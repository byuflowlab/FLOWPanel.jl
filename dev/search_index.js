var documenterSearchIndex = {"docs":
[{"location":"examples/duct-leastsquares/#Least-Squares-Solver","page":"Least-Squares Solver","title":"Least-Squares Solver","text":"","category":"section"},{"location":"examples/duct-leastsquares/","page":"Least-Squares Solver","title":"Least-Squares Solver","text":"It is well known that a purely doublet (or vortex ring) solver encounters difficulties when the geometry is closed (i.e., watertight). The flow field around a body is given by the vortex filaments that make the edges of the panel, and the strength of each filament is simply the difference between adjacent panels. Thus, in the absence of an open edge (like in a watertight geometry), the strengths of the vortex-ring elements become irrelevant, and the problem is purely determined by the difference in strength between adjacent panels. This leads to an overdetermined problem where one of the original degrees of freedom (panels strengths) has become redundant.","category":"page"},{"location":"examples/duct-leastsquares/","page":"Least-Squares Solver","title":"Least-Squares Solver","text":"Let n the number of panels. The problem is well defined for a open geometry formulating the solver as","category":"page"},{"location":"examples/duct-leastsquares/","page":"Least-Squares Solver","title":"Least-Squares Solver","text":"beginalign*\n    G Gamma = -b\nendalign*","category":"page"},{"location":"examples/duct-leastsquares/","page":"Least-Squares Solver","title":"Least-Squares Solver","text":"where b in mathbbR^n is the normal of the freestream condition at each panel that needs to be canceled (\"no-flow-through\" boundary condition), G in mathbbR^ntimes n contains the geometric information of the panels and Gamma in mathbbR^n is the strength of each vortex-ring panel. However, for a watertight geometry, G is no longer full rank and the problem becomes ill-conditioned. Due to numerical roundoff, the system of equations can still be inverted but the numerical solution ends up giving panel strengths (vortex-ring circulations) that are in the order of 10^16 and large numerical noise.","category":"page"},{"location":"examples/duct-leastsquares/","page":"Least-Squares Solver","title":"Least-Squares Solver","text":"In order to circumvent this issue, we can transform the original problem into a least-squares problem as follows. Since one of the panel strengths is redundant in a watertight geometry, we can simply pick an arbitrary panel and prescribe an arbitrary strength. Then, G has become a ntimes n-1 matrix, Gamma is a vector of length n-1, while b is still a vector of length n. To formulate the least-squares problem, we substract the velocity b_p induced by the \"prescribed\" panel  to the right-hand side,","category":"page"},{"location":"examples/duct-leastsquares/","page":"Least-Squares Solver","title":"Least-Squares Solver","text":"beginalign*\n    G Gamma = -b - b_p\nendalign*","category":"page"},{"location":"examples/duct-leastsquares/","page":"Least-Squares Solver","title":"Least-Squares Solver","text":"and we solve the problem as","category":"page"},{"location":"examples/duct-leastsquares/","page":"Least-Squares Solver","title":"Least-Squares Solver","text":"beginalign*\n    Gamma = - left( G^t G right)^-1 G^t left( b + b_p right)\nendalign*","category":"page"},{"location":"examples/duct-leastsquares/","page":"Least-Squares Solver","title":"Least-Squares Solver","text":"where the superscript t denotes the transposed matrix.","category":"page"},{"location":"examples/duct-leastsquares/","page":"Least-Squares Solver","title":"Least-Squares Solver","text":"Either solver (i.e., the original vortex-ring solver or the vortex-ring least-squares one) is automatically called whenever the function FLOWPanel.solve(body, Uinfs, Das, Dbs) is called. The solver to be used is identified based on the body type. A body type bodytype = pnl.RigidWakeBody{pnl.VortexRing} corresponds to the original vortex-ring solver, while the least-squares solver is called by declaring bodytype = pnl.RigidWakeBody{pnl.VortexRing, 2}.","category":"page"},{"location":"examples/duct-leastsquares/","page":"Least-Squares Solver","title":"Least-Squares Solver","text":"NOTE: The prescribed panel can be manually set by the user through the optional argument elprescribe = [(index, val), ...] of FLOWPanel.solve, which is a list of element to prescribe, where index is the linear index of the element and val is the prescribed element strength. If not set, the function defaults to FLOWPanel.solve(body, Uinfs, Das, Dbs; elprescribe=[(1, 0)])","category":"page"},{"location":"examples/duct-leastsquares/","page":"Least-Squares Solver","title":"Least-Squares Solver","text":"Even though both solvers lead to roughly the same flow field solution, the numerical noise of the ill-condition problem is evident when visualizing the potential field:","category":"page"},{"location":"examples/duct-leastsquares/","page":"Least-Squares Solver","title":"Least-Squares Solver","text":"<center>\n    <br><b>Vortex-Ring Solver</b><br>\n    <img src=\"../../assets/images/duct-hill0110-viz-phi00.png\" alt=\"Pic here\" style=\"width:70%;\"/>\n</center>\n<br>\n<center>\n    <br><b>Vortex-Ring Least-Squares Solver</b><br>\n    <img src=\"../../assets/images/duct-hill0111-viz-phi00.png\" alt=\"Pic here\" style=\"width:70%;\"/>\n</center>","category":"page"},{"location":"geometry/gridgeneration-triang/#Grid-Triangulation","page":"Grid Triangulation","title":"Grid Triangulation","text":"","category":"section"},{"location":"geometry/gridgeneration-triang/","page":"Grid Triangulation","title":"Grid Triangulation","text":"Since some element types require planar panels, the quadrilateral grids generated through the previous methods need to be transformed into triangular grids that ensure planar panels. This is done by splitting each quadrilateral panel into two triangular panel through the following function:","category":"page"},{"location":"geometry/gridgeneration-triang/","page":"Grid Triangulation","title":"Grid Triangulation","text":"FLOWPanel.GeometricTools.GridTriangleSurface","category":"page"},{"location":"geometry/gridgeneration-triang/#GeometricTools.GridTriangleSurface","page":"Grid Triangulation","title":"GeometricTools.GridTriangleSurface","text":"GridTriangleSurface(orggrid, dimsplit)\n\nReceives a 3D surface grid (like the one in Paneled Wing Example in the documentation), which by construction is made of nonplanar quadrilateral panels, and creates a surface grid of planar triangular panels by splitting every original quadrilateral panel into triangles.\n\nArguments\n\norggrid         : Original quadrilateral surface grid.\ndimsplit        : Dimension along which to split the quadrilaterals.\n\n\n\n\n\n","category":"type"},{"location":"geometry/gridgeneration-triang/#Triangulated-Lofted-Surface","page":"Grid Triangulation","title":"Triangulated Lofted Surface","text":"","category":"section"},{"location":"geometry/gridgeneration-triang/","page":"Grid Triangulation","title":"Grid Triangulation","text":"The indexing pattern of a triangulated lofted surface is shown below","category":"page"},{"location":"geometry/gridgeneration-triang/","page":"Grid Triangulation","title":"Grid Triangulation","text":"<center>\n  <table>\n      <tr>\n          <th>\n              <center>Node Index</center>\n          </th>\n          <th>\n              <center>Cell Index</center>\n          </th>\n      </tr>\n      <tr>\n          <th>\n              <img src=\"../../assets/images/loft-triang-nodeindex00.png\" alt=\"Pic here\" width=\"450px\">\n          </th>\n          <th>\n              <img src=\"../../assets/images/loft-triang-cellindex00.png\" alt=\"Pic here\" width=\"450px\">\n          </th>\n      </tr>\n  </table>\n</center>\n\n<br><br>\n\n<center>\n  <table>\n      <tr>\n          <th>\n              <center>First Coordinate</center>\n          </th>\n          <th>\n              <center>Second Coordinate</center>\n          </th>\n      </tr>\n      <tr>\n          <th>\n              <img src=\"../../assets/images/loft-triang-cellcoordinate03.png\" alt=\"Pic here\" width=\"450px\">\n          </th>\n          <th>\n              <img src=\"../../assets/images/loft-triang-cellcoordinate02.png\" alt=\"Pic here\" width=\"450px\">\n          </th>\n      </tr>\n  </table>\n</center>\n\n<br><br>\n\n<center>\n  <table>\n      <tr>\n          <th>\n              <center>Cell (1, 1)</center>\n          </th>\n          <th>\n              <center>Cell (31, 1)</center>\n          </th>\n          <th>\n              <center>Cell (30, 2)</center>\n          </th>\n      </tr>\n      <tr>\n          <th>\n              <img src=\"../../assets/images/loft-triang-cellnodes00.0000.png\" alt=\"Pic here\" width=\"450px\">\n          </th>\n          <th>\n              <img src=\"../../assets/images/loft-triang-cellnodes00.0002.png\" alt=\"Pic here\" width=\"450px\">\n          </th>\n          <th>\n              <img src=\"../../assets/images/loft-triang-cellnodes00.0005.png\" alt=\"Pic here\" width=\"450px\">\n          </th>\n      </tr>\n      <tr>\n          <th>\n              <center>Cell (2, 1)</center>\n          </th>\n          <th>\n              <center>Cell (32, 1)</center>\n          </th>\n          <th>\n              <center>Cell (1, 2)</center>\n          </th>\n      </tr>\n      <tr>\n          <th>\n              <img src=\"../../assets/images/loft-triang-cellnodes00.0001.png\" alt=\"Pic here\" width=\"450px\">\n          </th>\n          <th>\n              <img src=\"../../assets/images/loft-triang-cellnodes00.0003.png\" alt=\"Pic here\" width=\"450px\">\n          </th>\n          <th>\n              <img src=\"../../assets/images/loft-triang-cellnodes00.0004.png\" alt=\"Pic here\" width=\"450px\">\n          </th>\n      </tr>\n  </table>\n</center>\n\n<br><br>","category":"page"},{"location":"geometry/gridgeneration-triang/","page":"Grid Triangulation","title":"Grid Triangulation","text":"It is possible to define a normal vector on a planar panel, which is then used to define the panel coordinate system as explained in Panel Definition. The normal vector of each panel is shown here below in the left, while the orthonormal bases left( hatmathbft hatmathbfo hatmathbfn right) are shown in the right (hatmathbft = mathrmred, hatmathbfo = mathrmyellow, hatmathbfn = mathrmgreen).","category":"page"},{"location":"geometry/gridgeneration-triang/","page":"Grid Triangulation","title":"Grid Triangulation","text":"<center>\n  <table>\n      <tr>\n          <th>\n              <center>Normals</center>\n          </th>\n          <th>\n              <center>Panel Coordinate System</center>\n          </th>\n      </tr>\n      <tr>\n          <th>\n              <img src=\"../../assets/images/loft-triang-normals00.png\" alt=\"Pic here\" width=\"450px\">\n          </th>\n          <th>\n              <img src=\"../../assets/images/loft-triang-vectors03.png\" alt=\"Pic here\" width=\"450px\">\n          </th>\n      </tr>\n  </table>\n</center>","category":"page"},{"location":"geometry/gridgeneration-triang/#Triangulated-Surface-of-Revolution","page":"Grid Triangulation","title":"Triangulated Surface of Revolution","text":"","category":"section"},{"location":"geometry/gridgeneration-triang/","page":"Grid Triangulation","title":"Grid Triangulation","text":"The indexing pattern of a triangulated surface of revolution is shown below","category":"page"},{"location":"geometry/gridgeneration-triang/","page":"Grid Triangulation","title":"Grid Triangulation","text":"<center>\n  <table>\n      <tr>\n          <th>\n              <center>Node Index</center>\n          </th>\n          <th>\n              <center>Cell Index</center>\n          </th>\n      </tr>\n      <tr>\n          <th>\n              <img src=\"../../assets/images/bodyrev-triang-nodeindex-000transp.png\" alt=\"Pic here\" width=\"450px\">\n          </th>\n          <th>\n              <img src=\"../../assets/images/bodyrev-triang-cellindex-000transp.png\" alt=\"Pic here\" width=\"450px\">\n          </th>\n      </tr>\n  </table>\n</center>\n\n<br><br>\n\n<center>\n  <table>\n      <tr>\n          <th>\n              <center>First Coordinate</center>\n          </th>\n          <th>\n              <center>Second Coordinate</center>\n          </th>\n      </tr>\n      <tr>\n          <th>\n              <img src=\"../../assets/images/bodyrev-triang-cellindexdim1-002transp.png\" alt=\"Pic here\" width=\"450px\">\n          </th>\n          <th>\n              <img src=\"../../assets/images/bodyrev-triang-cellindexdim2-000transp.png\" alt=\"Pic here\" width=\"450px\">\n          </th>\n      </tr>\n  </table>\n</center>\n\n<br><br>\n\n<center>\n  <table>\n      <tr>\n          <th>\n              <center>Cell (1, 1)</center>\n          </th>\n          <th>\n              <center>Cell (79, 1)</center>\n          </th>\n          <th>\n              <center>Cell (78, 2)</center>\n          </th>\n      </tr>\n      <tr>\n          <th>\n              <img src=\"../../assets/images/bodyrev-triang-cell-000transp.0000.png\" alt=\"Pic here\" width=\"450px\">\n          </th>\n          <th>\n              <img src=\"../../assets/images/bodyrev-triang-cell-000transp.0002.png\" alt=\"Pic here\" width=\"450px\">\n          </th>\n          <th>\n              <img src=\"../../assets/images/bodyrev-triang-cell-000transp.0004.png\" alt=\"Pic here\" width=\"450px\">\n          </th>\n      </tr>\n      <tr>\n          <th>\n              <center>Cell (2, 1)</center>\n          </th>\n          <th>\n              <center>Cell (80, 1)</center>\n          </th>\n          <th>\n              <center>Cell (1, 2)</center>\n          </th>\n      </tr>\n      <tr>\n          <th>\n              <img src=\"../../assets/images/bodyrev-triang-cell-000transp.0001.png\" alt=\"Pic here\" width=\"450px\">\n          </th>\n          <th>\n              <img src=\"../../assets/images/bodyrev-triang-cell-000transp.0003.png\" alt=\"Pic here\" width=\"450px\">\n          </th>\n          <th>\n              <img src=\"../../assets/images/bodyrev-triang-cell-000transp.0005.png\" alt=\"Pic here\" width=\"450px\">\n          </th>\n      </tr>\n  </table>\n</center>\n\n<br><br>","category":"page"},{"location":"geometry/gridgeneration-triang/","page":"Grid Triangulation","title":"Grid Triangulation","text":"It is possible to define a normal vector on a planar panel, which is then used to define the panel coordinate system as explained in Panel Definition. The normal vector of each panel is shown here below in the left, while the orthonormal bases left( hatmathbft hatmathbfo hatmathbfn right) are shown in the right (hatmathbft = mathrmred, hatmathbfo = mathrmyellow, hatmathbfn = mathrmgreen).","category":"page"},{"location":"geometry/gridgeneration-triang/","page":"Grid Triangulation","title":"Grid Triangulation","text":"<center>\n  <table>\n      <tr>\n          <th>\n              <center>Normals</center>\n          </th>\n          <th>\n              <center>Panel Coordinate System</center>\n          </th>\n      </tr>\n      <tr>\n          <th>\n              <img src=\"../../assets/images/bodyrev-triang-normals-002transp.png\" alt=\"Pic here\" width=\"450px\">\n          </th>\n          <th>\n              <img src=\"../../assets/images/bodyrev-triang-coordinatesystem-000transp.png\" alt=\"Pic here\" width=\"450px\">\n          </th>\n      </tr>\n  </table>\n</center>","category":"page"},{"location":"examples/centerbody-vortexring/#Vortex-Ring-Elements","page":"Vortex Ring Elements","title":"Vortex Ring Elements","text":"","category":"section"},{"location":"examples/centerbody-vortexring/","page":"Vortex Ring Elements","title":"Vortex Ring Elements","text":"While source elements are physically adequate to model a non-lifting body, in some circumstances it may be benefitial to use all vortex ring elements. A thick body with only vortex ring elements leads to a surface velocity that is inaccurate at the exact surface of the body, but that approximates the physical solution away from the surface. For this reason, we probe the velocity used to calculate Cp slightly away from the body.","category":"page"},{"location":"examples/centerbody-vortexring/","page":"Vortex Ring Elements","title":"Vortex Ring Elements","text":"Here we repeat the example using only vortex ring elements.","category":"page"},{"location":"examples/centerbody-vortexring/","page":"Vortex Ring Elements","title":"Vortex Ring Elements","text":"bodytype = pnl.RigidWakeBody{pnl.VortexRing}    # Elements and wake model\n\nbody = pnl.generate_revolution_liftbody(bodytype, points, NDIVS_theta;\n                                        # Loop the azimuthal dimension to close the surface\n                                        loop_dim=2,\n                                        # Rotate the axis of rotation to align with x-axis\n                                        axis_angle=90,\n                                        # Indicate that this body is open at the trailing edge\n                                        closed_contour=false)\n\n\n# ----------------- CALL SOLVER ------------------------------------------------\nprintln(\"Solving body...\")\n\n# Freestream at every control point\nUinfs = repeat(Vinf, 1, body.ncells)\n\n# Unitary direction of semi-infinite vortex at points `a` and `b` of each\n# trailing edge panel\n# NOTE: In this case they are empty arrays since there is no wake\nDas = repeat(Vinf/magVinf, 1, body.nsheddings)\nDbs = repeat(Vinf/magVinf, 1, body.nsheddings)\n\n# Solve body (panel strengths) giving `Uinfs` as boundary conditions and\n# `Das` and `Dbs` as trailing edge rigid wake direction\n@time pnl.solve(body, Uinfs, Das, Dbs)\n\n\n# ----------------- POST PROCESSING --------------------------------------------\nprintln(\"Post processing...\")\n# NOTE: A thick body with only vortex ring elements leads to a surface velocity\n#       that is inaccurate at the exact surface of the body, but that\n#       approximates the physical solution away from the surface. For this\n#       reason, we probe the velocity used to calculate Cp slightly away from\n#       the body\n\n# Calculate surface velocity on the body\nUs = pnl.calcfield_U(body, body)\n\n# NOTE: Since the boundary integral equation of the potential flow has a\n#       discontinuity at the boundary, we need to add the gradient of the\n#       doublet strength to get an accurate surface velocity\n\n# Calculate surface velocity U_∇μ due to the gradient of the doublet strength\nUDeltaGamma = pnl.calcfield_Ugradmu(body)\n\n# Add both velocities together\npnl.addfields(body, \"Ugradmu\", \"U\")\n\n# Calculate pressure coefficient\nCps = pnl.calcfield_Cp(body, magVinf)\n\n# Calculate the force of each panel\nFs = pnl.calcfield_F(body, magVinf, rho)\n\n","category":"page"},{"location":"examples/centerbody-vortexring/","page":"Vortex Ring Elements","title":"Vortex Ring Elements","text":"<center>\n    <br><b>Surface velocity</b><br>\n    <img src=\"../../assets/images/centerbody-lewis00-velocity-vortexring.png\" alt=\"Pic here\" style=\"width: 60%;\"/>\n</center>","category":"page"},{"location":"elements/paneldefinition/#Panel-Definition","page":"Panel Definition","title":"Panel Definition","text":"","category":"section"},{"location":"elements/paneldefinition/","page":"Panel Definition","title":"Panel Definition","text":"In order to compute and/or solve the boundary integral equation, we discretize the numerical boundaries of our domain through numerical elements, forming what is called a boundary element method. or BEM. The geometry of our problem is discretized into panels. To each panel then we associate one or multiple types of elements described in this section.","category":"page"},{"location":"elements/paneldefinition/","page":"Panel Definition","title":"Panel Definition","text":"Given a planar polygonal panel, we define the following unitary vectors following the right-hand rule as follows","category":"page"},{"location":"elements/paneldefinition/","page":"Panel Definition","title":"Panel Definition","text":"<center>\n  <img src=\"../../assets/images/panelcs00.png\" alt=\"Pic here\" width=\"400px\">\n</center>","category":"page"},{"location":"elements/paneldefinition/","page":"Panel Definition","title":"Panel Definition","text":"beginalign*\n        textTangent vectorqquad\n        \n        hatmathbft = fracmathbfp_2 - mathbfp_1Vert mathbfp_2 - mathbfp_1 Vert\n    \n        textNormal vectorqquad\n        \n        hatmathbfn = frac\n                                    left( mathbfp_2 - mathbfp_1 right)\n                                    times\n                                    left( mathbfp_3 - mathbfp_1 right)\n                                leftVert\n                                    left( mathbfp_2 - mathbfp_1 right)\n                                    times\n                                    left( mathbfp_3 - mathbfp_1 right)\n                                rightVert\n    \n        textOblique vectorqquad\n        \n        hatmathbfo = hatmathbfn times hatmathbft\nendalign*","category":"page"},{"location":"elements/paneldefinition/","page":"Panel Definition","title":"Panel Definition","text":"This defines the orthonormal basis left( hatmathbft hatmathbfo hatmathbfn right) which, along with the panel's centroid, define the panel's local coordinate system. This basis follows hatmathbft times hatmathbfo = hatmathbfn, hatmathbfo times hatmathbfn = hatmathbft, and hatmathbfn times hatmathbft = hatmathbfo.","category":"page"},{"location":"examples/duct-aoasweep/","page":"AOA Sweep","title":"AOA Sweep","text":"<center>\n  <img src=\"../../assets/images/duct-hill-aoa15-0001-viz-glyph00.png\" alt=\"Pic here\" style=\"width: 100%;\"/>\n</center>","category":"page"},{"location":"examples/duct-aoasweep/","page":"AOA Sweep","title":"AOA Sweep","text":"In this example we solve the flow around a fan duct (aka annular airfoil or engine cowl) at an angle of attack leading to asymmetric flow. The geometry is generated as a body of revolution that is watertight.","category":"page"},{"location":"examples/duct-aoasweep/#AOA-Sweep","page":"AOA Sweep","title":"AOA Sweep","text":"","category":"section"},{"location":"examples/duct-aoasweep/","page":"AOA Sweep","title":"AOA Sweep","text":"Here we generate the duct as a body of revolution and then we run a sweep of inflow angle of attack","category":"page"},{"location":"examples/duct-aoasweep/","page":"AOA Sweep","title":"AOA Sweep","text":"#=##############################################################################\n# DESCRIPTION\n    Fan duct replicating the experiment reported by V. P. Hill (1978), \"A\n    Surface Vorticity Theory for Propeller Ducts and Turbofan Engine Cowls in\n    Non-Axisymmetric Incompressible Flow.\" The same experiment is also\n    discussed in Sections 4.4 and 6.3.1 of Lewis, R. (1991), \"Vortex Element\n    Methods for Fluid Dynamic Analysis of Engineering Systems.\"\n\n# AUTHORSHIP\n  * Author    : Eduardo J. Alvarez\n  * Email     : Edo.AlvarezR@gmail.com\n  * Created   : Jan 2023\n  * License   : MIT License\n=###############################################################################\n\nimport FLOWPanel as pnl\nimport CSV\nimport DataFrames: DataFrame\n\ninclude(joinpath(pnl.examples_path, \"duct_postprocessing.jl\"))\n\nrun_name        = \"duct-hill00\"             # Name of this run\n\nsave_path       = run_name                  # Where to save outputs\nfluiddomain     = false                     # Whether to generate fluid domain\nparaview        = true                      # Whether to visualize with Paraview\n\nsave_plots      = false                     # Whether to save plots or not\n# Where to save plots (default to re-generating the figures that are used\n# in the docs)\nfig_path = joinpath(pnl.examples_path, \"..\", \"docs\", \"resources\", \"images\")\n\n\n# ----------------- SIMULATION PARAMETERS --------------------------------------\nAOAs            = [0, 5, 15]                # (deg) angles of attack to evaluate\nmagVinf         = 30.0                      # (m/s) freestream velocity\nrho             = 1.225                     # (kg/m^3) air density\n\n\n# ----------------- GEOMETRY DESCRIPTION ---------------------------------------\n# Read duct contour (table in figure 7.4 of Lewis 1991)\nfilename        = joinpath(pnl.examples_path, \"data\", \"naca662015.csv\")\ncontour         = CSV.read(filename, DataFrame)\n\naspectratio     = 0.6                       # Duct trailing edge aspect ratio l/d\nd               = 2*0.835                   # (m) duct diameter\n\n\n# ----------------- SOLVER PARAMETERS ------------------------------------------\n# Discretization\nNDIVS_theta     = 60                        # Number of azimuthal panels\n\n# NOTE: NDIVS is the number of divisions (panels) in each dimension. This can be\n#       either an integer, or an array of tuples as shown below\n\nn_rfl           = 10                        # This controls the number of chordwise panels\n\nNDIVS_rfl_up = [                            # Discretization of airfoil upper surface\n            # 0 to 0.25 of the airfoil has `n_rfl` panels at a geometric expansion of 10 that is not central\n                (0.25, n_rfl,   10.0, false),\n            # 0.25 to 0.75 of the airfoil has `n_rfl` panels evenly spaced\n                (0.50, n_rfl,    1.0, true),\n            # 0.75 to 1.00 of the airfoil has `n_rfl` panels at a geometric expansion of 0.1 that is not central\n                (0.25, n_rfl,    0.1, false)]\n\nNDIVS_rfl_lo = NDIVS_rfl_up                 # Discretization of airfoil lower surface\n\n# NOTE: A geometric expansion of 10 that is not central means that the last\n#       panel is 10 times larger than the first panel. If central, the\n#       middle panel is 10 times larger than the peripheral panels.\n\n# Solver: Vortex-ring least-squares\nbodytype        = pnl.RigidWakeBody{pnl.VortexRing, 2} # Elements and wake model\n\n\n# ----------------- GENERATE BODY ----------------------------------------------\n# Re-discretize the contour of the body of revolution according to NDIVS\nxs, ys = pnl.gt.rediscretize_airfoil(contour[:, 1], contour[:, 2],\n                                        NDIVS_rfl_up, NDIVS_rfl_lo;\n                                        verify_spline=false)\n\n# Make sure that the contour is closed\nys[end] = ys[1]\n\n# Scale contour by duct length\nxs *= d*aspectratio\nys *= d*aspectratio\n\n# Move contour to the radial position\nys .+= d/2\n\n# Collect points that make the contour of the body of revolution\npoints = hcat(xs, ys)\n\n# Generate body of revolution\nbody = pnl.generate_revolution_liftbody(bodytype, points, NDIVS_theta;\n                                        bodyoptargs = (\n                                                        CPoffset=1e-14,\n                                                        kerneloffset=1e-8,\n                                                        kernelcutoff=1e-14,\n                                                        characteristiclength=(args...)->d*aspectratio\n                                            )\n                                        )\n\nprintln(\"Number of panels:\\t$(body.ncells)\")\n\nvtks = save_path*\"/\"                        # String with VTK output files\n\n\n# ----------------- CALL SOLVER ------------------------------------------------\nfor (i, AOA) in enumerate(AOAs)             # Sweep over angle of attack\n\n    println(\"Solving body...\")\n\n    # Freestream vector\n    Vinf = magVinf*[cos(AOA*pi/180), 0, sin(AOA*pi/180)]\n\n    # Freestream at every control point\n    Uinfs = repeat(Vinf, 1, body.ncells)\n\n    # Unitary direction of semi-infinite vortex at points `a` and `b` of each\n    # trailing edge panel\n    Das = repeat(Vinf/magVinf, 1, body.nsheddings)\n    Dbs = repeat(Vinf/magVinf, 1, body.nsheddings)\n\n    # Solve body (panel strengths) giving `Uinfs` as boundary conditions and\n    # `Das` and `Dbs` as trailing edge rigid wake direction\n    @time pnl.solve(body, Uinfs, Das, Dbs)\n\n    # ----------------- POST PROCESSING ----------------------------------------\n    println(\"Post processing...\")\n\n    # Calculate surface velocity U on the body\n    Us = pnl.calcfield_U(body, body)\n\n    # NOTE: Since the boundary integral equation of the potential flow has a\n    #       discontinuity at the boundary, we need to add the gradient of the\n    #       doublet strength to get an accurate surface velocity\n\n    # Calculate surface velocity U_∇μ due to the gradient of the doublet strength\n    # UDeltaGamma = pnl.calcfield_Ugradmu(body)\n    UDeltaGamma = pnl.calcfield_Ugradmu(body; sharpTE=true, force_cellTE=false)\n\n    # Add both velocities together\n    pnl.addfields(body, \"Ugradmu\", \"U\")\n\n    # Calculate pressure coefficient (based on U + U_∇μ)\n    @time Cps = pnl.calcfield_Cp(body, magVinf)\n\n    # Calculate the force of each panel (based on Cp)\n    @time Fs = pnl.calcfield_F(body, magVinf, rho)\n\n    # ----------------- COMPARISON TO EXPERIMENTAL DATA ------------------------\n    # Plot surface pressure along slices of the duct\n    fig, axs = plot_Cp(body, AOA)\n\n    if save_plots\n        fname = \"$(run_name)-Cp-AOA$(ceil(Int, AOA)).png\"\n        fig.savefig(joinpath(fig_path, fname), dpi=300, transparent=true)\n    end\n\n    # ----------------- VISUALIZATION ------------------------------------------\n    # Compute fluid domain and save as VTK\n    if fluiddomain\n        global vtks *= generate_fluiddomain(body, AOA, Vinf, d,\n                                                aspectratio, save_path; num=i)\n    end\n\n    # Save body as VTK\n    if paraview\n        global vtks *= pnl.save(body, \"duct\"; path=save_path, num=i,\n                                        wake_panel=false, debug=true)\n    end\n\nend\n\n# Call Paraview\nif paraview\n    run(`paraview --data=$(vtks)`)\nend","category":"page"},{"location":"examples/duct-aoasweep/","page":"AOA Sweep","title":"AOA Sweep","text":"(see the complete example under examples/duct.jl )","category":"page"},{"location":"examples/duct-aoasweep/","page":"AOA Sweep","title":"AOA Sweep","text":"<center>\n    <br><b>No AOA (symmetric flow)</b><br>\n    <img src=\"../../assets/images/duct-hill00-Cp-AOA0.png\" alt=\"Pic here\" style=\"width:100%;\"/>\n</center>\n\n<center>\n    <br><b>5° angle of attack</b><br>\n    <img src=\"../../assets/images/duct-hill00-Cp-AOA5.png\" alt=\"Pic here\" style=\"width:100%;\"/>\n</center>\n\n<center>\n    <br><b>15° angle of attack</b><br>\n    <img src=\"../../assets/images/duct-hill00-Cp-AOA15.png\" alt=\"Pic here\" style=\"width:100%;\"/>\n</center>","category":"page"},{"location":"examples/duct-aoasweep/","page":"AOA Sweep","title":"AOA Sweep","text":"In the plots above, the upper and lower sides correspond to the slice shown here below:","category":"page"},{"location":"examples/duct-aoasweep/","page":"AOA Sweep","title":"AOA Sweep","text":"<center>\n  <img src=\"../../assets/images/duct-hill-aoa15-slice02.png\" alt=\"Pic here\" style=\"width: 100%;\"/>\n</center>","category":"page"},{"location":"geometry/basics-transformations/#Space-Transformations","page":"Space Transformations","title":"Space Transformations","text":"","category":"section"},{"location":"geometry/basics-transformations/","page":"Space Transformations","title":"Space Transformations","text":"A Cartesian grid can be used as the starting point to define a more complex structured grid through any arbitrary non-linear transformation:","category":"page"},{"location":"geometry/basics-transformations/","page":"Space Transformations","title":"Space Transformations","text":"FLOWPanel.GeometricTools.transform!\nFLOWPanel.GeometricTools.lintransform!","category":"page"},{"location":"geometry/basics-transformations/#GeometricTools.transform!","page":"Space Transformations","title":"GeometricTools.transform!","text":"transform!(grid::Grid, f)\n\nApplies the space transformation given by function f to the grid, where the position of every node is given to the function f.\n\n\n\n\n\n","category":"function"},{"location":"geometry/basics-transformations/#GeometricTools.lintransform!","page":"Space Transformations","title":"GeometricTools.lintransform!","text":"lintransform!(grid::Grid, M::Array{Float64,2}, T::Array{Float64,1})\n\nRotates and translates the grid by the rotation matrix M and translation vector T (linear transformation).\n\n\n\n\n\n","category":"function"},{"location":"geometry/basics-transformations/","page":"Space Transformations","title":"Space Transformations","text":"GeometricTools provides the following non-linear orthogonal space transformations: cylindrical3D(X), cylindrical2D(X), spherical3D(X), parabolic3D(X), paraboloidal3D(X), elliptic3D(X; a=1), prolate3D(X; a=1), oblate3D(X; a=1), bipolar3D(X; a=1), toroidal3D(X; a=1), and conical3D(X; b=2, c=1).","category":"page"},{"location":"geometry/basics-transformations/","page":"Space Transformations","title":"Space Transformations","text":"For linear transformations, rotation_matrix(yaw::Real, pitch::Real, roll::Real) returns the rotation matrix of such angles, and axis_rotation(r::Array{Float64, 1}, angle_deg::Float64) returns the transformation matrix of rotation around an arbitrary axis of unit vector r.","category":"page"},{"location":"geometry/basics-transformations/","page":"Space Transformations","title":"Space Transformations","text":"The user can also define an arbitrary space transformation. The airfoil example in the Looped Grid section shows the example of transforming a quasi-one-dimensional line into an two-dimensional airfoil contour.","category":"page"},{"location":"geometry/basics-transformations/#Example-—-2D-circular-grid","page":"Space Transformations","title":"Example — 2D circular grid","text":"","category":"section"},{"location":"geometry/basics-transformations/","page":"Space Transformations","title":"Space Transformations","text":"To demonstrate the use of space transformations, in this example we generate a two-dimensional circular grid. First we define the boundaries of the circular section r_textmin r_textmax theta_textmin theta_textmax as a cartesian grid of minimum and maximum bounds P_textmin=(r_textmin theta_textmin) and P_textmax=(r_textmax theta_textmax), respectively. We then applying a cylindrical transformation on the grid. The cylindrical transformation takes the current xy coordinates of the grid as rtheta for the new grid. In this case, r_textmin=R4, r_textmax=R, theta_textmin=0^circ, theta_textmax=270^circ, as shown below.","category":"page"},{"location":"geometry/basics-transformations/","page":"Space Transformations","title":"Space Transformations","text":"import GeometricTools as gt\n\nfile_name = \"circulargrid00\"                # Output file\nparaview = true                             # Whether to visualize the grid in Paraview\n\nR = 1.0                   # Radius of circle\n\nP_min = [R/4, 0*pi/180]   # Lower boundaries r, theta\nP_max = [R, 270*pi/180]   # Upper boundaries r, theta\n\nNDIVS = [15, 60]          # 15 radius divisions, 60 angle divisions\n\n# Generate the Cartesian grid\ngrid = gt.Grid(P_min, P_max, NDIVS)\n\n# Convert grid to cylindrical\ngt.transform!(grid, gt.cylindrical2D)\n\n# Visualization\nif paraview\n\n    # Output a vtk file\n    gt.save(grid, file_name; format=\"vtk\")\n\n    # Call paraview\n    run(`paraview --data=$file_name.vtk`)\n\nelse\n    # Use PyPlot instead of Paraview\n    gt.plot(grid; labelnodes=!true, labelcells=!true, labelndivs=true)\nend;","category":"page"},{"location":"geometry/basics-transformations/","page":"Space Transformations","title":"Space Transformations","text":"<img src=\"../../assets/images/circ01.png\" alt=\"Pic here\" style=\"width: 600px;\"/>\n<br><br>","category":"page"},{"location":"geometry/basics-transformations/","page":"Space Transformations","title":"Space Transformations","text":"Notice that NDIVS can still be used to defined sections of refinement:","category":"page"},{"location":"geometry/basics-transformations/","page":"Space Transformations","title":"Space Transformations","text":"import GeometricTools as gt\n\nfile_name = \"circulargrid01\"                # Output file\nparaview = true                             # Whether to visualize the grid in Paraview\n\nNDIVS = [   # r sections\n            [(1.0, 15, 5.0, true)],\n            # theta sections\n            [(1/3, 15, 1/3, false),\n             (1/3, 15, 3.0, true),\n             (1/3, 15, 3.0, false)]\n        ]\n\n# Generates the grid as cartesian\ngrid = gt.Grid(P_min, P_max, NDIVS)\n\n# Converts to cylindrical\ngt.transform!(grid, gt.cylindrical2D)\n\n# Visualization\nif paraview\n\n    # Outputs a vtk file\n    gt.save(grid, file_name; format=\"vtk\")\n\n    # Calls paraview\n    run(`paraview --data=$file_name.vtk`)\nelse\n    # Use PyPlot instead of Paraview\n    gt.plot(grid; labelnodes=!true, labelcells=!true, labelndivs=true)\nend;","category":"page"},{"location":"geometry/basics-transformations/","page":"Space Transformations","title":"Space Transformations","text":"<img src=\"../../assets/images/circ02.png\" alt=\"Pic here\" style=\"width: 600px;\"/>","category":"page"},{"location":"examples/sweptwing-4p2aoa/","page":"4.2° Angle of Attack","title":"4.2° Angle of Attack","text":"<center>\n  <img src=\"../../assets/images/sweptwing-viz00.png\" alt=\"Pic here\" style=\"width: 100%;\"/>\n</center>","category":"page"},{"location":"examples/sweptwing-4p2aoa/","page":"4.2° Angle of Attack","title":"4.2° Angle of Attack","text":"In this example we solve the flow around a 45^circ swept-back wing at an angle of attack of 42^circ using a rigid wake model.","category":"page"},{"location":"examples/sweptwing-4p2aoa/#4.2\\circ-Angle-of-Attack","page":"4.2° Angle of Attack","title":"42^circ Angle of Attack","text":"","category":"section"},{"location":"examples/sweptwing-4p2aoa/","page":"4.2° Angle of Attack","title":"4.2° Angle of Attack","text":"#=##############################################################################\n# DESCRIPTION\n    45deg swept-back wing at an angle of attack of 4.2deg. This wing has an\n    aspect ratio of 5.0, a RAE 101 airfoil section with 12% thickness, and no\n    dihedral, twist, nor taper. This test case matches the experimental setup\n    of Weber, J., and Brebner, G., “Low-Speed Tests on 45-deg Swept-Back Wings,\n    Part I,” Tech. rep., 1951.\n\n# AUTHORSHIP\n  * Author    : Eduardo J. Alvarez\n  * Email     : Edo.AlvarezR@gmail.com\n  * Created   : Dec 2022\n  * License   : MIT License\n=###############################################################################\n\nimport FLOWPanel as pnl\n\nrun_name        = \"sweptwing000\"                # Name of this run\n\nsave_path       = run_name                      # Where to save outputs\nairfoil_path    = joinpath(pnl.examples_path, \"data\") # Where to find airfoil contours\n\nparaview        = true                          # Whether to visualize with Paraview\n\n# ----------------- SIMULATION PARAMETERS --------------------------------------\nAOA             = 4.2                           # (deg) angle of attack\nmagVinf         = 30.0                          # (m/s) freestream velocity\nVinf            = magVinf*[cos(AOA*pi/180), 0, sin(AOA*pi/180)] # Freestream\n\nrho             = 1.225                         # (kg/m^3) air density\n\n# ----------------- GEOMETRY DESCRIPTION ---------------------------------------\nb               = 98*0.0254                     # (m) span length\nar              = 5.0                           # Aspect ratio b/c_tip\ntr              = 1.0                           # Taper ratio c_tip/c_root\ntwist_root      = 0                             # (deg) twist at root\ntwist_tip       = 0                             # (deg) twist at tip\nlambda          = 45                            # (deg) sweep\ngamma           = 0                             # (deg) dihedral\nairfoil         = \"airfoil-rae101.csv\"          # Airfoil contour file\n\n# ----- Chordwise discretization\n\n# NOTE: NDIVS is the number of divisions (panels) in each dimension. This an be\n#       either an integer, or an array of tuples as shown below\n\nn_rfl           = 8                             # Control number of chordwise panels\n# n_rfl         = 10                            # <-- uncomment this for finer discretization\n\n#           # 0 to 0.25 of the airfoil has `n_rfl` panels at a geometric expansion of 10 that is not central\nNDIVS_rfl = [ (0.25, n_rfl,   10.0, false),\n            # 0.25 to 0.75 of the airfoil has `n_rfl` panels evenly spaced\n              (0.50, n_rfl,    1.0, true),\n            # 0.75 to 1.00 of the airfoil has `n_rfl` panels at a geometric expansion of 0.1 that is not central\n              (0.25, n_rfl, 1/10.0, false)]\n\n# NOTE: A geometric expansion of 10 that is not central means that the last\n#       panel is 10 times larger than the first panel. If central, the\n#       middle panel is 10 times larger than the peripheral panels.\n\n# ----- Spanwise discretization\nn_span          = 15                            # Number of spanwise panels on each side of the wing\n# n_span        = 60                            # <-- uncomment this for finer discretization\n\nNDIVS_span_l    = [(1.0, n_span, 10.0, false)]  # Discretization of left side\nNDIVS_span_r    = [(1.0, n_span, 10.0, false)]  # Discretization of right side\n\n\n# ----------------- GENERATE BODY ----------------------------------------------\nprintln(\"Generating body...\")\n\n#= NOTE: Here we loft each side of the wing independently. One could also loft\n        the entire wing at once from left tip to right tip, but the sweep of the\n        wing would lead to an asymmetric discretization with the panels of left\n        side side would have a higher aspect ratio than those of the right side.\n        To avoid that, instead we loft the left side from left to right, then we\n        loft to right side from right to left, and we combine left and right\n        sides into a MultiBody that represents the wing.\n=#\n\nbodytype = pnl.RigidWakeBody{pnl.VortexRing}    # Elements and wake model\n\n# Arguments for lofting the left side of the wing\nbodyoptargs_l = (;\n                    CPoffset=1e-14,                 # Offset control points slightly in the positive normal direction\n                )\n\n# Same arguments but negative CPoffset since the normals are flipped\nbodyoptargs_r = (;\n                    CPoffset=-1e-14\n                )\n\n# Loft left side of the wing from left to right\n@time wing_left = pnl.simplewing(b, ar, tr, twist_root, twist_tip, lambda, gamma;\n                            bodytype=bodytype, bodyoptargs=bodyoptargs_l,\n                            airfoil_root=airfoil, airfoil_tip=airfoil,\n                            airfoil_path=airfoil_path,\n                            rfl_NDIVS=NDIVS_rfl,\n                            delim=\",\",\n                            span_NDIVS=NDIVS_span_l,\n                            b_low=-1.0, b_up=0.0\n                           )\n\n# Loft right side of the wing from right to left\n@time wing_right = pnl.simplewing(b, ar, tr, twist_root, twist_tip, lambda, gamma;\n                            bodytype=bodytype, bodyoptargs=bodyoptargs_r,\n                            airfoil_root=airfoil, airfoil_tip=airfoil,\n                            airfoil_path=airfoil_path,\n                            rfl_NDIVS=NDIVS_rfl,\n                            delim=\",\",\n                            span_NDIVS=NDIVS_span_r,\n                            b_low=1.0, b_up=0.0,\n                           )\n\n# Put both sides together to make a wing with symmetric discretization\nbodies = [wing_left, wing_right]\nnames = [\"L\", \"R\"]\n\n@time body = pnl.MultiBody(bodies, names)\n\n\nprintln(\"Number of panels:\\t$(body.ncells)\")\n\n\n# ----------------- CALL SOLVER ------------------------------------------------\nprintln(\"Solving body...\")\n\n# Freestream at every control point\nUinfs = repeat(Vinf, 1, body.ncells)\n\n# Unitary direction of semi-infinite vortex at points `a` and `b` of each\n# trailing edge panel\nDas = repeat(Vinf/magVinf, 1, body.nsheddings)\nDbs = repeat(Vinf/magVinf, 1, body.nsheddings)\n\n# Solve body (panel strengths) giving `Uinfs` as boundary conditions and\n# `Das` and `Dbs` as trailing edge rigid wake direction\n@time pnl.solve(body, Uinfs, Das, Dbs)\n\n\n# ----------------- POST PROCESSING --------------------------------------------\nprintln(\"Post processing...\")\n\n# Calculate surface velocity induced by the body on itself\n@time Us = pnl.calcfield_U(body, body)\n\n# NOTE: Since the boundary integral equation of the potential flow has a\n#       discontinuity at the boundary, we need to add the gradient of the\n#       doublet strength to get an accurate surface velocity\n\n# Calculate surface velocity U_∇μ due to the gradient of the doublet strength\nUDeltaGamma = pnl.calcfield_Ugradmu(body)\n\n# Add both velocities together\npnl.addfields(body, \"Ugradmu\", \"U\")\n\n# Calculate pressure coefficient\n@time Cps = pnl.calcfield_Cp(body, magVinf)\n\n# Calculate the force of each panel\n@time Fs = pnl.calcfield_F(body, magVinf, rho)\n\n\n# ----------------- VISUALIZATION ----------------------------------------------\nif paraview\n    str = save_path*\"/\"\n\n    # Save body as a VTK\n    str *= pnl.save(body, \"wing\"; path=save_path)\n\n    # Call Paraview\n    run(`paraview --data=$(str)`)\nend\n\n\n\n","category":"page"},{"location":"examples/sweptwing-4p2aoa/","page":"4.2° Angle of Attack","title":"4.2° Angle of Attack","text":"(see the complete example under examples/sweptwing.jl to see how to postprocess the solution to calculate the slices of pressure distribution and spanwise loading that is plotted here below)","category":"page"},{"location":"examples/sweptwing-4p2aoa/","page":"4.2° Angle of Attack","title":"4.2° Angle of Attack","text":"<center>\n    <br><b>Chordwise pressure distribution</b>\n    <img src=\"../../assets/images/sweptwing000-chordpressure.png\" alt=\"Pic here\" style=\"width: 100%;\"/>\n\n    <br><br><b>Pressure difference</b>\n    <img src=\"../../assets/images/sweptwing000-deltapressure.png\" alt=\"Pic here\" style=\"width: 100%;\"/>\n\n    <br><br><b>Spanwise loading distribution</b>\n    <img src=\"../../assets/images/sweptwing000-loading.png\" alt=\"Pic here\" style=\"width: 100%;\"/>\n</center>","category":"page"},{"location":"examples/sweptwing-4p2aoa/","page":"4.2° Angle of Attack","title":"4.2° Angle of Attack","text":" Experimental FLOWPanel Error OPENVSP\nC_L 0.238 0.272 14.1% 0.257\nC_D 0.005 0.0066 32.0% 0.0033","category":"page"},{"location":"examples/sweptwing-4p2aoa/","page":"4.2° Angle of Attack","title":"4.2° Angle of Attack","text":"details: Tip\nYou can also automatically run this example and generate these plots with the following command:import FLOWPanel as pnl\n\ninclude(joinpath(pnl.examples_path, \"sweptwing.jl\"))","category":"page"},{"location":"elements/constantvortexsheet/#Constant-Strength-Vortex-Sheet","page":"Constant Vortex Sheet","title":"Constant-Strength Vortex Sheet","text":"","category":"section"},{"location":"elements/constantvortexsheet/","page":"Constant Vortex Sheet","title":"Constant Vortex Sheet","text":"(Adapted from David Pate's 2017 doctoral dissertation A Surface Vorticity Method for Wake-Body Interactions, and Pate and German (2018), A Surface Vorticity Panel Method)","category":"page"},{"location":"elements/constantvortexsheet/","page":"Constant Vortex Sheet","title":"Constant Vortex Sheet","text":"The velocity induced by a vortex sheet at a target point mathbfx is the integral of the Biot-Savart law over the surface of the sheet:","category":"page"},{"location":"elements/constantvortexsheet/","page":"Constant Vortex Sheet","title":"Constant Vortex Sheet","text":"beginalign*\n        mathbfu(mathbfx)\n    =\n        frac14pi\n        intlimits_S\n            fracmathbfr times boldsymbolgammaVert mathbfr Vert^3\n        mathrmd S\nendalign*","category":"page"},{"location":"elements/constantvortexsheet/","page":"Constant Vortex Sheet","title":"Constant Vortex Sheet","text":"where mathrmr = mathbfx - mathbfx is the vector directed from the target to the differential mathrmdS.","category":"page"},{"location":"elements/constantvortexsheet/","page":"Constant Vortex Sheet","title":"Constant Vortex Sheet","text":"In order to evaluate this integral, we follow the procedure put forth by Pate 2017. First, we define a local coordinate system at the projection of point mathbfx unto the plane of the triangle as shown below:","category":"page"},{"location":"elements/constantvortexsheet/","page":"Constant Vortex Sheet","title":"Constant Vortex Sheet","text":"<center>\n  <img src=\"../../assets/images/pate-figa1.png\" alt=\"Pic here\" style=\"width:50%;\"/>\n  <br>\n  <span style=\"color:gray\">(figure retrieved from <a href=\"https://smartech.gatech.edu/handle/1853/58265\">Pate 2017</a>)</span>\n  <br><br>\n</center>","category":"page"},{"location":"elements/constantvortexsheet/","page":"Constant Vortex Sheet","title":"Constant Vortex Sheet","text":"The projection point mathbfp_x (or P_B in the figure above) is calculated as mathbfp_x = mathbfx - left (mathbfx - mathbfp_1)cdot hatmathbfn right hatmathbfn, and the orthonormal basis (mathbfb_1 mathbfb_2 mathbfb_3)  is completely arbitrary except for requiring mathbfb_3 = hatmathbfn. We also define the vector directed from mathbfp_x to the differential as boldsymbolrho equiv mathbfx - mathbfp_x. We then define the following three triangles S_1 S_2 S_3 that will be used for the integration:","category":"page"},{"location":"elements/constantvortexsheet/","page":"Constant Vortex Sheet","title":"Constant Vortex Sheet","text":"<center>\n  <img src=\"../../assets/images/pate-figa2.png\" alt=\"Pic here\" style=\"width:35%;\"/>\n  <br>\n  <span style=\"color:gray\">(figure retrieved from <a href=\"https://smartech.gatech.edu/handle/1853/58265\">Pate 2017</a>)</span>\n  <br><br>\n</center>","category":"page"},{"location":"elements/constantvortexsheet/","page":"Constant Vortex Sheet","title":"Constant Vortex Sheet","text":"where, mathbfq_i = mathbfp_i - mathbfp_x. S_1 is the triangle of vertices (mathbfp_x mathbfp_1 mathbfp_2), S_2 is (mathbfp_x mathbfp_2 mathbfp_3), and S_3 is (mathbfp_x mathbfp_3 mathbfp_1). More generally, the vertices of triangle S_i in the global coordinate system are (mathbfp_x mathbfp_i mathbfp_i+1), with mathbfp_4 = mathbfp_1. In the coordinate system with origin at mathbfp_x and basis (mathbfb_1 mathbfb_2 mathbfb_3), the vertices of triangle S_i are","category":"page"},{"location":"elements/constantvortexsheet/","page":"Constant Vortex Sheet","title":"Constant Vortex Sheet","text":"beginalign*\n    boxed\n        (mathbf0 mathbfq_1 mathbfq_2)_i\n    =\n        (mathbfp_x mathbfp_i - mathbfp_x mathbfp_i+1 - mathbfp_x)\n    \nendalign*","category":"page"},{"location":"elements/constantvortexsheet/","page":"Constant Vortex Sheet","title":"Constant Vortex Sheet","text":"For each triangle S_i, Pate then proceeds to define the following orthonormal basis (mathbfc_1 mathbfc_2 mathbfc_3):","category":"page"},{"location":"elements/constantvortexsheet/","page":"Constant Vortex Sheet","title":"Constant Vortex Sheet","text":"<center>\n  <img src=\"../../assets/images/pate-figa3.png\" alt=\"Pic here\" style=\"width:35%;\"/>\n  <br>\n  <span style=\"color:gray\">(figure retrieved from <a href=\"https://smartech.gatech.edu/handle/1853/58265\">Pate 2017</a>)</span>\n  <br><br>\n</center>","category":"page"},{"location":"elements/constantvortexsheet/","page":"Constant Vortex Sheet","title":"Constant Vortex Sheet","text":"beginalign*\n            mathbfc_3\n         equiv\n            mathbfb_3 = hatmathbfn\n    \n            mathbfc_2\n         equiv\n            fracmathbfq_2 - mathbfq_1Vert mathbfq_2 - mathbfq_1 Vert\n    \n            mathbfc_1\n         equiv\n            mathbfc_2 times mathbfc_3\nendalign*","category":"page"},{"location":"elements/constantvortexsheet/","page":"Constant Vortex Sheet","title":"Constant Vortex Sheet","text":"The vector boldsymbolrho is then decomposed in this basis as","category":"page"},{"location":"elements/constantvortexsheet/","page":"Constant Vortex Sheet","title":"Constant Vortex Sheet","text":"beginalign*\n        boldsymbolrho\n     =\n        u mathbfc_1 + v mathbfc_2\nendalign*","category":"page"},{"location":"elements/constantvortexsheet/","page":"Constant Vortex Sheet","title":"Constant Vortex Sheet","text":"where","category":"page"},{"location":"elements/constantvortexsheet/","page":"Constant Vortex Sheet","title":"Constant Vortex Sheet","text":"beginalign*\n        u\n     equiv\n        boldsymbolrho cdot mathbfc_1\n    \n        v\n     equiv\n        boldsymbolrho cdot mathbfc_2\nendalign*","category":"page"},{"location":"elements/constantvortexsheet/","page":"Constant Vortex Sheet","title":"Constant Vortex Sheet","text":"The full-distance vector mathbfr (pointing from mathbfx to the differential) is decomposed as","category":"page"},{"location":"elements/constantvortexsheet/","page":"Constant Vortex Sheet","title":"Constant Vortex Sheet","text":"beginalign*\n        mathbfr\n     =\n        u mathbfc_1 + v mathbfc_2 - z mathbfc_3\nendalign*","category":"page"},{"location":"elements/constantvortexsheet/","page":"Constant Vortex Sheet","title":"Constant Vortex Sheet","text":"where","category":"page"},{"location":"elements/constantvortexsheet/","page":"Constant Vortex Sheet","title":"Constant Vortex Sheet","text":"beginalign*\n        z\n     equiv\n        left( mathbfx - mathbfp_1 right) cdot hatmathbfn\nendalign*","category":"page"},{"location":"elements/constantvortexsheet/","page":"Constant Vortex Sheet","title":"Constant Vortex Sheet","text":"while the constant strength of the vortex sheet is decomposed as","category":"page"},{"location":"elements/constantvortexsheet/","page":"Constant Vortex Sheet","title":"Constant Vortex Sheet","text":"beginalign*\n        boldsymbolgamma\n     =\n        a_00 mathbfc_1 + b_00 mathbfc_2\nendalign*","category":"page"},{"location":"elements/constantvortexsheet/","page":"Constant Vortex Sheet","title":"Constant Vortex Sheet","text":"where","category":"page"},{"location":"elements/constantvortexsheet/","page":"Constant Vortex Sheet","title":"Constant Vortex Sheet","text":"beginalign*\n        a_00\n     equiv\n        boldsymbolgamma cdot mathbfc_1\n    \n        b_00\n     equiv\n        boldsymbolgamma cdot mathbfc_2\nendalign*","category":"page"},{"location":"elements/constantvortexsheet/","page":"Constant Vortex Sheet","title":"Constant Vortex Sheet","text":"The numerator in the integral of the Biot-Savart law then becomes","category":"page"},{"location":"elements/constantvortexsheet/","page":"Constant Vortex Sheet","title":"Constant Vortex Sheet","text":"beginalign*\n        mathbfr times boldsymbolgamma\n     =\n        z b_00 mathbfc_1 - z a_00 mathbfc_2 + (u b_00 - v a_00) mathbfc_3\nendalign*","category":"page"},{"location":"elements/constantvortexsheet/","page":"Constant Vortex Sheet","title":"Constant Vortex Sheet","text":"In order to avoid the singularity when the denominator of the integral becomes zero, we add a small offset delta to the distance of the denominator defining boxedr equiv sqrtu^2 + v^2 + z^2 + delta^2. We also add the same offset to the height of the target as boxedh equiv sqrtz^2 + delta^2, effectively defining a thickness for the sheet.","category":"page"},{"location":"elements/constantvortexsheet/","page":"Constant Vortex Sheet","title":"Constant Vortex Sheet","text":"The integral over the original triange S can then be expressed in terms of S_1, S_2, and S_3 as","category":"page"},{"location":"elements/constantvortexsheet/","page":"Constant Vortex Sheet","title":"Constant Vortex Sheet","text":"beginalign*\n        intlimits_S\n            fracmathbfr times boldsymbolgammar^3\n        mathrmd S\n    =\n        sumlimits_i\n        intlimits_S_i\n            fracmathbfr times boldsymbolgammar^3\n        mathrmd S_i\nendalign*","category":"page"},{"location":"elements/constantvortexsheet/","page":"Constant Vortex Sheet","title":"Constant Vortex Sheet","text":"The integral terms H_00, H_10, and H_01 are given in Pate 2017, Appendix A.4:","category":"page"},{"location":"elements/constantvortexsheet/","page":"Constant Vortex Sheet","title":"Constant Vortex Sheet","text":"beginalign*\n    \n           H_00\n       =\n           frac1h tan^-1leftleft(\n               fracal a^2 + h^2 + hsqrtl^2 + a^2 + h^2\n           right)rightrvert_l_1^l_2\n     \n           H_10\n       =\n           left\n           left\n               fraclsqrtl^2 + a^2 lnleft( sqrtl^2 + a^2 + h^2 + sqrtl^2 + a^2 right)\n               -\n               lnleft( l + sqrtl^2 + a^2 + h^2 right)\n               -\n               fracl ln h sqrtl^2 + a^2\n           right\n           rightrvert_l_1^l_2\n     \n           H_01\n       =\n           left\n           left\n               fracasqrtl^2 + a^2\n               left\n                   ln h\n                   -\n                   lnleft( sqrtl^2 + a^2 + h^2 + sqrtl^2 + a^2 right)\n               right\n           right\n           rightrvert_l_1^l_2\nendalign*","category":"page"},{"location":"elements/constantvortexsheet/","page":"Constant Vortex Sheet","title":"Constant Vortex Sheet","text":"and the integral over S_i is calculated as","category":"page"},{"location":"elements/constantvortexsheet/","page":"Constant Vortex Sheet","title":"Constant Vortex Sheet","text":"beginalign*\n            intlimits_S_i\n                fracmathbfr times boldsymbolgammar^3\n            mathrmd S_i\n        =\n            z b_00 mathbfc_1\n            underbrace\n                intlimits_S_i  \n                    frac1r^3\n                mathrmd S_i\n            _H_00\n        -\n            z a_00 mathbfc_2\n            underbrace\n                intlimits_S_i\n                    frac1r^3\n                mathrmd S_i\n            _H_00\n        +\n            b_00 mathbfc_3\n            underbrace\n                intlimits_S_i\n                    fracur^3\n                mathrmd S_i\n            _H_10\n        -\n            a_00 mathbfc_3\n            underbrace\n                intlimits_S_i\n                    fracvr^3\n                mathrmd S_i\n            _H_01\nendalign*","category":"page"},{"location":"elements/constantvortexsheet/","page":"Constant Vortex Sheet","title":"Constant Vortex Sheet","text":"The integral terms H_00, H_10, and H_01 are given in Pate 2017, Appendix A.4:","category":"page"},{"location":"elements/constantvortexsheet/","page":"Constant Vortex Sheet","title":"Constant Vortex Sheet","text":"beginalign*\n    \n           H_00\n       =\n           frac1h tan^-1leftleft(\n               fracal a^2 + h^2 + hsqrtl^2 + a^2 + h^2\n           right)rightrvert_l_1^l_2\n     \n           H_10\n       =\n           left\n           left\n               fraclsqrtl^2 + a^2 lnleft( sqrtl^2 + a^2 + h^2 + sqrtl^2 + a^2 right)\n               -\n               lnleft( l + sqrtl^2 + a^2 + h^2 right)\n               -\n               fracl ln h sqrtl^2 + a^2\n           right\n           rightrvert_l_1^l_2\n     \n           H_01\n       =\n           left\n           left\n               fracasqrtl^2 + a^2\n               left\n                   ln h\n                   -\n                   lnleft( sqrtl^2 + a^2 + h^2 + sqrtl^2 + a^2 right)\n               right\n           right\n           rightrvert_l_1^l_2\nendalign*","category":"page"},{"location":"elements/constantvortexsheet/","page":"Constant Vortex Sheet","title":"Constant Vortex Sheet","text":"where","category":"page"},{"location":"elements/constantvortexsheet/","page":"Constant Vortex Sheet","title":"Constant Vortex Sheet","text":"beginalign*\n    \n       a = mathbfq_1 cdot mathbfc_1\n    \n       l_1 = mathbfq_1 cdot mathbfc_2\n    \n       l_2 = mathbfq_2 cdot mathbfc_2\n    \n       h = sqrtz^2 + delta^2\n    \n       z = left( mathbfx - mathbfp_1 right) cdot hatmathbfn\nendalign*","category":"page"},{"location":"elements/constantvortexsheet/","page":"Constant Vortex Sheet","title":"Constant Vortex Sheet","text":"NOTE: H_10 and H_01 becomes undefined when the projection of mathbfx onto the panel plane lays on one of the vertices, leading to the a division of zero by zero in fraclsqrtl^2 + a^2 and fracasqrtl^2 + a^2. Both H_10 and H_01 actually converge to 0 in that situation, and can be manually prescibed to that value.","category":"page"},{"location":"elements/constantvortexsheet/","page":"Constant Vortex Sheet","title":"Constant Vortex Sheet","text":"Finally, the velocity induced by the sheet is evaluated as","category":"page"},{"location":"elements/constantvortexsheet/","page":"Constant Vortex Sheet","title":"Constant Vortex Sheet","text":"beginalign*\n    boxed\n            mathbfu(mathbfx)\n        =\n            frac14pi\n            intlimits_S\n                fracmathbfr times boldsymbolgammaVert mathbfr Vert^3\n            mathrmd S\n        =\n            frac14pi\n            sumlimits_i\n            left\n                z b_00 H_00 mathbfc_1\n                -\n                z a_00 H_00 mathbfc_2\n                +\n                left(b_00 H_10 - a_00 H_01right) mathbfc_3\n            right\n    \n    \nendalign*","category":"page"},{"location":"elements/constantvortexsheet/","page":"Constant Vortex Sheet","title":"Constant Vortex Sheet","text":"To speed up computation, we can use trigonometric and logarithmic identities to rewrite the formulas given by Pate as","category":"page"},{"location":"elements/constantvortexsheet/","page":"Constant Vortex Sheet","title":"Constant Vortex Sheet","text":"beginalign*\n    \n           H_00\n       =\n           frac1h tan^-1left(\n               fracm_2 - m_11 + m_1 m_2\n           right)\n           qquad text where  quad\n           m_i = fracal_i a^2 + h^2 + hsqrtl_i^2 + a^2 + h^2\n     \n           H_10\n       =\n           lnleft( fracm_2m_1 right)\n           qquad text where  quad\n           m_i = frac1l_i + sqrtl_i^2 + a^2 + h^2\n               left(\n                   fracsqrtl_i^2 + a^2 + h^2 + sqrtl_i^2 + a^2h\n               right)^fracl_isqrtl_i^2 + a^2\n     \n           H_01\n       =\n               -\n               ln left(\n                   fracm_2m_1\n               right)\n           qquad text where  quad\n           m_i = left( fracsqrtl_i^2 + a^2 + h^2 + sqrtl_i^2 + a^2h right)^fracasqrtl_i^2 + a^2\nendalign*","category":"page"},{"location":"elements/constantvortexsheet/","page":"Constant Vortex Sheet","title":"Constant Vortex Sheet","text":"thus reducing the number of log and tan^-1 evaluations.","category":"page"},{"location":"elements/constantvortexsheet/","page":"Constant Vortex Sheet","title":"Constant Vortex Sheet","text":"<center>\n  <table>\n      <tr>\n          <td>\n              <img src=\"../../assets/images/vortexsheet-viz-w02.png\" alt=\"Pic here\" width=\"100%\">\n          </td>\n          <td>\n              <img src=\"../../assets/images/vortexsheet-viz-u02.png\" alt=\"Pic here\" width=\"100%\">\n          </td>\n      </tr>\n  </table>\n</center>","category":"page"},{"location":"elements/constantvortexsheet/","page":"Constant Vortex Sheet","title":"Constant Vortex Sheet","text":"<center>\n    <img src=\"../../assets/images/constantvortexsheet01-probe1.png\" alt=\"Pic here\" width=\"90%\">\n    <img src=\"../../assets/images/constantvortexsheet01-probe2.png\" alt=\"Pic here\" width=\"90%\">\n    <img src=\"../../assets/images/constantvortexsheet01-probe3.png\" alt=\"Pic here\" width=\"90%\">\n</center>","category":"page"},{"location":"examples/cessna-openvsp/","page":"OpenVSP Model","title":"OpenVSP Model","text":"<center>\n  <img src=\"https://edoalvar2.groups.et.byu.net/public/FLOWPanel/cessna002.jpg\" alt=\"Pic here\" style=\"width: 100%;\"/>\n</center>","category":"page"},{"location":"examples/cessna-openvsp/","page":"OpenVSP Model","title":"OpenVSP Model","text":"In this example we analyze a Cessna 210 aircraft that is generated using OpenVSP. We show how to polish and mesh the OpenVSP model, and the mesh is then read by FLOWPanel using Meshes.jl.","category":"page"},{"location":"examples/cessna-openvsp/","page":"OpenVSP Model","title":"OpenVSP Model","text":"To run this tutorial you will have to install a few dependencies for processing unstructured grids:","category":"page"},{"location":"examples/cessna-openvsp/","page":"OpenVSP Model","title":"OpenVSP Model","text":"import Pkg\n\nPkg.add(Meshes)\nPkg.add(GeoIO)\nPkg.add(Rotations)","category":"page"},{"location":"examples/cessna-openvsp/#OpenVSP-Model","page":"OpenVSP Model","title":"OpenVSP Model","text":"","category":"section"},{"location":"examples/cessna-openvsp/","page":"OpenVSP Model","title":"OpenVSP Model","text":"We will use the Cessna 210 model that is available in the OpenVSP Ground School as the starting point (you can also download the .vsp3 file directly from here, right click → save as...). Follow the steps below to polish the model, mesh it, and export the mesh.","category":"page"},{"location":"examples/cessna-openvsp/#Polish-the-Model","page":"OpenVSP Model","title":"Polish the Model","text":"","category":"section"},{"location":"examples/cessna-openvsp/","page":"OpenVSP Model","title":"OpenVSP Model","text":"If you try to run the model as-is through the OpenVSP aero solver, you might notice that VSPAERO crashes. This is an indication that the model needs some clean up and polish before we can do any numerical analysis with it.","category":"page"},{"location":"examples/cessna-openvsp/","page":"OpenVSP Model","title":"OpenVSP Model","text":"We recommend doing the following modifications to the model,","category":"page"},{"location":"examples/cessna-openvsp/","page":"OpenVSP Model","title":"OpenVSP Model","text":"Round up the wing tips to avoid sharp edges\nSharpen the wing trailing edge\nMerge the prop spinner with the main body by translating it to close the gap\nAdequately adapt the mesh resolution:\nRefinement towards wing tips\nRefinement towards both wing LE and TE\nAvoid abrupt changes in cell sizes","category":"page"},{"location":"examples/cessna-openvsp/","page":"OpenVSP Model","title":"OpenVSP Model","text":"<center>\n    <span style=\"font-size: 1.1em; color:black;\"><b>\n        Before\n    </b></span>\n    <br>\n    <img src=\"https://edoalvar2.groups.et.byu.net/public/FLOWPanel/openvsp000.png\" alt=\"Pic here\" style=\"width: 100%;\"/>\n</center>\n<br>\n<center>\n    <span style=\"font-size: 1.1em; color:black;\"><b>\n        After\n    </b></span>\n    <br>\n    <img src=\"https://edoalvar2.groups.et.byu.net/public/FLOWPanel/openvsp001.png\" alt=\"Pic here\" style=\"width: 100%;\"/>\n</center>","category":"page"},{"location":"examples/cessna-openvsp/","page":"OpenVSP Model","title":"OpenVSP Model","text":"info: OpenVSP Files\nThe .vsp3 files are available here: [before] [after] (right click → save as...).","category":"page"},{"location":"examples/cessna-openvsp/#Quality-Check","page":"OpenVSP Model","title":"Quality Check","text":"","category":"section"},{"location":"examples/cessna-openvsp/","page":"OpenVSP Model","title":"OpenVSP Model","text":"Make sure that the OPENVSP aero solver (VSPAERO) can successfully perform analysis with the mesh:","category":"page"},{"location":"examples/cessna-openvsp/","page":"OpenVSP Model","title":"OpenVSP Model","text":"Confirm that the analysis completes without returning nans\nConfirm that the analysis returns reasonable values for C_L and C_D\nVisualize the wake and make sure that the body is not improperly   interfering with the wake (e.g.,, wake penetrating into the body)\nVisualize C_p and make sure that there aren't any regions where the   solution blows up","category":"page"},{"location":"examples/cessna-openvsp/","page":"OpenVSP Model","title":"OpenVSP Model","text":"If VSPAERO can't successfully do numerical analysis with this mesh, it is likely that FLOWPanel will also fail.","category":"page"},{"location":"examples/cessna-openvsp/#Export","page":"OpenVSP Model","title":"Export","text":"","category":"section"},{"location":"examples/cessna-openvsp/","page":"OpenVSP Model","title":"OpenVSP Model","text":"Export mesh: File > Export > Gmsh (.msh)\nExport NURBS: File > Export > Untrimmed STEP (.stp), set length unit to MM, and set tolerance to 1e-12=","category":"page"},{"location":"examples/cessna-openvsp/","page":"OpenVSP Model","title":"OpenVSP Model","text":"OpenVSP exports .msh files in an older format that is not compatible with Meshes.jl, so here we recommend using Gmsh to convert the .msh file to a newer version:","category":"page"},{"location":"examples/cessna-openvsp/","page":"OpenVSP Model","title":"OpenVSP Model","text":"Open the .msh file in Gmsh\nRe-export .msh in ASCII format v4: File > Export and select   Mesh - Gmsh MSH (*.msh) in the dropdown menu","category":"page"},{"location":"examples/cessna-openvsp/","page":"OpenVSP Model","title":"OpenVSP Model","text":"info: Mesh Files\nThe resulting .msh and .stp files are available here: cessna.msh cessna.stp (right click → save as...).","category":"page"},{"location":"examples/blendedwingbody-aero/","page":"Import Mesh and Solve","title":"Import Mesh and Solve","text":"<center>\n  <img src=\"http://edoalvar2.groups.et.byu.net/public/FLOWPanel/zeroebwb005.jpg\" alt=\"Pic here\" style=\"width: 100%;\"/>\n</center>","category":"page"},{"location":"examples/blendedwingbody-aero/#Import-Mesh-and-Solve","page":"Import Mesh and Solve","title":"Import Mesh and Solve","text":"","category":"section"},{"location":"examples/blendedwingbody-aero/","page":"Import Mesh and Solve","title":"Import Mesh and Solve","text":"Here we import the mesh into FLOWPanel using Meshes.jl, identify the trailing edge, and run the watertight solver.","category":"page"},{"location":"examples/blendedwingbody-aero/","page":"Import Mesh and Solve","title":"Import Mesh and Solve","text":"info: Default Gmsh files\nWe have pre-generated and uploaded a Gmsh mesh to this example so that you can run this section without needing to complete the previous sections. However, if you would like to use your own mesh, simply change read_path, meshfile, and trailingedgefile to point to your files.","category":"page"},{"location":"examples/blendedwingbody-aero/","page":"Import Mesh and Solve","title":"Import Mesh and Solve","text":"#=##############################################################################\n# DESCRIPTION\n    Blended wing body resembling the Airbus ZEROe BWB twin-engine subscale\n    model. The mesh used in this analysis was created using SolidWorks + Gmsh.\n\n# AUTHORSHIP\n  * Author    : Eduardo J. Alvarez\n  * Email     : Edo.AlvarezR@gmail.com\n  * Created   : Apri 2024\n  * License   : MIT License\n=###############################################################################\n\nimport FLOWPanel as pnl\nimport FLOWPanel: norm, dot, cross\n\nimport Meshes\nimport GeoIO\nimport Rotations: RotX, RotY, RotZ\n\n# import CUDA                               # Uncomment this to use GPU (if available)\n\n\nrun_name        = \"blendedwing\"             # Name of this run\n\nsave_path       = run_name                  # Where to save outputs\nparaview        = true                      # Whether to visualize with Paraview\nread_path       = joinpath(pnl.examples_path, \"data\") # Where to read Gmsh files from\n\n# ----------------- SIMULATION PARAMETERS --------------------------------------\nAOA             = 10.0                      # (deg) freestream angle of attack\nmagVinf         = 30.0                      # (m/s) freestream velocity\nrho             = 1.225                     # (kg/m^3) air density\n\n\n# ----------------- GEOMETRY DESCRIPTION ---------------------------------------\nmeshfile        = joinpath(read_path, \"zeroebwb.msh\")    # Gmsh file to read\ntrailingedgefile= joinpath(read_path, \"zeroebwb-TE.msh\") # Gmsh file with trailing edge\n\noffset          = [0, 0, 0]                 # Offset to center the mesh\nrotation        = RotZ(-90*pi/180)*RotX(90*pi/180) # Rotation to align mesh\nscaling         = 2e-3                      # Factor to scale original mesh to\n                                            # the approximate dimensions of the\n                                            # ZEROEe BWB subscale model\n\nspandir         = [0, 1, 0]                 # Span direction used to orient the trailing edge\nflip            = false                     # Whether to flip control points against the direction of normals\n                                            # NOTE: use `flip=true` if the normals\n                                            #       point inside the body\n\nSref            = 3.23^2 / 8.0             # (m^2) reference area\n\n# ----------------- SOLVER SETTINGS -------------------------------------------\n\n# Solver: direct linear solver for open bodies\n# bodytype = pnl.RigidWakeBody{pnl.VortexRing} # Wake model and element type\n\n# Solver: least-squares solver for watertight bodies\nbodytype        = pnl.RigidWakeBody{pnl.VortexRing, 2}\n\n\n# ----------------- GENERATE BODY ----------------------------------------------\n# Read Gmsh mesh\nmsh = GeoIO.load(meshfile)\nmsh = msh.geometry\n\n# Read Gmsh line of trailing edge\nTEmsh = GeoIO.load(trailingedgefile)\nTEmsh = TEmsh.geometry\n\n# Transform the original mesh: Translate, rotate, and scale\nmsh = msh |> Meshes.Translate(offset...) |> Meshes.Rotate(rotation) |> Meshes.Scale(scaling)\n\n# Apply the same transformations to the trailing edge\nTEmsh = TEmsh |> Meshes.Translate(offset...) |> Meshes.Rotate(rotation) |> Meshes.Scale(scaling)\n\n# Wrap Meshes object into a Grid object from GeometricTools\ngrid = pnl.gt.GridTriangleSurface(msh)\n\n# Convert TE Meshes object into a matrix of points used to identify the trailing edge\ntrailingedge = pnl.gt.vertices2nodes(TEmsh.vertices)\n\n# Sort TE points from left to right\ntrailingedge = sortslices(trailingedge; dims=2, by = X -> pnl.dot(X, spandir))\n\n# Estimate span length (used as a reference length)\nspantips = extrema(X -> pnl.dot(X, spandir), eachcol(trailingedge))\nspan = spantips[2] - spantips[1]\n\n# Generate TE shedding matrix\nshedding = pnl.calc_shedding(grid, trailingedge; tolerance=0.001*span)\n\n# Generate paneled body\nbody = bodytype(grid, shedding; CPoffset=(-1)^flip * 1e-14)\n\nprintln(\"Number of panels:\\t$(body.ncells)\")\n\n\n# ----------------- CALL SOLVER ------------------------------------------------\nprintln(\"Solving body...\")\n\n# Freestream vector\nVinf = magVinf*[cos(AOA*pi/180), 0, sin(AOA*pi/180)]\n\n# Freestream at every control point\nUinfs = repeat(Vinf, 1, body.ncells)\n\n# Unitary direction of semi-infinite vortex at points `a` and `b` of each\n# trailing edge panel\nDas = repeat(Vinf/magVinf, 1, body.nsheddings)\nDbs = repeat(Vinf/magVinf, 1, body.nsheddings)\n\n# Solve body (panel strengths) giving `Uinfs` as boundary conditions and\n# `Das` and `Dbs` as trailing edge rigid wake direction\n@time pnl.solve(body, Uinfs, Das, Dbs)\n\n# Uncomment this to use GPU instead (if available)\n# @time pnl.solve(body, Uinfs, Das, Dbs; GPUArray=CUDA.CuArray{Float32})\n\n# ----------------- POST PROCESSING ----------------------------------------\nprintln(\"Post processing...\")\n\n# Calculate surface velocity U on the body\nUs = pnl.calcfield_U(body, body)\n\n# NOTE: Since the boundary integral equation of the potential flow has a\n#       discontinuity at the boundary, we need to add the gradient of the\n#       doublet strength to get an accurate surface velocity\n\n# Calculate surface velocity U_∇μ due to the gradient of the doublet strength\nUDeltaGamma = pnl.calcfield_Ugradmu(body)\n# UDeltaGamma = pnl.calcfield_Ugradmu(body; sharpTE=true, force_cellTE=false)\n\n# Add both velocities together\npnl.addfields(body, \"Ugradmu\", \"U\")\n\n# Calculate pressure coefficient (based on U + U_∇μ)\n@time Cps = pnl.calcfield_Cp(body, magVinf)\n\n# Calculate the force of each panel (based on Cp)\n@time Fs = pnl.calcfield_F(body, magVinf, rho)\n\n# Calculate total force of the vehicle decomposed as lift, drag, and sideslip\nDhat = Vinf/norm(Vinf)                      # Drag direction\nShat = [0, 1, 0]                            # Span direction\nLhat = cross(Dhat, Shat)                    # Lift direction\n\nLDS = pnl.calcfield_LDS(body, Lhat, Dhat)\n\nL = LDS[:, 1]\nD = LDS[:, 2]\n\n# Force coefficients\nnondim = 0.5*rho*magVinf^2*Sref             # Normalization factor\nCL = sign(dot(L, Lhat)) * norm(L) / nondim\nCD = sign(dot(D, Dhat)) * norm(D) / nondim\n\n@show L\n@show D\n@show CL\n@show CD\n\n# ----------------- VISUALIZATION ------------------------------------------\n\n# Save body as VTK\nvtks = save_path*\"/\"                        # String with VTK output files\nvtks *= pnl.save(body, run_name; path=save_path)\n\n# Call Paraview\nif paraview\n    run(`paraview --data=$(vtks)`)\nend","category":"page"},{"location":"examples/blendedwingbody-aero/","page":"Import Mesh and Solve","title":"Import Mesh and Solve","text":"<span style=\"font-size: 0.9em; color:gray;\"><i>\n    Number of panels: 22,000. <br>\n    Run time: ~90 seconds on a Dell Precision 7760 laptop (no GPU). <br>\n</i></span>\n<br><br>","category":"page"},{"location":"examples/blendedwingbody-aero/","page":"Import Mesh and Solve","title":"Import Mesh and Solve","text":"<center>\n  <img src=\"http://edoalvar2.groups.et.byu.net/public/FLOWPanel/zeroebwb009.jpg\" alt=\"Pic here\" style=\"width: 100%;\"/>\n  <img src=\"http://edoalvar2.groups.et.byu.net/public/FLOWPanel/zeroebwb004.jpg\" alt=\"Pic here\" style=\"width: 100%;\"/>\n</center>\n<br><br>\n<br><br>","category":"page"},{"location":"examples/blendedwingbody-aero/","page":"Import Mesh and Solve","title":"Import Mesh and Solve","text":"details: Tip\nYou can also automatically run this example with the following command:import FLOWPanel as pnl\n\ninclude(joinpath(pnl.examples_path, \"blendedwingbody.jl\"))","category":"page"},{"location":"examples/blendedwingbody-aero/","page":"Import Mesh and Solve","title":"Import Mesh and Solve","text":"tip: Checklist for importing meshes\nCheck whether normals point into the body: Using the flag  debug=true in pnl.save(body, run_name; path=save_path, debug=true)  will output the control points of the body along with the associated  normal vector of each panel.      We recommend opening the body and control points in ParaView and  visualizing the normals with the Glyph filter.      Whenever the normals are pointing into the body, the user needs  to flip the offset of the  control points with CPoffset=-1e-14 or any other negligibly small  negative number. This won't flip the normals outwards, but it will flip  the zero-potential domain from outwards back to inside the body  (achieved by shifting the control points slightly into the body).  If you pull up the solution in ParaView and realize that the surface  velocity is much smaller than the freestream everywhere along the  aircraft, that's an indication that the normals are point inwards  and you need to set CPoffset to be negative.\nCheck that the trailing edge was correctly identified:  pnl.save(body, run_name; path=save_path) automatically outputes the  wake.      We recommend opening the body and wake in ParaView and visually  inspecting that the wake runs along the trailing edge line that you  defined under trailingedge.      If not successful, increase the resolution of trailingedge and tighten  the tolerance to something small like  pnl.calc_shedding(grid, trailingedge; tolerance=0.0001*span).\nChoose the right solver for the geometry:  Use the least-squares solver with watertight bodies  (bodytype = pnl.RigidWakeBody{pnl.VortexRing, 2}), and the direct  linear solver with open bodies  (bodytype = pnl.RigidWakeBody{pnl.VortexRing}). The least-squares  solver runs much faster in GPU  (pnl.solve(body, Uinfs, Das, Dbs; GPUArray=CUDA.CuArray{Float32})),  but it comes at the price of sacrificing accuracy (single precision  numbers as opposed to double).","category":"page"},{"location":"geometry/basics-grid/#Cartesian-Grid","page":"Cartesian Grid","title":"Cartesian Grid","text":"","category":"section"},{"location":"geometry/basics-grid/","page":"Cartesian Grid","title":"Cartesian Grid","text":"The object Grid defines a structured cartesian n-dimensional grid and it is the base for all other types of grids. Here below is the object constructor and associated functions. For examples see the documentation of GeometricTools.","category":"page"},{"location":"geometry/basics-grid/","page":"Cartesian Grid","title":"Cartesian Grid","text":"FLOWPanel.GeometricTools.Grid\nFLOWPanel.GeometricTools.get_node\nFLOWPanel.GeometricTools.get_cell","category":"page"},{"location":"geometry/basics-grid/#GeometricTools.Grid","page":"Cartesian Grid","title":"GeometricTools.Grid","text":"Grid(P_min, P_max, NDIVS)\n\nGenerates an n-dimensional grid.\n\nArguments\n\nP_min::Array{Float64,1}   : Minimum point of the domain.\nP_max::Array{Float64,1}   : Maximum point of the domain.\nNDIVS::Array{Int64,1}     : Number of divisions in each coordinate.\n\nProperties\n\ndims::Int64               : Number of dimensions.\nnnodes::Int64             : Number of nodes in the grid.\nnodes::Array{Float64,2}   : Matrix size (nnodes, dims) of node position.\nfield : Contains calculated fields formated as field[fieldname] = Dict(                         \"fieldname\" => fieldname::String,                         \"fieldtype\" => \"scalar\" or \"vector\",                         \"entrytype\" => \"node\" or \"cell\",                         \"fielddata\" => data                         )         where data is an array data[i] = [val1, val2, ...] containing         this field values (scalar or vector) at each node in the grid.\n\nNOTE: All indexing is done linearly, meaning that nodes is indexed from 1 to       nnodes, and all data fields follow the same indexing.\n\nNOTE2: NDIVS can either be an array of integers with NDIVS[i] indicating the       number of divisions in the i-th coordinate, or it can be an array of       sections (see multidiscretize() doc) with NDIVS[i] = [sec1, sec2, ...]       indicating the discretization into sections in the i-th coordinate.\n\n\n\n\n\n","category":"type"},{"location":"geometry/basics-grid/#GeometricTools.get_node","page":"Cartesian Grid","title":"GeometricTools.get_node","text":"get_node(grid, i)\n\nReturns the position of the i-th node (1-indexed) in the grid\n\n\n\n\n\nget_node(grid, coor)\n\nReturns the position of the node of subscript coordinates coor (1-indexed)\n\n\n\n\n\n","category":"function"},{"location":"geometry/basics-grid/#GeometricTools.get_cell","page":"Cartesian Grid","title":"GeometricTools.get_cell","text":"get_cell(grid, i)\n\nReturns the nodes indices of i-th cell in the grid (1-indexed)\n\n\n\n\n\nget_cell(grid, coor)\n\nReturns the node indices of the cell with subscript coordinates coor (1-indexed). The format corresponds to VTKHEXAHEDRON (=12) in 3D, VTKQUAD (=9) in 2D, or VTK_LINE (=3) in 1D–-except that points are 1-indexed instead of 0-indexed.\n\n\n\n\n\n","category":"function"},{"location":"geometry/basics-grid/","page":"Cartesian Grid","title":"Cartesian Grid","text":"<center>\n  <table style=\"width:100%\">\n    <tr>\n      <td>\n          <img src=\"../../assets/images/vtk00.png\" alt=\"Pic here\" style=\"width: 200px;\"/>\n      </td>\n      <td>\n          <img src=\"../../assets/images/vtk01.png\" alt=\"Pic here\" style=\"width: 150px;\"/>\n      </td>\n      <td>\n          <img src=\"../../assets/images/vtk02.png\" alt=\"Pic here\" style=\"width: 200px;\"/>\n      </td>\n    </tr>\n  </table>\n</center>","category":"page"},{"location":"elements/constantsource/#Constant-Strength-Source","page":"Constant Source","title":"Constant-Strength Source","text":"","category":"section"},{"location":"elements/constantsource/","page":"Constant Source","title":"Constant Source","text":"(Adapted fron Hess, J. L., & Smith, A. M. O. (1967), Calculation of potential flow about arbitrary bodies)","category":"page"},{"location":"elements/constantsource/","page":"Constant Source","title":"Constant Source","text":"Given the following planar polygonal panel","category":"page"},{"location":"elements/constantsource/","page":"Constant Source","title":"Constant Source","text":"<center>\n  <img src=\"../../assets/images/panel-HS00.png\" alt=\"Pic here\" style=\"width: 400px;\"/>\n</center>","category":"page"},{"location":"elements/constantsource/","page":"Constant Source","title":"Constant Source","text":"the potential at an arbitrary point (x y z) is calculated in the panel's coordinate system with constant-strength source as","category":"page"},{"location":"elements/constantsource/","page":"Constant Source","title":"Constant Source","text":"  beginalign*\n        phi\n    =\n        -fracsigma4pi intlimits_S fracmathrmdSr\n  endalign*","category":"page"},{"location":"elements/constantsource/","page":"Constant Source","title":"Constant Source","text":"with r=sqrt(x-xi)^2 + (y-eta)^2 + z^2.","category":"page"},{"location":"elements/constantsource/","page":"Constant Source","title":"Constant Source","text":"NOTE: The local coordinate system used by Hess and Smith (and also Katz and Plotkin) follows the opposite to the right-hand rule to define its normal. For this reason, the local coordinate system implemented in all phi and mathbfu functions in FLOWPanel define hatboldsymbolxi = hatmathbfo, hatboldsymboleta = hatmathbft, and hatmathbfn_mathrmHS = -hatmathbfn.","category":"page"},{"location":"elements/constantsource/","page":"Constant Source","title":"Constant Source","text":"Integrating over a planar element with n vertices results in","category":"page"},{"location":"elements/constantsource/","page":"Constant Source","title":"Constant Source","text":"beginalign*\n        phi(xyz)\n    =\n        -fracsigma4pi\n        sumlimits_ijin A left\n            R_ij Q_ij\n            + \n            vert z vert J_ij\n        right\nendalign*","category":"page"},{"location":"elements/constantsource/","page":"Constant Source","title":"Constant Source","text":"where A = (12)dots(n-1 n)(n 1)  and","category":"page"},{"location":"elements/constantsource/","page":"Constant Source","title":"Constant Source","text":"beginalign*\n        bullet quad  S_ij = fraceta_j - eta_id_ij\n    \n        bullet quad  C_ij = fracxi_j - xi_id_ij\n    \n        bullet quad  Q_ij = lnleft(frac r_i+r_j+d_ij  r_i+r_j-d_ij right)\n    \n        bullet quad  J_ij = arctanleft(frac\n                                R_ijlvert z rvert( r_i s_ij^(j) - r_j s_ij^(i))\n                            \n                                r_i r_j R_ij^2 + z^2 s_ij^(j) s_ij^(i)\n                            right)\n    \n        bullet quad  s_ij^(k) = (xi_k - x)C_ij + (eta_k - y)S_ij\n    \n        bullet quad  R_ij = (x - xi_i)S_ij - (y - eta_i)C_ij\n    \n        bullet quad  d_ij = sqrt(xi_j-xi_i)^2 + (eta_j-eta_i)^2\n    \n        bullet quad  r_i = sqrt(x-xi_i)^2 + (y-eta_i)^2 + z^2\nendalign*","category":"page"},{"location":"elements/constantsource/","page":"Constant Source","title":"Constant Source","text":"NOTE: The arctan defined in J_ij is intended to be evaluated in the range -pi to pi.","category":"page"},{"location":"elements/constantsource/","page":"Constant Source","title":"Constant Source","text":"The velocity induced by the panel at (xyz) is calculated as","category":"page"},{"location":"elements/constantsource/","page":"Constant Source","title":"Constant Source","text":"beginalign*\n    mathbfu = nabla phi\nendalign*","category":"page"},{"location":"elements/constantsource/","page":"Constant Source","title":"Constant Source","text":"which results in","category":"page"},{"location":"elements/constantsource/","page":"Constant Source","title":"Constant Source","text":"beginalign*\n        bullet quad  U_x = fracpartialvarphipartial x = - fracsigma4pi sumlimits_i=1^n S_i Q_i\n    \n        bullet quad  U_y = fracpartialvarphipartial y = fracsigma4pi sumlimits_i=1^n C_i Q_i\n    \n        bullet quad  U_z = fracpartialvarphipartial z = textsgn(z) fracsigma4pi left(  Deltatheta - sumlimits_i=1^n J_i right)\nendalign*","category":"page"},{"location":"elements/constantsource/","page":"Constant Source","title":"Constant Source","text":"where Deltatheta=2pi if (xy0) lies inside the quadrilateral, Deltatheta=0 if not. Hess & Smith mentions that the point lies inside the quadrilateral iff all R_i are positive.","category":"page"},{"location":"elements/constantsource/","page":"Constant Source","title":"Constant Source","text":"NOTE: The U_z velocity poses a discontinuity at the surface since limlimits_zrightarrow pm 0 U_z (0 0 z) = pm fracsigma2. Hess and Smith recommends setting U_z (0 0 0) = + fracsigma2. In FLOWPanel, however, we let U_z (0 0 0) = 0, but we also have shifted all control points slightly in the direction of hatmathbfn. Remembering that hatmathbfn_mathrmHS = -hatmathbfn, the control points are thus shifted in the -z direction, effectively obtaining boxedU_z (mathbfx_mathrmcp) approx - fracsigma2.","category":"page"},{"location":"elements/constantsource/","page":"Constant Source","title":"Constant Source","text":"NOTE 2: The offset of the control points is controlled through the properties body.CPoffset and body.characteristiclength of the Body type. Here, body.CPoffset is a small non-dimensional number s and body.characteristiclength is a user-defined function of the form (nodes, panel) -> l that returns a characteristic length ell (which can be either computed based on the panel, or it can be set the same for all panels). Each control point mathbfx_mathrmcp is then computed as mathbfx_mathrmcp = mathbfx_mathrmcentroid + sellhatmathbfn.","category":"page"},{"location":"elements/constantsource/","page":"Constant Source","title":"Constant Source","text":"NOTE 3: By default, FLOWPanel sets the characteristic length to be the square root of the panel area, but it is strongly recommended that the user provides their own characteristic length, and that this length is the same for all panels.","category":"page"},{"location":"elements/constantsource/","page":"Constant Source","title":"Constant Source","text":"ASSUMPTIONS","category":"page"},{"location":"elements/constantsource/","page":"Constant Source","title":"Constant Source","text":"The panel is a polygon of n number of vertices with nge3.\nThe polygon is planar, i.e., all vertices lay on the same plane.\nVectors betweens nodes 1 and 2 and nodes 1 and 3 are not collinear.\nThe polygon must be concave.","category":"page"},{"location":"elements/constantsource/","page":"Constant Source","title":"Constant Source","text":"OBSERVATIONS","category":"page"},{"location":"elements/constantsource/","page":"Constant Source","title":"Constant Source","text":"The term Q_ij makes this formulation singular at all vertices and edges of a panel; hence, FLOWPanel adds a small epsilon to the denominator of the log argument to avoid the singularity.","category":"page"},{"location":"elements/constantsource/","page":"Constant Source","title":"Constant Source","text":"NOTE: The small offset added to the denominator of Q_ij corresponds to body.kerneloffset.","category":"page"},{"location":"elements/constantsource/","page":"Constant Source","title":"Constant Source","text":"The potential and velocity field of a source panel of unitary strength (sigma=1) is shown below","category":"page"},{"location":"elements/constantsource/","page":"Constant Source","title":"Constant Source","text":"<center>\n  <table>\n      <tr>\n          <td>\n              <img src=\"../../assets/images/panel-source-phi00.png\" alt=\"Pic here\" width=\"450px\">\n          </td>\n          <td>\n              <img src=\"../../assets/images/panel-source-u02.png\" alt=\"Pic here\" width=\"300px\">\n          </td>\n      </tr>\n  </table>\n</center>","category":"page"},{"location":"elements/constantsource/","page":"Constant Source","title":"Constant Source","text":"<center>\n  <br>$\\nabla \\phi$ = $\\mathbf{u}$ verification\n  <img src=\"../../assets/images/panel-source-divphivsu00.png\" alt=\"Pic here\" style=\"width: 700px;\"/>\n</center>","category":"page"},{"location":"geometry/basics/#GeometricTools.jl","page":"GeometricTools.jl","title":"GeometricTools.jl","text":"","category":"section"},{"location":"geometry/basics/","page":"GeometricTools.jl","title":"GeometricTools.jl","text":"Some of the solvers implemented in FLOWPanel require flat panels and a structured surface grid that facilitates the declaration of edges along which to specify the Kutta condition. Hence, all paneled bodies are required to be structured grids.","category":"page"},{"location":"geometry/basics/","page":"GeometricTools.jl","title":"GeometricTools.jl","text":"The package GeometricTools.jl implements a variety of methods for the generation of grids and meshes, refinement, and space transformations, and is chosen as the geometric engine for FLOWPanel. Here below we show the low level manipulation of GeometricTools.jl for the sake of showing how to manually define complex geometries based on space transformations and localized refinement. The section Methods under Grid Generation shows predefined methods for creating common geometries, e.g., lofted surfaces, surfaces of revolution, etc.","category":"page"},{"location":"examples/blendedwingbody-TE/#Export-Trailing-Edge","page":"Export Trailing Edge","title":"Export Trailing Edge","text":"","category":"section"},{"location":"examples/blendedwingbody-TE/","page":"Export Trailing Edge","title":"Export Trailing Edge","text":"Along with the mesh, we also need to export the trailing edge as a line of points that we can use to identify the trailing edge in the mesh.","category":"page"},{"location":"examples/blendedwingbody-TE/","page":"Export Trailing Edge","title":"Export Trailing Edge","text":"First, close the Gmsh session from the previous section and launch Gmsh again to clean up the workspace. Then follow these steps using the same STEP file that you were processing before:","category":"page"},{"location":"examples/blendedwingbody-TE/","page":"Export Trailing Edge","title":"Export Trailing Edge","text":"Import STEP file\nFile > Merge\nCreate physical group with only the TE curves\nMake sure that geometric curves are visible: Tools > Options > Geometry > Visibility > ✓ Curves\nCreate physical group: Modules > Geometry > Physical Groups > Add > Curve\nSelect all the curves that define the trailing edge\n(Image: pic)\nDiscretize the TE\nSet size factor to something small: Tools > Options > Mesh > General > Element size factor > 0.01\nDiscretize 1D curves: Modules > Mesh > 1D\n(Optional) Verify discretization\nMake nodes visible: Tools > Options > Mesh > Visibility > ✓ Nodes\nZoom into the trailing edge and visually confirm that the line is finelly discretized\n(Image: pic)\nExport discretized curve as .msh in ASCII format v4: File > Export and select Mesh - Gmsh MSH (*.msh) in the dropdown menu","category":"page"},{"location":"examples/blendedwingbody-TE/","page":"Export Trailing Edge","title":"Export Trailing Edge","text":"info: `.msh` File\nThe resulting .msh file is available here: LINK (right click → save as...).","category":"page"},{"location":"examples/blendedwingbody-gpucpu/#GPU-and-CPU-Acceleration","page":"GPU and CPU Acceleration","title":"GPU and CPU Acceleration","text":"","category":"section"},{"location":"examples/blendedwingbody-gpucpu/#CPU-Multi-Threading","page":"GPU and CPU Acceleration","title":"CPU Multi-Threading","text":"","category":"section"},{"location":"examples/blendedwingbody-gpucpu/","page":"GPU and CPU Acceleration","title":"GPU and CPU Acceleration","text":"The kernels and solvers implemented in FLOWPanel are parallelized (threaded) in CPU by default. However, in order to activate the CPU parallelization, the user needs to launch Julia with multi-threading activated. For instance, to launch Julia with 4 threads:","category":"page"},{"location":"examples/blendedwingbody-gpucpu/","page":"GPU and CPU Acceleration","title":"GPU and CPU Acceleration","text":"$ julia --threads 4","category":"page"},{"location":"examples/blendedwingbody-gpucpu/","page":"GPU and CPU Acceleration","title":"GPU and CPU Acceleration","text":"You can then verify that the 4 threads became available:","category":"page"},{"location":"examples/blendedwingbody-gpucpu/","page":"GPU and CPU Acceleration","title":"GPU and CPU Acceleration","text":"julia> Threads.nthreads()\n4","category":"page"},{"location":"examples/blendedwingbody-gpucpu/#Porting-to-GPU","page":"GPU and CPU Acceleration","title":"Porting to GPU","text":"","category":"section"},{"location":"examples/blendedwingbody-gpucpu/","page":"GPU and CPU Acceleration","title":"GPU and CPU Acceleration","text":"The solver can be seamlessly ported to GPU by indicating the type of array to be used internally. The Julia GPU interface is the same for any GPU hardware and platform (NVIDIA CUDA, AMD ROCm, and Mac Metal), however, we have only tested NVIDIA GPUs.","category":"page"},{"location":"examples/blendedwingbody-gpucpu/","page":"GPU and CPU Acceleration","title":"GPU and CPU Acceleration","text":"For an NVIDIA GPU, first import the CUDA package before running the code of the previous section,","category":"page"},{"location":"examples/blendedwingbody-gpucpu/","page":"GPU and CPU Acceleration","title":"GPU and CPU Acceleration","text":"julia> import CUDA","category":"page"},{"location":"examples/blendedwingbody-gpucpu/","page":"GPU and CPU Acceleration","title":"GPU and CPU Acceleration","text":"check that the GPU hardware is ready to be used,","category":"page"},{"location":"examples/blendedwingbody-gpucpu/","page":"GPU and CPU Acceleration","title":"GPU and CPU Acceleration","text":"julia> CUDA.functional()\ntrue","category":"page"},{"location":"examples/blendedwingbody-gpucpu/","page":"GPU and CPU Acceleration","title":"GPU and CPU Acceleration","text":"and instead of letting the solver default its internal arrays to CPU, change the solver call from","category":"page"},{"location":"examples/blendedwingbody-gpucpu/","page":"GPU and CPU Acceleration","title":"GPU and CPU Acceleration","text":"julia> pnl.solve(body, Uinfs, Das, Dbs)","category":"page"},{"location":"examples/blendedwingbody-gpucpu/","page":"GPU and CPU Acceleration","title":"GPU and CPU Acceleration","text":"to","category":"page"},{"location":"examples/blendedwingbody-gpucpu/","page":"GPU and CPU Acceleration","title":"GPU and CPU Acceleration","text":"julia> pnl.solve(body, Uinfs, Das, Dbs; GPUArray=CUDA.CuArray{Float32})","category":"page"},{"location":"examples/blendedwingbody-gpucpu/","page":"GPU and CPU Acceleration","title":"GPU and CPU Acceleration","text":"For AMD GPU:","category":"page"},{"location":"examples/blendedwingbody-gpucpu/","page":"GPU and CPU Acceleration","title":"GPU and CPU Acceleration","text":"julia> import AMDGPU\njulia> AMDGPU.functional()\ntrue\njulia> AMDGPU.functional(:MIOpen)\ntrue\njulia> pnl.solve(body, Uinfs, Das, Dbs; GPUArray=AMDGPU.ROCArray{Float32})","category":"page"},{"location":"examples/blendedwingbody-gpucpu/","page":"GPU and CPU Acceleration","title":"GPU and CPU Acceleration","text":"For Metal GPU:","category":"page"},{"location":"examples/blendedwingbody-gpucpu/","page":"GPU and CPU Acceleration","title":"GPU and CPU Acceleration","text":"julia> import Metal\njulia> Metal.functional()\ntrue\njulia> pnl.solve(body, Uinfs, Das, Dbs; GPUArray=Metal.MtlArray{Float32})","category":"page"},{"location":"examples/blendedwingbody-gpucpu/","page":"GPU and CPU Acceleration","title":"GPU and CPU Acceleration","text":"info: GPU\nWe have only tested NVIDIA GPUs","category":"page"},{"location":"examples/sweptwing-aoasweep/#AOA-Sweep","page":"AOA Sweep","title":"AOA Sweep","text":"","category":"section"},{"location":"examples/sweptwing-aoasweep/","page":"AOA Sweep","title":"AOA Sweep","text":"Using the wing defined in the previous section, we now sweep the angle     of attack.","category":"page"},{"location":"examples/sweptwing-aoasweep/","page":"AOA Sweep","title":"AOA Sweep","text":"AOAs = [0, 2.1, 4.2, 6.3, 8.4, 10.5, 12, 14, 16] # (deg) angles of attack\nXac = [0.0*b/ar, 0, 0]                 # (m) aerodynamic center for moment calculation\n\n# Results are stored in these arrays\nLs, Ds = [], []                         # Lift and drag at each angle of attack\nLhats, Dhats = [], []                   # Direction of lift and drag at each AOA\n\nrolls, pitchs, yaws = [], [], []        # Rolling, pitching, and yawing moment\nlhats, mhats, nhats = [], [], []        # Direction of roll, pitch, and yaw\n\nls, ds = [], []                         # Load and drag distributions\nspanposs = []                           # Spanwise positions for load distributions\n\n\n# ----------------- AOA SWEEP --------------------------------------------------\nfor AOA in AOAs\n\n    Vinf = magVinf*[cos(AOA*pi/180), 0, sin(AOA*pi/180)] # Freestream\n\n    # ----------------- CALL SOLVER --------------------------------------------\n    # Freestream at every control point\n    Uinfs = repeat(Vinf, 1, body.ncells)\n    Das = repeat(Vinf/magVinf, 1, body.nsheddings)\n    Dbs = repeat(Vinf/magVinf, 1, body.nsheddings)\n\n    # Solve body\n    @time pnl.solve(body, Uinfs, Das, Dbs)\n\n    # ----------------- POST PROCESSING ----------------------------------------\n    # Calculate velocity away from the body\n    Us = pnl.calcfield_U(body, body; characteristiclength=(args...)->b/ar)\n\n    # Calculate surface velocity U_∇μ due to the gradient of the doublet strength\n    UDeltaGamma = pnl.calcfield_Ugradmu(body)\n\n    # Add both velocities together\n    pnl.addfields(body, \"Ugradmu\", \"U\")\n\n    # Calculate pressure coeffiecient\n    Cps = pnl.calcfield_Cp(body, magVinf)\n\n    # Calculate the force of each panel\n    Fs = pnl.calcfield_F(body, magVinf, rho)\n\n    # Integrated force decomposed into lift and drag\n    Dhat = Vinf/pnl.norm(Vinf)    # Drag direction\n    Shat = [0, 1, 0]              # Span direction\n    Lhat = pnl.cross(Dhat, Shat)  # Lift direction\n\n    LDS = pnl.calcfield_LDS(body, Lhat, Dhat, Shat)\n\n    L = LDS[:, 1]\n    D = LDS[:, 2]\n\n    push!(Ls, L)\n    push!(Ds, D)\n    push!(Lhats, Lhat)\n    push!(Dhats, Dhat)\n\n    # Integrated moment decomposed into rolling, pitching, and yawing moments\n    lhat = Dhat                   # Rolling direction\n    mhat = Shat                   # Pitching direction\n    nhat = Lhat                   # Yawing direction\n\n    lmn = pnl.calcfield_lmn(body, Xac, lhat, mhat, nhat)\n    roll, pitch, yaw = collect(eachcol(lmn))\n\n    push!(rolls, roll)\n    push!(pitchs, pitch)\n    push!(yaws, yaw)\n    push!(lhats, lhat)\n    push!(mhats, mhat)\n    push!(nhats, nhat)\n\n    # Calculate loading distribution\n    fs, spanpos = pnl.calcfield_sectionalforce(wing_right; spandirection=[0, 1, 0])\n    lds = pnl.decompose(fs, Lhat, Dhat)\n\n    l = lds[1, :]\n    d = lds[2, :]\n\n    push!(spanposs, spanpos)\n    push!(ls, l)\n    push!(ds, d)\nend\n\n\n\n","category":"page"},{"location":"examples/sweptwing-aoasweep/","page":"AOA Sweep","title":"AOA Sweep","text":"(see the complete example under examples/sweptwing_aoasweep.jl to see how to postprocess the solution as plotted here below)","category":"page"},{"location":"examples/sweptwing-aoasweep/","page":"AOA Sweep","title":"AOA Sweep","text":"<center>\n    <br><b>Spanwise loading distribution</b>\n    <img src=\"../../assets/images/sweptwing000-sweep-loading.png\" alt=\"Pic here\" style=\"width: 100%;\"/>\n\n    <br><br><b>Lift and induced drag</b>\n    <img src=\"../../assets/images/sweptwing000-sweep-CLCD.png\" alt=\"Pic here\" style=\"width: 100%;\"/>\n\n    <br><br><b>Pitching moment</b><br>\n    <img src=\"../../assets/images/sweptwing000-sweep-Cm.png\" alt=\"Pic here\" style=\"width: 50%;\"/>\n</center>","category":"page"},{"location":"examples/sweptwing-aoasweep/","page":"AOA Sweep","title":"AOA Sweep","text":"details: Tip\nYou can also automatically run this example and generate these plots with the following command:import FLOWPanel as pnl\n\ninclude(joinpath(pnl.examples_path, \"sweptwing.jl\"))\ninclude(joinpath(pnl.examples_path, \"sweptwing_aoasweep.jl\"))\n","category":"page"},{"location":"geometry/gridgeneration-pathloft/#Path-Lofting-Method","page":"Path-Lofting Method","title":"Path-Lofting Method","text":"","category":"section"},{"location":"geometry/gridgeneration-pathloft/","page":"Path-Lofting Method","title":"Path-Lofting Method","text":"The following function in GeometricTools lofts a set of contours along a path. This method uses an Akima spline to extrapolate in between the contours and path points supplied by the user, which resembles the flexibility of NURBs but without weights in order to make the process simpler for the user.","category":"page"},{"location":"geometry/gridgeneration-pathloft/","page":"Path-Lofting Method","title":"Path-Lofting Method","text":"FLOWPanel.GeometricTools.surface_pathloft","category":"page"},{"location":"geometry/gridgeneration-pathloft/#GeometricTools.surface_pathloft","page":"Path-Lofting Method","title":"GeometricTools.surface_pathloft","text":"surface_pathloft(sections, section_NDIVS, path_NDIVS, path; injective_coordinate=1, loop_dim=0, nperiodic=2, redisc_optargs=[], verify_spline=true, save_path=nothing, paraview=true, file_pref=\"pathloft\")\n\nGeneration of a surface grid by lofting a set of sections along a path.\n\nsections is an array where sections[i] = (spos, points) is the i-th contour made out of the 2xn matrix points that goes along the path in the nondimensional arc-length position spos (a number between 0 and 1, where 0 is the start of the path and 1 is the end of the path). path is an array where path[i] = (X, n, twist) is the i-th point along the path placed at X in the global coordinate system and the cross section passing through this point will be oriented according to the normal vector n and twisted by twist (in degrees). The number of points in path does not need to match the number of sections in sections\n\nThis function rediscretizes the sections as indicated by section_NDIVS, which could be an array of multidiscretization parameters to apply to each section, a single multidiscretization parameter set for all the sections, or an integer with the number of points used to discretize all sections. Similarly, path_NDIVS indicates the desired discretization of the x-position along the path.\n\nContours can either be closed or open, and the discretization will automatically recognize and preserve that. Contours must be concave.\n\nsections has the format sections[i] = (spos, points) where points is the nx2 matrix of n contours points (y, z) of each section, and spos is the nondimensional position along the path of each section.\n\npath has the format path[i] = (X, normal, twist), where X is the position of the i-th point (a vector of length 3), normal is a the normal of cross sections at that position (a vector of length 3), and twist is the twist of the cross section at that position (in degrees). injective_coordinate is the coordinate that makes the path injective.\n\n\n\n\n\nsurface_pathloft(sections::Vector{Tuple{<:Real, String}}, data_path::String, args...; header_len=1, delim=\",\", optargs...)\n\nLoft a geometry where the sections are read from the files indicated by sections found in data_path.\n\nsections has the format sections[i] = (xpos, filename) where filename is the CSV file containing the (y, z) contours of each section, and xpos is the nondimensional position along the path of each section.\n\n\n\n\n\n","category":"function"},{"location":"geometry/gridgeneration-pathloft/#Example","page":"Path-Lofting Method","title":"Example","text":"","category":"section"},{"location":"geometry/gridgeneration-pathloft/","page":"Path-Lofting Method","title":"Path-Lofting Method","text":"In this example we read two conic sections from a CSV and define a loft path to generate a lofted surface grid. This animation shows the path of the loft ( points in black, normals in green, path spline in red):","category":"page"},{"location":"geometry/gridgeneration-pathloft/","page":"Path-Lofting Method","title":"Path-Lofting Method","text":"<center>\n<img src=\"http://edoalvar2.groups.et.byu.net/public/FLOWPanel/pathloft-example_4-small.gif\" alt=\"Vid here\", width=\"70%\"/>\n</center>","category":"page"},{"location":"geometry/gridgeneration-pathloft/","page":"Path-Lofting Method","title":"Path-Lofting Method","text":"import GeometricTools as gt\n\nimport FLOWPanel: examples_path\nimport CSV\nimport DataFrames: DataFrame\n\n\nsave_path       = \"pathloft-example\"                # Where to save grid VTK\ncontour_path    = joinpath(examples_path, \"data\")   # Where to read the conic contour from\n\n\n# ------------ Define contours of loft -----------------------------------------\n\n# Read conic contours for loft\npoints1 = CSV.read(joinpath(contour_path, \"conicsection1.csv\"), DataFrame)\npoints1 = Matrix(points1)\n\npoints2 = CSV.read(joinpath(contour_path, \"conicsection2.csv\"), DataFrame)\npoints2 = Matrix(points2)\n\n# Define loft sections\nsections = [ # (non-dimensional arclength position along path, contour)\n                (0.000,  points1),\n                (0.125, points1),\n                (0.250, points1),\n                (0.800,  points2),\n                (0.900,  points2),\n                (1.000,  points2)\n            ]\n\n\n# ------------ Define loft path ------------------------------------------------\n\n# Points along path\npath_Xs = [\n            [1.0, 0, 0],\n            [2.0, 0, 0],\n            [3.0, 0, 0],\n            [4.0, 0.5, 0],\n            [6.0, 1, 1]\n          ]\n\n# Section normals along path\npath_normals = [\n                [1, 0, 0],\n                [1, 0, 0],\n                [1, 0, 0],\n                [1, 1, 0]/sqrt(2),\n                [1, 1, 1]/sqrt(3)\n               ]\n\n# Twist of section contours along path\npath_twists = [0, -30, -45, 0, -45]\n\n# Collect the path\npath = collect(zip(path_Xs, path_normals, path_twists))\n\n\n# ------------ Generate lofted surface grid ----------------------------------\n\n# Define discretization\nsection_NDIVS   = 200                               # Discretization of section contours\npath_NDIVS      = 100                               # Discretization of path\n\n# Generate loft\ngrid = gt.surface_pathloft(sections, path,\n                            section_NDIVS, path_NDIVS; save_path=save_path, paraview=true)","category":"page"},{"location":"geometry/gridgeneration-pathloft/","page":"Path-Lofting Method","title":"Path-Lofting Method","text":"surface_pathloft(...; verify_spline=true, ...) automatically generates the following plots for the user to verify that the spline is correctly fitting the raw contours and path. Here are the contours:","category":"page"},{"location":"geometry/gridgeneration-pathloft/","page":"Path-Lofting Method","title":"Path-Lofting Method","text":"\n<center>\n  <table>\n      <tr>\n          <td>\n              <img src=\"../../assets/images/pathloft-example-contour000.png\" alt=\"Pic here\" width=\"100%\">\n          </td>\n          <td>\n              <img src=\"../../assets/images/pathloft-example-contour001.png\" alt=\"Pic here\" width=\"100%\">\n          </td>\n          <td>\n              <img src=\"../../assets/images/pathloft-example-contour002.png\" alt=\"Pic here\" width=\"100%\">\n          </td>\n      </tr>\n      <tr>\n          <td>\n              <img src=\"../../assets/images/pathloft-example-contour003.png\" alt=\"Pic here\" width=\"100%\">\n          </td>\n          <td>\n              <img src=\"../../assets/images/pathloft-example-contour004.png\" alt=\"Pic here\" width=\"100%\">\n          </td>\n          <td>\n              <img src=\"../../assets/images/pathloft-example-contour005.png\" alt=\"Pic here\" width=\"100%\">\n          </td>\n      </tr>\n  </table>\n</center>\n\n<br><br>","category":"page"},{"location":"geometry/gridgeneration-pathloft/","page":"Path-Lofting Method","title":"Path-Lofting Method","text":"The path is visualized showing the x-y and x-z coordinates of the path points and normals, as shown below:","category":"page"},{"location":"geometry/gridgeneration-pathloft/","page":"Path-Lofting Method","title":"Path-Lofting Method","text":"<center>\n  <table>\n      <tr>\n          <td>\n              <img src=\"../../assets/images/pathloft-example-path000.png\" alt=\"Pic here\" width=\"100%\">\n          </td>\n      </tr>\n  </table>\n</center>","category":"page"},{"location":"geometry/gridgeneration-pathloft/","page":"Path-Lofting Method","title":"Path-Lofting Method","text":"Also the contour twist is shown along the dimensional length of the path:","category":"page"},{"location":"geometry/gridgeneration-pathloft/","page":"Path-Lofting Method","title":"Path-Lofting Method","text":"<center>\n  <table>\n      <tr>\n          <td>\n              <img src=\"../../assets/images/pathloft-example-path001.png\" alt=\"Pic here\" width=\"100%\">\n          </td>\n      </tr>\n  </table>\n</center>","category":"page"},{"location":"geometry/gridgeneration-pathloft/","page":"Path-Lofting Method","title":"Path-Lofting Method","text":"surface_pathloft(...; paraview=true, ...) calls ParaView after generating the grid to visualize the loft:","category":"page"},{"location":"geometry/gridgeneration-pathloft/","page":"Path-Lofting Method","title":"Path-Lofting Method","text":"<center>\n  <img src=\"http://edoalvar2.groups.et.byu.net/public/FLOWPanel/pathloft-example_5-small.gif\" alt=\"Vid here\", width=\"70%\"/>\n  <img src=\"http://edoalvar2.groups.et.byu.net/public/FLOWPanel/pathloft-example_6-small.gif\" alt=\"Vid here\", width=\"70%\"/>\n</center>","category":"page"},{"location":"geometry/gridgeneration-loft/#Lofting-Method","page":"Lofting Method","title":"Lofting Method","text":"","category":"section"},{"location":"geometry/gridgeneration-loft/","page":"Lofting Method","title":"Lofting Method","text":"The following function in GeometricTools facilitates lofting of a surface geometry through a set of cross sections, doing a first order (linear) interpolation between sections.","category":"page"},{"location":"geometry/gridgeneration-loft/","page":"Lofting Method","title":"Lofting Method","text":"FLOWPanel.GeometricTools.generate_loft","category":"page"},{"location":"geometry/gridgeneration-loft/#GeometricTools.generate_loft","page":"Lofting Method","title":"GeometricTools.generate_loft","text":"generate_loft(crosssections, bscale, b_pos, chords, twists, LE_x, LE_z)\n\nGenerates a lofted surface geometry. The name of the arguments are taken from   its initial application to the lofting of an aircraft wing.\n\nArguments\n\nbscale::Float64         : Semi-span scale. It will scale the entire                             geometry by this factor.\nb_pos::Array{Float64, 1}: Normalized span positions y/bscale of the                             following distributions.\nchords::Array{Float64,1}: Chord c/bscale distribution.\ntwists::Array{Float64,1}: Twist (deg) distribution.\nLE_x::Array{Float64,1}  : x-position (chordwise) x/bscale of leading edge                             distribution.\nLE_z::Array{Float64,1}  : z-position (dihedral-wise) z/bscale of leading                             edge distribution.\ncrosssections::Array{Tuple{T,Array{T,2}}, 1}    : cross sections along the                             span in the form [(y/bscale, crosssection)],                             where crosssection is a matrix that contains                             all points of the airfoil contour indexed by                             row. In order to define the resulting normals                             pointing out of the geometry, the points in                             crosssection must start from the trailing                             edge, go around the top side towards the leading                             edge, and back to the trailing edge around the                             bottom side. ALL CROSS SECTIONS MUST HAVE THE                             SAME NUMBER OF POINTS.\n\nOptional Arguments\n\ntilt_z::Array{Float64,1}: Tilting (deg) about the z-axis of every span                             cross section. This is also a distribution.\nsymmetric::Bool         : Whether to consider the crosssections to be                             symmetric about the semi-span. If true, only                             positive y/bscale are neeeded.\n\nNOTE: The resulting geometry will be a structured surface mesh with the first   index going in chordwise direction starting from the TE around the bottom   surface and around back to the TE. The second index is the in the spanwise   direction starting at left end (lowest position along y axis) to right end.\n\n\n\n\n\ngenerate_loft(crosssections, bscale, b_low, b_up, b_NDIVS, chords, twists, LE_x, LE_z; optargs...)\n\nGenerates a lofted surface geometry. The name of the arguments are taken from   its initial application to the lofting of an aircraft wing.\n\nArguments\n\nbscale::Float64         : Semi-span scale. It will scale the entire                             geometry by this factor. All y/bscale values in                             the following arguments must go from 0 to 1.\nb_low::Float64          : Scaled lower bound of the span.\nb_up::Float64           : Scaled upper bound of the span. To generate                             a symmetric wing, give it blow=-1, bup=1 and .                             symmetric=true; for a semi-span, give it                             blow=0, bup=1. If generating a prop blade,                             give it blow=Rhub/Rtip, bup=1.\nb_NDIVS                 : Number of divisions (cells) along span. This                             if either an Int or an array of sections in the                             format of multidiscretize().\nchords::Array{Float64,2}: Chord distribution along the span in the form                             [y/bscale c/bscale].\ntwists::Array{Float64,2}: Twist distribution along the span in the form                             [y/bscale deg].\nLE_x::Array{Float64,2}  : x-position (chordwise) of leading edge along the                             span in the form [y/bscale x/bscale].\nLE_z::Array{Float64,2}  : z-position (dihedral-wise) of leading edge along                             the span in the form [y/bscale z/bscale].\ncrosssections::Array{Tuple{T,Array{T,2}}, 1}    : cross sections along the                             span in the form [(y/bscale, crosssection)],                             where crosssection is a matrix that contains                             all points of the airfoil contour indexed by                             row. In order to define the resulting normals                             pointing out of the geometry, the points in                             crosssection must start from the trailing                             edge, go around the top side towards the leading                             edge, and back to the trailing edge around the                             bottom side. ALL CROSS SECTIONS MUST HAVE THE                             SAME NUMBER OF POINTS.\n\nOptional Arguments\n\ntilt_z::Array{Float64,2}: Tilting about the z-axis of every span cross                             section in the form [(y/bscale, deg)].\nspl_k, spl_bc, spl_s: Spline parameters with k the degree of the                             spline, bc the boundary condition, and s the                             smoothing or error of the spline.\n\nNOTE: The resulting geometry will be a structured surface mesh with the first   index going in chordwise direction starting from the TE around the bottom   surface and around back to the TE. The second index is the in the spanwise   direction starting at left end (lowest position along y axis) to right end.\n\n\n\n\n\ngenerate_loft(crosssections, upper_rfl_NDIVS, lower_rfl_NDIVS, args...; rflspl_k::Int64=5, rflspl_s::Real=0.001, verify_rflspline::Bool=true, rfloptargs=[], optargs...)\n\nThis function also rediscretizes the cross sections as indicated by   upper_rfl_NDIVS, and lower_rfl_NDIVS (upper and lower surface sections,   respectively). Hence, the original cross sections need not to have the same   number of points.\n\n\n\n\n\ngenerate_loft(crosssections::Array{Tuple{T,String}, 1},                         data_path::String, args...; header_len::Int64=1,                         delim::String=\" \", optargs...) where{T<:Real}\n\nLoft a geometry where the cross sections are read from the files indicated by crosssections found in data_path.\n\n\n\n\n\n","category":"function"},{"location":"geometry/gridgeneration-loft/#Node-and-Cell-Indexing","page":"Lofting Method","title":"Node and Cell Indexing","text":"","category":"section"},{"location":"geometry/gridgeneration-loft/","page":"Lofting Method","title":"Lofting Method","text":"It is recommended that wings follow conventional aerodynamic coordinates, building the wing from left tip (-y) to right tip (+y), leading edge pointing in the direction of -x and trailing edge in the direction of +x, and top side of the airfoil in the direction of +z. However, the user is free to define wings in any arbitrary convention since the solvers are indifferent to orientation. Unless otherwise indicated, the solvers are indifferent to whether normals point inside or outside the geometry, but for consistency, it is good practice to define the geometry such as to have the normals pointing outside. This is done by building every airfoil starting at the trailing edge first going around the bottom side towards the leading edge, and going back to the trailing edge around the top side, while using b_low < b_up.","category":"page"},{"location":"geometry/gridgeneration-loft/","page":"Lofting Method","title":"Lofting Method","text":"Following these guidelines, GeometricTools.generate_loft returns a lofted quadrilateral surface with the following node and cell indexing pattern:","category":"page"},{"location":"geometry/gridgeneration-loft/","page":"Lofting Method","title":"Lofting Method","text":"\n<center>\n  <table>\n      <tr>\n          <th>\n              <center>First Coordinate</center>\n          </th>\n          <th>\n              <center>Second Coordinate</center>\n          </th>\n      </tr>\n      <tr>\n          <td>\n              <img src=\"../../assets/images/loft-quad-cellcoordinate03.png\" alt=\"Pic here\" width=\"450px\">\n          </td>\n          <td>\n              <img src=\"../../assets/images/loft-quad-cellcoordinate02.png\" alt=\"Pic here\" width=\"450px\">\n          </td>\n      </tr>\n  </table>\n</center>\n\n<br><br>\n\n<center>\n  <table>\n      <tr>\n          <th>\n              <center>Node Index</center>\n          </th>\n          <th>\n              <center>Cell Index</center>\n          </th>\n      </tr>\n      <tr>\n          <td>\n              <img src=\"../../assets/images/loft-quad-nodeindex00.png\" alt=\"Pic here\" width=\"450px\">\n          </td>\n          <td>\n              <img src=\"../../assets/images/loft-quad-cellindex01.png\" alt=\"Pic here\" width=\"450px\">\n          </td>\n      </tr>\n  </table>\n</center>\n\n<br><br>\n\n<center>\n  <table>\n      <tr>\n          <th>\n              <center>Cell (1, 1)</center>\n          </th>\n          <th>\n              <center>Cell (16, 1)</center>\n          </th>\n          <th>\n              <center>Cell (15, 2)</center>\n          </th>\n      </tr>\n      <tr>\n          <td>\n              <img src=\"../../assets/images/loft-quad-cellnodes00.0000.png\" alt=\"Pic here\" width=\"450px\">\n          </td>\n          <td>\n              <img src=\"../../assets/images/loft-quad-cellnodes00.0001.png\" alt=\"Pic here\" width=\"450px\">\n          </td>\n          <td>\n              <img src=\"../../assets/images/loft-quad-cellnodes00.0002.png\" alt=\"Pic here\" width=\"450px\">\n          </td>\n      </tr>\n  </table>\n</center>","category":"page"},{"location":"geometry/gridgeneration-loft/#Example-—-Wing,-uniform-mesh","page":"Lofting Method","title":"Example — Wing, uniform mesh","text":"","category":"section"},{"location":"geometry/gridgeneration-loft/","page":"Lofting Method","title":"Lofting Method","text":"Here is a wing with a 5-th order spline. Since I'm giving it data points to spline that are quite sparse along the span, the splined values end up curving the chord distribution.","category":"page"},{"location":"geometry/gridgeneration-loft/","page":"Lofting Method","title":"Lofting Method","text":"import FLOWPanel as pnl\nimport GeometricTools as gt\n                                # Airfoil data path\nairfoil_path = joinpath(pnl.def_data_path, \"airfoils\");\n\nfile_name = \"paneledwing01\"     # Output file name\nsave_path = \"./\"                # Save path\n\n# ----------------- GEOMETRY DESCRIPTION -------------------------------------------\nsemispan = 10                       # (m) semi-span length\n\nchords = [0.00 0.25;                # (semi-span position, chord c/semib)\n          0.25 0.20;\n          1.00 0.10]\n\ntwists = [0.0 5;                    # (semi-span position, twist (deg))\n          1.0 0]\n\nx_pos = [0.00 0;                    # (semi-span position, LE x-position x/semib)\n         0.25 1/40;\n         1.00 1/8;]\n\nz_pos = [0.00 0;                    # (semi-span position, LE x-position x/semib)\n         0.25 1/100;\n         1.00 1/50]\n\n\nairfoil_files = [(0.0, \"naca6412.dat\"), # (semi-span position, airfoil file)\n                 (1.0, \"naca6412.dat\")]\n\n\n# ----------------- MESHING PARAMETERS ---------------------------------------------\nurfl_NDIVS = 25                     # Cells on upper side of airfoils\nlrfl_NDIVS = 25                     # Cells on lower side of airfoils\nb_NDIVS = 76                        # Span cells\n\n\n# ----------------- LOFTING PARAMETERS ---------------------------------------------\nb_low = -1.0                        # Lower bound of span lofting\nb_up = 1.0                          # Upper bound of span lofting\nsymmetric = true                    # Lofting symmetric about b=0\nspl_k = 5                           # Spline order of distributions along span\nspl_s = 0.001                       # Spline smoothing of distribution along span\nverify_spline = true                # Plots the splined distributions\n\n# ----------------- GENERATE WING --------------------------------------------------\nwing = pnl.gt.generate_loft(airfoil_files, airfoil_path, urfl_NDIVS, lrfl_NDIVS,\n                                        semispan, b_low, b_up, b_NDIVS,\n                                        chords, twists, x_pos, z_pos;\n                                        symmetric=symmetric,\n                                        spl_k=spl_k, spl_s=spl_s,\n                                        verify_spline=verify_spline\n                                    )\n\n# Save vtk and call paraview\npnl.gt.save(wing, file_name; path=save_path, format=\"vtk\")\n\nrun(`paraview --data=$(joinpath(save_path, file_name)).vtk`)","category":"page"},{"location":"geometry/gridgeneration-loft/","page":"Lofting Method","title":"Lofting Method","text":"<img src=\"http://edoalvar2.groups.et.byu.net/public/FLOWPanel/wing00.gif\" alt=\"Vid here\" style=\"width: 900px;\"/>","category":"page"},{"location":"geometry/gridgeneration-loft/","page":"Lofting Method","title":"Lofting Method","text":"In order to avoid the curving, we reduce the splining degree to only first order—which becomes a linear interpolation—however, the smoothing makes everything just a simple line from root to tip:","category":"page"},{"location":"geometry/gridgeneration-loft/","page":"Lofting Method","title":"Lofting Method","text":"spl_k = 1                           # Spline order of distributions along span\n\n# ----------------- GENERATE WING --------------------------------------------------\nwing = pnl.gt.generate_loft(airfoil_files, airfoil_path, urfl_NDIVS, lrfl_NDIVS,\n                                        semispan, b_low, b_up, b_NDIVS,\n                                        chords, twists, x_pos, z_pos;\n                                        symmetric=symmetric,\n                                        spl_k=spl_k, spl_s=spl_s,\n                                        verify_spline=verify_spline\n                                    )\n\n# Save vtk and call paraview\npnl.gt.save(wing, file_name; path=save_path, format=\"vtk\")\n\nrun(`paraview --data=$(joinpath(save_path, file_name)).vtk`)","category":"page"},{"location":"geometry/gridgeneration-loft/","page":"Lofting Method","title":"Lofting Method","text":"<img src=\"http://edoalvar2.groups.et.byu.net/public/FLOWPanel/wing02.gif\" alt=\"Vid here\" style=\"width: 900px;\"/>","category":"page"},{"location":"geometry/gridgeneration-loft/","page":"Lofting Method","title":"Lofting Method","text":"Decreasing the smoothing forces the spline to intersect every data point, finally obtaining the desired geometry:","category":"page"},{"location":"geometry/gridgeneration-loft/","page":"Lofting Method","title":"Lofting Method","text":"spl_k = 1                           # Spline order of distributions along span\nspl_s = 0.0000001                   # Spline smoothing of distribution along span\n\n# ----------------- GENERATE WING --------------------------------------------------\nwing = pnl.gt.generate_loft(airfoil_files, airfoil_path, urfl_NDIVS, lrfl_NDIVS,\n                                        semispan, b_low, b_up, b_NDIVS,\n                                        chords, twists, x_pos, z_pos;\n                                        symmetric=symmetric,\n                                        spl_k=spl_k, spl_s=spl_s,\n                                        verify_spline=verify_spline\n                                    )\n\n# Save vtk and call paraview\npnl.gt.save(wing, file_name; path=save_path, format=\"vtk\")\n\nrun(`paraview --data=$(joinpath(save_path, file_name)).vtk`);","category":"page"},{"location":"geometry/gridgeneration-loft/","page":"Lofting Method","title":"Lofting Method","text":"<img src=\"http://edoalvar2.groups.et.byu.net/public/FLOWPanel/wing01.gif\" alt=\"Vid here\" style=\"width: 900px;\"/>","category":"page"},{"location":"geometry/gridgeneration-loft/#Example-—-Wing,-localized-refinement-mesh","page":"Lofting Method","title":"Example — Wing, localized refinement mesh","text":"","category":"section"},{"location":"geometry/gridgeneration-loft/","page":"Lofting Method","title":"Lofting Method","text":"Here is an example of how to defined a localized refinement. Instead of defining the a uniform discretization around the airfoil cross sections as","category":"page"},{"location":"geometry/gridgeneration-loft/","page":"Lofting Method","title":"Lofting Method","text":"urfl_NDIVS = 25                     # Cells on upper side of airfoils\nlrfl_NDIVS = 25                     # Cells on lower side of airfoils","category":"page"},{"location":"geometry/gridgeneration-loft/","page":"Lofting Method","title":"Lofting Method","text":"we define the divisions as sections of discretization as follows:","category":"page"},{"location":"geometry/gridgeneration-loft/","page":"Lofting Method","title":"Lofting Method","text":"urfl_NDIVS = [(0.25, 10,   10.0, false),       # Cells on upper side of airfoils\n              (0.50,  7,    1.0, true),\n              (0.25,  8, 1/10.0, false)]                    \nlrfl_NDIVS = urfl_NDIVS                        # Cells on lower side of airfoils","category":"page"},{"location":"geometry/gridgeneration-loft/","page":"Lofting Method","title":"Lofting Method","text":"The first section starts at the leading edge, with a length of 0.25 and 10 divisions with a geometric expansion of 10.0. The second section is the center of airfoil, and the last one is the trailing edge:","category":"page"},{"location":"geometry/gridgeneration-loft/","page":"Lofting Method","title":"Lofting Method","text":"import FLOWPanel as pnl\nimport GeometricTools as gt\n                                # Airfoil data path\nairfoil_path = joinpath(pnl.def_data_path, \"airfoils\");\n\nfile_name = \"paneledwing02\"     # Output file name\nsave_path = \"./\"                # Save path\n\n# ----------------- GEOMETRY DESCRIPTION -------------------------------------------\nsemispan = 10                       # (m) semi-span length\n\nchords = [0.00 0.25;                # (semi-span position, chord c/semib)\n          0.25 0.20;\n          1.00 0.10]\n\ntwists = [0.0 5;                    # (semi-span position, twist (deg))\n          1.0 0]\n\nx_pos = [0.00 0;                    # (semi-span position, LE x-position x/semib)\n         0.25 1/40;\n         1.00 1/8;]\n\nz_pos = [0.00 0;                    # (semi-span position, LE x-position x/semib)\n         0.25 1/100;\n         1.00 1/50]\n\n\nairfoil_files = [(0.0, \"naca6412.dat\"), # (semi-span position, airfoil file)\n                 (1.0, \"naca6412.dat\")]\n\n\n# ----------------- MESHING PARAMETERS ---------------------------------------------\nurfl_NDIVS = [(0.25, 10,   10.0, false),       # Cells on upper side of airfoils\n              (0.50,  7,    1.0, true),\n              (0.25,  8, 1/10.0, false)]                    \nlrfl_NDIVS = urfl_NDIVS             # Cells on lower side of airfoils\nb_NDIVS = 76                        # Span cells\n\n\n# ----------------- LOFTING PARAMETERS ---------------------------------------------\nb_low = -1.0                        # Lower bound of span lofting\nb_up = 1.0                          # Upper bound of span lofting\nsymmetric = true                    # Lofting symmetric about b=0\nspl_k = 1                           # Spline order of distributions along span\nspl_s = 0.0000001                   # Spline smoothing of distribution along span\nverify_spline = false               # Plots the splined distributions\nverify_rflspline = true             # Plots the splined airfoil cross sections\n\n\n# ----------------- GENERATE WING --------------------------------------------------\nwing = pnl.gt.generate_loft(airfoil_files, airfoil_path, urfl_NDIVS, lrfl_NDIVS,\n                                        semispan, b_low, b_up, b_NDIVS,\n                                        chords, twists, x_pos, z_pos;\n                                        symmetric=symmetric,\n                                        spl_k=spl_k, spl_s=spl_s,\n                                        verify_spline=verify_spline,\n                                        verify_rflspline=verify_rflspline\n                                    )\n\n# Save vtk and call paraview\npnl.gt.save(wing, file_name; path=save_path, format=\"vtk\")\n\nrun(`paraview --data=$(joinpath(save_path, file_name)).vtk`)","category":"page"},{"location":"geometry/gridgeneration-loft/","page":"Lofting Method","title":"Lofting Method","text":"<img src=\"http://edoalvar2.groups.et.byu.net/public/FLOWPanel/wing03_2.gif\" alt=\"Vid here\" style=\"width: 900px;\"/>","category":"page"},{"location":"geometry/gridgeneration-loft/","page":"Lofting Method","title":"Lofting Method","text":"It works great, however, zooming in we realize that the leading edge of the wing is blunt, in spite of refinement. This is due to the splining of the airfoil cross sections smoothing out the high curvature at the leading edge (see below, top image) and failing to actually reconnect bottom and top surfaces. We fix this by decreasing the smoothness of the airfoil splines (see below, bottom image).","category":"page"},{"location":"geometry/gridgeneration-loft/","page":"Lofting Method","title":"Lofting Method","text":"rflspl_s = 0.00000001               # Spline smoothing of airfoil cross sections.\n\n# ----------------- GENERATE WING --------------------------------------------------\nwing = pnl.gt.generate_loft(airfoil_files, airfoil_path, urfl_NDIVS, lrfl_NDIVS,\n                                        semispan, b_low, b_up, b_NDIVS,\n                                        chords, twists, x_pos, z_pos;\n                                        symmetric=symmetric,\n                                        spl_k=spl_k, spl_s=spl_s,\n                                        verify_spline=verify_spline,\n                                        verify_rflspline=verify_rflspline,\n                                        rflspl_s=rflspl_s\n                                    )\n\n# Save vtk and call paraview\npnl.gt.save(wing, file_name; path=save_path, format=\"vtk\")\n\nrun(`paraview --data=$(joinpath(save_path, file_name)).vtk`)","category":"page"},{"location":"geometry/gridgeneration-loft/","page":"Lofting Method","title":"Lofting Method","text":"<img src=\"../../assets/images/wing05_2.png\" alt=\"Pic here\" style=\"width: 900px;\"/>","category":"page"},{"location":"geometry/gridgeneration-loft/","page":"Lofting Method","title":"Lofting Method","text":"Finally, we can also refine the mesh towards both tips as shown below.","category":"page"},{"location":"geometry/gridgeneration-loft/","page":"Lofting Method","title":"Lofting Method","text":"b_NDIVS = [(1.0, 49, 20.0, true)]   # Span cell sections\n\n# ----------------- GENERATE WING --------------------------------------------------\nwing = pnl.gt.generate_loft(airfoil_files, airfoil_path, urfl_NDIVS, lrfl_NDIVS,\n                                        semispan, b_low, b_up, b_NDIVS,\n                                        chords, twists, x_pos, z_pos;\n                                        symmetric=symmetric,\n                                        spl_k=spl_k, spl_s=spl_s,\n                                        verify_spline=verify_spline,\n                                        verify_rflspline=false,\n                                        rflspl_s=rflspl_s\n                                    )\n\n# Save vtk and call paraview\npnl.gt.save(wing, file_name; path=save_path, format=\"vtk\")\n\nrun(`paraview --data=$(joinpath(save_path, file_name)).vtk`)","category":"page"},{"location":"geometry/gridgeneration-loft/","page":"Lofting Method","title":"Lofting Method","text":"<img src=\"http://edoalvar2.groups.et.byu.net/public/FLOWPanel/wing05.gif\" alt=\"Vid here\" style=\"width: 900px;\"/>","category":"page"},{"location":"geometry/gridgeneration-loft/#Example-—-Propeller,-nonsymmetric-loft","page":"Lofting Method","title":"Example — Propeller, nonsymmetric loft","text":"","category":"section"},{"location":"geometry/gridgeneration-loft/","page":"Lofting Method","title":"Lofting Method","text":"Here we examplify the versatility of the lofting capabilities of our geometric engine by generating a two-bladed rotor that is lofted from tip to tip:","category":"page"},{"location":"geometry/gridgeneration-loft/","page":"Lofting Method","title":"Lofting Method","text":"import FLOWPanel as pnl\nimport GeometricTools as gt\n                                # Airfoil data path\nairfoil_path = joinpath(pnl.def_data_path, \"airfoils\");\n\nfile_name = \"prop00\"     # Output file name\nsave_path = \"./\"                # Save path\n\n# ----------------- GEOMETRY DESCRIPTION -------------------------------------------\nRtip = 10*0.0254/2                   # (m) Radius of propeller\n\nchords = [0.0 0.134*2/3;                # (blade position, chord c/Rtip)\n#             0.086 0.137106*5/6;\n#             0.86 0.141*2/3;\n#             0.16 0.144606;\n            0.2 0.154291;\n            0.25 0.175;\n            0.3 0.19;\n            0.35 0.198;\n            0.4 0.202;\n            0.45 0.2;\n            0.5 0.195;\n            0.55 0.186;\n            0.6 0.174;\n            0.65 0.161;\n            0.7 0.145;\n            0.75 0.129;\n            0.8 0.112;\n            0.85 0.096;\n            0.9 0.081;\n            0.9245 0.071125;\n            0.954 0.066125;\n            1.0 0.0233333]\n\ntwists = [                     # (blade position, twist (deg))\n#             0.01 0;                \n#             0.04715 22.0;\n#             0.088145 30.0;\n#             0.15 37.86;\n#             0.2 45.82;\n            0.25 44.19;\n            0.3 38.35;\n            0.35 33.64;\n            0.4 29.9;\n            0.45 27.02;\n            0.5 24.67;\n            0.55 22.62;\n            0.6 20.88;\n            0.65 19.36;\n            0.7 17.98;\n            0.75 16.74;\n            0.8 15.79;\n            0.85 14.64;\n            0.9 13.86;\n            0.95 12.72;\n            1.0 11.53]\n\nx_pos = [                        # (blade position, LE x-position x/Rtip)\n#             0.0 0.0;\n#             0.0266906 -0.0675531*0;      \n#             0.0993744 -0.0781078*0;\n            0.16992 -0.0810668;\n            0.209422 -0.0860351;\n            0.260681 -0.0914966;\n            0.310887 -0.0958101;\n            0.352557 -0.0986618;\n            0.39209 -0.101424;\n            0.430601 -0.100831;\n            0.473388 -0.100419;\n            0.521551 -0.0980235;\n            0.574004 -0.0947046;\n            0.632903 -0.0894484;\n            0.69823 -0.083358;\n            0.7518 -0.0767745;\n            0.801094 -0.0700117;\n            0.865384 -0.0616702;\n            0.94041 -0.0504677;\n            0.973671 -0.0430323;\n            0.986802 -0.030395]\n\nz_pos = [0.0 0.0;                  # (blade position, LE x-position x/Rtip)\n#             0.075 -0.003*0;\n            0.12 0.016;\n            0.2 0.044;\n            0.4 0.024;\n            0.6 0.00278494;\n            0.8 -0.02;\n            0.95 -0.0388821;\n            1.0 -0.056]\n\n\nairfoil_files = [                    # (blade position, airfoil file)\n            (0.0, \"Cyl2.csv\"),  \n            (0.02, \"Cyl2.csv\"),  \n#             (0.075, \"rflsec7.csv\"),\n#             (0.12, \"rflsec6.csv\"),\n            (0.2, \"naca5521.csv\"),\n            (0.3, \"naca4515.csv\"),\n            (0.4, \"naca5513.csv\"),\n            (0.5, \"naca5513.csv\"),\n            (0.6, \"naca4512.csv\"),\n            (0.7, \"naca4511.csv\"),\n            (0.8, \"naca4410.csv\"),\n            (0.9, \"naca4309.csv\"),\n            (1.0, \"naca4309.csv\")\n                ]\n\n# Mirrors distribution for opposite blade\nauxM = [chords[i,j] for i in size(chords,1):-1:1, j in 1:2]\nchords = vcat(auxM.*[[-1, 1][j] for i in 1:size(auxM,1), j in 1:2], chords)\n\nauxM = [twists[i,j] for i in size(twists,1):-1:1, j in 1:2]\nauxM[:,2] .+= 180\ntwists = vcat(auxM.*[[-1, -1][j] for i in 1:size(auxM,1), j in 1:2], twists)\n\nauxM = [x_pos[i,j] for i in size(x_pos,1):-1:1, j in 1:2]\nx_pos = vcat(auxM.*[[-1, -1][j] for i in 1:size(auxM,1), j in 1:2], x_pos)\n\nauxM = [z_pos[i,j] for i in size(z_pos,1):-1:1, j in 1:2]\nz_pos = vcat(auxM.*[[-1, 1][j] for i in 1:size(auxM,1), j in 1:2], z_pos)\n\n# auxM = reverse([(-pos, afile) for (pos, afile) in airfoil_files])\n# airfoil_files = vcat(auxM, airfoil_files)\n\n# Some parameters regarding the format of the airfoil files\nheader_len = 0\ndelim = \",\"\n\n# Reads and reflect the airfoils of opposite blade\nairfoils = [(pos, pnl.gt.readcontour(f_name; path=airfoil_path,\n                                      header_len=header_len, delim=delim,\n                                      output=\"matrix\"))\n                              for (pos, f_name) in airfoil_files]\n\nauxM = [(-pos, M .* [[1, -1][j] for i in 1:size(M,1), j in 1:2]) for (pos, M) in airfoils]\nairfoils = vcat(reverse(auxM), airfoils)\n\n\n# ----------------- MESHING PARAMETERS ---------------------------------------------\nN=4                                         # Scaling of number of cells\nurfl_NDIVS = [(0.10, 3*N, 5.0, false),      # Cells on upper side of airfoils\n              (0.30, 3*N, 2.0, true),\n              (0.10, 3*N, 1/5, false)]                   \nlrfl_NDIVS = urfl_NDIVS                     # Cells on lower side of airfoils\nb_NDIVS = [(1.0, 50*N, 5.0, true)]          # Span cells\n\n\n# ----------------- LOFTING PARAMETERS ---------------------------------------------\nb_low = -1.0                        # Lower bound of span lofting\nb_up = 1.0                          # Upper bound of span lofting\nsymmetric = false                   # Lofting symmetric about b=0\nspl_k = 5                           # Spline order of distributions along span\nspl_s = 0.0001                      # Spline smoothing of distribution along span\nrflspl_s = 0.00001                  # Spline smoothing of airfoil cross sections.\nverify_spline = true                # Plots the splined distributions\nverify_rflspline = true             # Plots the splined airfoil cross sections\n\n\n# ----------------- GENERATE WING --------------------------------------------------\nwing = pnl.gt.generate_loft(airfoils, urfl_NDIVS, lrfl_NDIVS,\n                                        Rtip, b_low, b_up, b_NDIVS,\n                                        chords, twists, x_pos, z_pos;\n                                        symmetric=symmetric,\n                                        spl_k=spl_k, spl_s=spl_s,\n                                        rflspl_s=rflspl_s,\n                                        verify_spline=verify_spline,\n                                        verify_rflspline=verify_rflspline\n                                    )\n\n# Save vtk and call paraview\npnl.gt.save(wing, file_name; path=save_path, format=\"vtk\")\n\nrun(`paraview --data=$(joinpath(save_path, file_name)).vtk`)","category":"page"},{"location":"geometry/gridgeneration-loft/","page":"Lofting Method","title":"Lofting Method","text":"<img src=\"http://edoalvar2.groups.et.byu.net/public/FLOWPanel/prop07.gif\" alt=\"Vid here\" style=\"width: 900px;\"/>","category":"page"},{"location":"geometry/basics-surfacegrid/#Surface-Grid","page":"Surface Grid","title":"Surface Grid","text":"","category":"section"},{"location":"geometry/basics-surfacegrid/","page":"Surface Grid","title":"Surface Grid","text":"A 3D surface grid can be generated by defining a 3D grid where one of its dimensions has zero divisions, and then transforming the space into the surface geometry. A dimension with zero divisions is recognized as a \"quasi-dimension\", which is a place holder for space transformations without actually spanning the dimensions of the grid. For instance, a 3D grid with one quasi-dimension doesn't define its cells as VTK-HEXAHEDRONs as a regular 3D grid would, but its cells are defined as VTK-QUADs. Also, quasi-dimensions are not considered as a coordinate direction, meaning that a node/cell in a 3D grid with one quasi-dimension is not indexed by three coordinates (ijk), but with only two coordinates (ij).","category":"page"},{"location":"geometry/basics-surfacegrid/","page":"Surface Grid","title":"Surface Grid","text":"The following lines exemplify the process of defining the quasi-dimensional grid, and applying the space transformation:","category":"page"},{"location":"geometry/basics-surfacegrid/","page":"Surface Grid","title":"Surface Grid","text":"import GeometricTools as gt\n\n# Create quasi-3D grid\nP_min = [0, -1, 0]            # Lower boundaries of arclength, span, and dummy\nP_max = [1, 1, 0 ]            # Upper boundaries of arclength, span, and dummy\nNDIVS = [20, 10, 0]           # Divisions: 20 arclength, 10 span, 0 dummy\ngrid = gt.Grid(P_min, P_max, NDIVS)\n\n# Create a space transformation function\nfunction my_space_transform(X)\n    new_X = ... # Write a new definition of each node here\n    return new_X\nend\n\n# Applie the space transformation\ngt.transform!(grid, my_space_transform)","category":"page"},{"location":"geometry/basics-surfacegrid/#Example-—-Paneled-Wing","page":"Surface Grid","title":"Example — Paneled Wing","text":"","category":"section"},{"location":"geometry/basics-surfacegrid/","page":"Surface Grid","title":"Surface Grid","text":"We will now use a space transformation on a 2D looped grid with 3D quasi-dimensions to generate the 3D surface of a wing.","category":"page"},{"location":"geometry/basics-surfacegrid/","page":"Surface Grid","title":"Surface Grid","text":"import FLOWPanel as pnl\nimport GeometricTools as gt\n                                # Airfoil data path\nairfoil_path = joinpath(pnl.def_data_path, \"airfoils\");\n\nfile_name = \"paneledwing00\"\nparaview = true\n\n# ----------------- READ AND PARAMETERIZE AIRFOILS ----------------------------\nsemispan = 10            # (m) semi-span length\n\nchords = [(0, 2.5),      # (semi-span position, chord length (m))\n          (0.25, 2.0),\n          (1, 1.0)]\n\nx_pos = [(0, 0),         # (semi-span position, leading edge x-position (m))\n         (0.25, semispan/40 ),\n         (1, semispan/8 )]\n\nz_pos = [(0, 0),         # (semi-span position, leading edge z-position (m))\n         (0.25, semispan/100 ),\n         (1, semispan/50 )]\n\ntwist = [(0, 5),         # (semi-span position, twist (deg))\n         (1, 0)]\n\nairfoils = [(0, \"naca6412.dat\"), # (semi-span position, airfoil geometry)\n            (1, \"naca6412.dat\")]\n\nairfoil_funs = []\n\nfor (pos, airfoil_file) in airfoils\n    # Read the original airfoil geometry from airfoiltools.com\n    org_x, org_y = gt.readcontour(joinpath(airfoil_path, airfoil_file); header_len=1)\n\n    # Separate upper and lower sides to make the contour injective in x\n    upper, lower = gt.splitcontour(org_x, org_y)\n\n    # Parameterize both sides independently\n    fun_upper = gt.parameterize(upper[1], upper[2], zeros(size(upper[1])); inj_var=1)\n    fun_lower = gt.parameterize(lower[1], lower[2], zeros(size(lower[1])); inj_var=1)\n\n    push!(airfoil_funs, [pos, (fun_upper, fun_lower)])\nend\n\n\n# ----------------- CREATE 3D SURFACE GRID ----------------------------------\nP_min = [0, -1, 0]            # Lower boundaries arclength, span, dummy\nP_max = [1, 1, 0 ]            # Upper boundaries arclength, span, dummy\nNDIVS = [20, 10, 0]           # 50 arclength cells, 10 span cells, 0 dummy\nloop_dim = 1                  # Loop the arclength dimension\n\ngrid = gt.Grid(P_min, P_max, NDIVS, loop_dim)\n\ngt.plot(grid; labelnodes=!true, labelcells=!true, labelndivs=true,\n                fontsize=8, fig_name=\"org\", title_str=\"Original Grid\",\n                alpha=0.25)","category":"page"},{"location":"geometry/basics-surfacegrid/","page":"Surface Grid","title":"Surface Grid","text":"<img src=\"../../assets/images/geometry-surfacegrid-wing00.png\" alt=\"Pic here\" style=\"width: 600px;\"/>\n<br><br><br><br>","category":"page"},{"location":"geometry/basics-surfacegrid/","page":"Surface Grid","title":"Surface Grid","text":"# Auxiliary function for weighting values across span\nfunction calc_vals(span, array)\n\n    # Finds bounding airfoil position\n    val_in, val_out = nothing, array[1]\n    for val in array[2:end]\n        val_in = val_out\n        val_out = val\n        if val[1]>=abs(span); break; end\n    end\n    pos_in = val_in[1]\n    val_in = val_in[2]\n    pos_out = val_out[1]\n    val_out = val_out[2]\n\n    weight = (abs(span)-pos_in)/(pos_out-pos_in)\n\n    return weight, val_in, val_out\nend\n\n# Creates a space transformation function\nfunction my_space_transform(X)\n    span = X[2]\n\n    # Calculates chord\n    weight, chord_in, chord_out = calc_vals(span, chords)\n    chord = weight*chord_out+(1-weight)*chord_in\n\n    # Calculates airfoil geometry\n    weight, rfl_in, rfl_out = calc_vals(span, airfoil_funs)\n    fun_upper_in, fun_lower_in = rfl_in\n    fun_upper_out, fun_lower_out = rfl_out\n\n    # Arc-length on upper or lower side of airfoil\n    if X[1]<0.5\n        s = 1 - 2 * X[1]\n        fun_in = fun_upper_in\n        fun_out = fun_upper_out\n    else\n        s = 2 * (X[1] - 0.5)\n        fun_in = fun_lower_in\n        fun_out = fun_lower_out\n    end\n\n    # Point over airfoil contour\n    point =  weight * fun_out(s) + (1 - weight) * fun_in(s)\n    point = chord * point\n\n    # Twist\n    weight, twist_in, twist_out = calc_vals(span, twist)\n    this_twist = weight * twist_out + (1 - weight) * twist_in\n\n    # Applies twist to the airfoil point\n    point = gt.rotation_matrix(-this_twist, 0, 0) * point\n\n    # Leading edge x-position\n    weight, x_in, x_out = calc_vals(span, x_pos)\n    le_x = weight * x_out + (1 - weight) * x_in\n\n    # Leading edge z-position\n    weight, z_in, z_out = calc_vals(span, z_pos)\n    le_z = weight * z_out + (1 - weight) * z_in\n\n    # Span position\n    y = X[2] * semispan\n\n    return [point[1] + le_x, y, point[2] + le_z]\nend\n\n# Transforms the quasi-2D grid into the wing surface\ngt.transform!(grid, my_space_transform)\n\n\nlims = [-semispan, semispan]\ngt.plot(grid; labelnodes=!true, labelcells=!true, labelndivs=true,\n                fontsize=8, title_str=\"Transformed grid\", alpha=0.25,\n                xlims=lims / 2 .* [0,1], ylims=lims, zlims=lims/10);","category":"page"},{"location":"geometry/basics-surfacegrid/","page":"Surface Grid","title":"Surface Grid","text":"<img src=\"../../assets/images/geometry-surfacegrid-wing01.png\" alt=\"Pic here\" style=\"width: 600px;\"/>\n<br><br><br><br>","category":"page"},{"location":"geometry/basics-surfacegrid/","page":"Surface Grid","title":"Surface Grid","text":"# Adds some dummy example fields\ngt.add_field(grid, \"node_index\", \"scalar\", [i for i in 1:grid.nnodes], \"node\")\ngt.add_field(grid, \"cell_index\", \"scalar\", [i for i in 1:grid.ncells], \"cell\")\n\nif paraview\n    # Outputs a vtk file\n    gt.save(grid, file_name; format=\"vtk\")\n\n    # Calls paraview\n    run(`paraview --data=$file_name.vtk`)\nend;","category":"page"},{"location":"geometry/basics-surfacegrid/","page":"Surface Grid","title":"Surface Grid","text":"<img src=\"../../assets/images/wing04.png\" alt=\"Pic here\" style=\"width: 800px;\"/>\n<img src=\"http://edoalvar2.groups.et.byu.net/public/FLOWPanel/wing04.gif\" alt=\"Vid here\" style=\"width: 800px;\"/>","category":"page"},{"location":"geometry/basics-surfacegrid/","page":"Surface Grid","title":"Surface Grid","text":"By construction, the wing we have defined has non-planar quadrilateral panel. Since some solvers require planar panels, GeometricTools has a especial type of grid that receives a 3D surface Grid object, and splits all non-planar quadrilateral panels into planar triangular panels of the VTK_TRIANGLE type.","category":"page"},{"location":"geometry/basics-surfacegrid/","page":"Surface Grid","title":"Surface Grid","text":"<img src=\"../../assets/images/vtk_triangle.png\" alt=\"Pic here\" style=\"width: 200px;\"/>\n<br><br>","category":"page"},{"location":"geometry/basics-surfacegrid/","page":"Surface Grid","title":"Surface Grid","text":"This is implemented in the GridTriangleSurface type:","category":"page"},{"location":"geometry/basics-surfacegrid/","page":"Surface Grid","title":"Surface Grid","text":"FLOWPanel.GeometricTools.GridTriangleSurface","category":"page"},{"location":"geometry/basics-surfacegrid/","page":"Surface Grid","title":"Surface Grid","text":"file_name = \"paneledwing01\"\n\n# Splits the quadrialateral panels into triangles\ndimsplit = 1              # Dimension along which to split\ntriang_grid = gt.GridTriangleSurface(grid, dimsplit)\n\n# Adds some dummy example fields\ngt.add_field(triang_grid, \"node_index\", \"scalar\",\n                    [i for i in 1:triang_grid.nnodes], \"node\")\ngt.add_field(triang_grid, \"cell_index\", \"scalar\",\n                    [i for i in 1:triang_grid.ncells], \"cell\")\ngt.add_field(triang_grid, \"normal\", \"vector\",\n                    [gt.get_normal(triang_grid, i)\n                       for i in 1:triang_grid.ncells], \"cell\")\ngt.add_field(triang_grid, \"tangent\", \"vector\",\n                    [gt.get_tangent(triang_grid, i)\n                       for i in 1:triang_grid.ncells], \"cell\")\n\nif paraview\n    # Outputs a vtk file\n    gt.save(triang_grid, file_name; format=\"vtk\")\n\n    # Calls paraview\n    run(`paraview --data=$file_name.vtk`)\nend","category":"page"},{"location":"geometry/basics-surfacegrid/","page":"Surface Grid","title":"Surface Grid","text":"<img src=\"../../assets/images/wing05.png\" alt=\"Pic here\" style=\"width: 900px;\"/>","category":"page"},{"location":"geometry/gridgeneration/#Methods","page":"Methods","title":"Methods","text":"","category":"section"},{"location":"geometry/gridgeneration/","page":"Methods","title":"Methods","text":"While the previous section outlines the basics on how to generate geometry manually using GeometricTools, this section shows how geometry can be automatically generated.","category":"page"},{"location":"geometry/gridgeneration/","page":"Methods","title":"Methods","text":"Three methods are reviewed:","category":"page"},{"location":"geometry/gridgeneration/","page":"Methods","title":"Methods","text":"Surface lofting\nSurface of revolution\nSpace transformation","category":"page"},{"location":"geometry/gridgeneration/","page":"Methods","title":"Methods","text":"Each of these methods return a grid of quadrilateral panels that are not necessarily planar. Because some element types require planar panels, we also review a method for generating a triangular grid out of any grid obtained from the previous methods.","category":"page"},{"location":"examples/centerbody-source/","page":"Source Elements","title":"Source Elements","text":"<center>\n  <img src=\"../../assets/images/centerbody-viz00.png\" alt=\"Pic here\" style=\"width: 100%;\"/>\n</center>","category":"page"},{"location":"examples/centerbody-source/","page":"Source Elements","title":"Source Elements","text":"In this example we solve the flow around a body of revolution resembling the centerbody (hub) of a ducted fan.","category":"page"},{"location":"examples/centerbody-source/#Source-Elements","page":"Source Elements","title":"Source Elements","text":"","category":"section"},{"location":"examples/centerbody-source/","page":"Source Elements","title":"Source Elements","text":"First we run this example with source elements, which are especially accurate for non-lifting bodies.","category":"page"},{"location":"examples/centerbody-source/","page":"Source Elements","title":"Source Elements","text":"#=##############################################################################\n# DESCRIPTION\n    Centerbody (body of revolution) replicating the experiment reported in\n    Section Section 4.3.2 of Lewis, R. (1991), \"Vortex Element Methods for\n    Fluid Dynamic Analysis of Engineering Systems.\"\n\n# AUTHORSHIP\n  * Author    : Eduardo J. Alvarez\n  * Email     : Edo.AlvarezR@gmail.com\n  * Created   : Dec 2022\n  * License   : MIT License\n=###############################################################################\n\nimport FLOWPanel as pnl\nimport CSV\nimport DataFrames: DataFrame\n\nrun_name        = \"centerbody-lewis00\"      # Name of this run\n\nsave_path       = \"\"                        # Where to save outputs\nparaview        = true                      # Whether to visualize with Paraview\n\n\n# ----------------- SIMULATION PARAMETERS --------------------------------------\nAOA             = 0.0                       # (deg) angle of attack\nmagVinf         = 30.0                      # (m/s) freestream velocity\nVinf            = magVinf*[cos(AOA*pi/180), 0, sin(AOA*pi/180)] # Freestream\n\nrho             = 1.225                     # (kg/m^3) air density\n\n\n# ----------------- GEOMETRY DESCRIPTION ---------------------------------------\n# Read body contour (table 4.2 in Lewis 1991)\nfilename        = joinpath(pnl.examples_path, \"data\",\n                                \"centerbody-lewis-table4p2.csv\")\ncontour_lewis   = CSV.read(filename, DataFrame)\n\nR               = maximum(contour_lewis[:, 2]) # (m) max radius\n\n# ----------------- SOLVER PARAMETERS ------------------------------------------\n# Discretization\nNDIVS_theta     = 60                        # Number of azimuthal panels\n\n# Solver\nbodytype        = pnl.NonLiftingBody{pnl.ConstantSource}    # Elements and wake model\n\n\n# ----------------- GENERATE BODY ----------------------------------------------\n# Generate grid of body of revolution\n# holeradius      = 0.10*R                    # Hole in centerbody\n                                            # Points of contour to revolve\npoints = Matrix(contour_lewis[2:end-1, :])\n# points[1, 2] += holeradius\n\ngrid = pnl.gt.surface_revolution(points, NDIVS_theta;\n                                    # Loop the azimuthal dimension to close the surface\n                                    loop_dim=2,\n                                    # Rotate the axis of rotation to align with x-axis\n                                    axis_angle=90\n                                )\n\n# Rotate the body of revolution to align centerline with x-axis\nOaxis = pnl.gt.rotation_matrix2(0, 0, 90)          # Rotation matrix\nO = zeros(3)                                       # Translation of coordinate system\npnl.gt.lintransform!(grid, Oaxis, O)\n\n# Triangular grid (splits quadrangular panels into triangular panels)\nsplit_dim = 1                               # Dimension to split into triangles\ntrigrid = pnl.gt.GridTriangleSurface(grid, split_dim)\n\n# Generate body to be solved\nbody = bodytype(trigrid)\n\nprintln(\"Number of panels:\\t$(body.ncells)\")\n\n\n# ----------------- CALL SOLVER ------------------------------------------------\nprintln(\"Solving body...\")\n\n# Freestream at every control point\nUinfs = repeat(Vinf, 1, body.ncells)\n\n# Solve body (panel strengths) giving `Uinfs` as boundary conditions\n@time pnl.solve(body, Uinfs)\n\n\n# ----------------- POST PROCESSING --------------------------------------------\nprintln(\"Post processing...\")\n\n# Calculate surface velocity on the body\n@time Us = pnl.calcfield_U(body, body)\n\n# Calculate pressure coefficient\n@time Cps = pnl.calcfield_Cp(body, magVinf)\n\n# Calculate the force of each panel\n@time Fs = pnl.calcfield_F(body, magVinf, rho)\n\n\n# ----------------- VISUALIZATION ----------------------------------------------\nif paraview\n    str = save_path*\"/\"\n\n    # Save body as a VTK\n    str *= pnl.save(body, run_name; path=save_path, debug=true)\n\n    # Call Paraview\n    run(`paraview --data=$(str)`)\nend\n\n","category":"page"},{"location":"examples/centerbody-source/","page":"Source Elements","title":"Source Elements","text":"(see the complete example under examples/centerbody.jl )","category":"page"},{"location":"examples/blendedwingbody-cad/","page":"CAD Model","title":"CAD Model","text":"<center>\n  <img src=\"http://edoalvar2.groups.et.byu.net/public/FLOWPanel/zeroebwb009.jpg\" alt=\"Pic here\" style=\"width: 100%;\"/>\n</center>","category":"page"},{"location":"examples/blendedwingbody-cad/","page":"CAD Model","title":"CAD Model","text":"In this example we analyze a blended wing body that is generated from CAD (SolidWorks). We show how to import the NURBS geometry into Gmsh to generate an unstructured watertight mesh with arbitrary regions of refinement, which is then read by FLOWPanel using Meshes.jl.","category":"page"},{"location":"examples/blendedwingbody-cad/","page":"CAD Model","title":"CAD Model","text":"To run this tutorial you will have to install a few dependencies for processing unstructured grids:","category":"page"},{"location":"examples/blendedwingbody-cad/","page":"CAD Model","title":"CAD Model","text":"import Pkg\n\nPkg.add(Meshes)\nPkg.add(GeoIO)\nPkg.add(Rotations)","category":"page"},{"location":"examples/blendedwingbody-cad/#CAD-Model","page":"CAD Model","title":"CAD Model","text":"","category":"section"},{"location":"examples/blendedwingbody-cad/","page":"CAD Model","title":"CAD Model","text":"Download the original SolidWorks CAD file from GrabCAD:  grabcad.com/library/airbuszeroe-blended-wing-body-concept-1  (Image: pic)\nRemove unnecessary parting lines and ducted fan array  (Image: pic)\nAdd a parting line along the leading edge around which we will later  customize the mesh refinement  (Image: pic)\nExport as a STEP file","category":"page"},{"location":"examples/blendedwingbody-cad/","page":"CAD Model","title":"CAD Model","text":"info: STEP File\nThe resulting .STEP file is available here: LINK (right click → save as...).","category":"page"},{"location":"examples/blendedwingbody-gmsh/#Unstructured-Mesh-Generation","page":"Unstructured Meshing","title":"Unstructured Mesh Generation","text":"","category":"section"},{"location":"examples/blendedwingbody-gmsh/","page":"Unstructured Meshing","title":"Unstructured Meshing","text":"We now open the NURBS from the STEP file in Gmsh and generate an unstructured surface mesh with refinement along the leading edge of the wing.","category":"page"},{"location":"examples/blendedwingbody-gmsh/","page":"Unstructured Meshing","title":"Unstructured Meshing","text":"NOTE: the CurveLists described below are valid for the file zeroebwb.STEP and Gmsh v4.8.4","category":"page"},{"location":"examples/blendedwingbody-gmsh/","page":"Unstructured Meshing","title":"Unstructured Meshing","text":"Import STEP file\nFile > Merge\nCreate physical group with all NURBS surfaces\nMake sure that geometric surfaces are visible: Tools > Options > Geometry > Visibility > Surfaces\nCreate physical group: Modules > Geometry > Physical Groups > Add > Surface\nPress CTRL + Right Click to box-select\n(Image: pic)\nCreate criterion for refinement at LE\nModules > Mesh > Define > Size fields\nDefine leading edge lines: Distance with CurvesList set to 33,25,53,45 and 1000 for NumPointsPercurve\nDefine transition lines: Distance with CurvesList set to 18,19,56,54 and 1000 for NumPointsPercurve\nDefine upper-bound lines of leading edge: Distance with CurvesList set to 30, 22, 55, 47 and 1000 for NumPointsPercurve\nDefine lower-bound lines of leading edge: Distance with CurvesList set to 35, 28, 51, 43 and 1000 for NumPointsPercurve\nDefine cell size based on distance to leading edge: MathEval with the formula 1.5*(F1^1.2 + 500/F2^0.5)/2 + 30\nDefine cell size based on thickness of leading edge: MathEval with the formula 3*((5*F1+F3+F4)/7)^1.5 + 5\nMix both cell sizes: Min with FieldsList set to 5,6, select \"Set as background field\" and click Apply. Defined this way, it refines the mesh in the proximity of the LE lines based on LE thickness, while transitioning the refinement close to the transition lines.\nSet mesher settings\nSet size factor: Tools > Options > Mesh > General > Element size factor and set to 0.1\nSelect MeshAdapt for the 2D algorithm\nMesh the NURBS surface\nDiscretize 1D curves: Modules > Mesh > 1D\nDiscretize 2D surfaces: Modules > Mesh > 2D\nSmooth out the discretization by clicking Modules > Mesh > Smooth 2D a few times\n(Image: pic)\nExport mesh as .msh in ASCII format v4: File > Export and select Mesh - Gmsh MSH (*.msh) in the dropdown menu","category":"page"},{"location":"examples/blendedwingbody-gmsh/","page":"Unstructured Meshing","title":"Unstructured Meshing","text":"info: `.msh` File\nThe resulting .msh file is available here: LINK (right click → save as...).","category":"page"},{"location":"examples/centerbody-slice/#Slice","page":"Slice","title":"Slice","text":"","category":"section"},{"location":"examples/centerbody-slice/","page":"Slice","title":"Slice","text":"FLOWPanel provides the following function to obtain the solution field along a slice along a body:","category":"page"},{"location":"examples/centerbody-slice/","page":"Slice","title":"Slice","text":"FLOWPanel.slicefield","category":"page"},{"location":"examples/centerbody-slice/#FLOWPanel.slicefield","page":"Slice","title":"FLOWPanel.slicefield","text":"slicefield(body::AbstractBody, fieldname::String,\n            position::Number, direction::Vector, row::Bool)\n\nReturn a slice of the field fieldname in body corresponding to the row or column (\"row\" is the first dimension of the grid, \"column\" is the second dimension) that is the closest to position calculated as the projection of the average cell position in the direction direction.\n\nExample: For a wing with its span aligned along the y-axis, the pressure along a slice of the wing at the spanwise position y=0.5 is obtained as slicefield(wing, \"Cp\", 0.5, [0, 1, 0], false).\n\n\n\n\n\nslicefield(body::AbstractBody, controlpoints::Matrix,\n                fieldname::String,\n                position::Number, direction::Vector, row::Bool)\n\nSame thing, but with the option of providing the control points as to save avoid memory allocation.\n\n\n\n\n\n","category":"function"},{"location":"examples/centerbody-slice/","page":"Slice","title":"Slice","text":"Now we process the solution to plot the surface velocity along a slice of the body of revolution.","category":"page"},{"location":"examples/centerbody-slice/","page":"Slice","title":"Slice","text":"import PyPlot as plt\nimport LaTeXStrings: @L_str\ninclude(joinpath(pnl.examples_path, \"plotformat.jl\"))\n\n# ----------------- COMPARISON TO EXPERIMENTAL DATA ----------------------------\n#=\n    NOTE: Here we take a slice of the body and plot the velocity distribution\n    along the slice.\n=#\n\n# Get a slice of the body\nposition        = 0.0        # Position of slice (slice along origin)\ndirection       = [0, 1, 0]  # Direction of slice (slice along the xz-plane)\nrow             = false      # If true, it slices along azimuth; centerline if false\n\nslicepoints, sliceCps = pnl.slicefield(body, \"Cp\", position, direction, row)\nslicepoints, sliceUs = pnl.slicefield(body, \"U\", position, direction, row)\n\n# Plot experimental surface velocity distribution (figure 4.6 in Lewis 1991)\nfig = plt.figure(figsize=[7, 5*0.8]*2/3)\nax = fig.gca()\n\nfilename = joinpath(pnl.examples_path, \"data\",\n                                \"centerbody-lewis-fig4p6.csv\")\nVoVinf_lewis = CSV.read(filename, DataFrame)\n\nax.plot(VoVinf_lewis[:, 1], VoVinf_lewis[:, 2], \"ok\",\n                            markersize=5, label=\"Experimental\")\n\n# Plot surface velocity distribution of FLOWPanel\nax.plot(slicepoints[1, :], pnl.norm.(sliceUs)/magVinf, \"-\", color=\"cyan\",\n                            linewidth=2.0, alpha=0.9, label=\"FLOWPanel\")\n\n# Plot contour of centerbody\nax2 = ax.twinx()\nxs = vcat(slicepoints[1, :], reverse(slicepoints[1, :]), slicepoints[1, 1])\nys = vcat(slicepoints[3, :], -reverse(slicepoints[3, :]), slicepoints[3, 1])\nax2.plot(xs, ys, \"-k\", alpha=0.25)\n","category":"page"},{"location":"examples/centerbody-slice/","page":"Slice","title":"Slice","text":"<center>\n    <br><b>Surface velocity</b><br>\n    <img src=\"../../assets/images/centerbody-lewis00-velocity-source.png\" alt=\"Pic here\" style=\"width: 60%;\"/>\n</center>","category":"page"},{"location":"geometry/gridgeneration-rev/#Surface-of-Revolution-Method","page":"Surface of Revolution Method","title":"Surface of Revolution Method","text":"","category":"section"},{"location":"geometry/gridgeneration-rev/","page":"Surface of Revolution Method","title":"Surface of Revolution Method","text":"Following the concept of bodies of revolution where a contour is revolved around an axis, this method generates the surface of such revolution.","category":"page"},{"location":"geometry/gridgeneration-rev/","page":"Surface of Revolution Method","title":"Surface of Revolution Method","text":"FLOWPanel.GeometricTools.surface_revolution","category":"page"},{"location":"geometry/gridgeneration-rev/#GeometricTools.surface_revolution","page":"Surface of Revolution Method","title":"GeometricTools.surface_revolution","text":"surface_revolution(profile, thetaNDIVS; loop_dim=0, axis_angle=0, low_a=0, up_a=360, save_path=nothing, paraview=true, file_name=\"myrev\")\n\nReceives a contour to revolve around an axis generating a surface of revolution.\n\nARGUMENTS\n\nprofile::Array{Float64,2}   : Contour to revolve. These are two-                                 dimensional points in the YZ-plane that will                                 get revolve around the Z-axis.\nthetaNDIVS::Int64           : Number of angle-sections (cells) in the                                 revolution.\n\nOPTIONAL ARGUMENTS\n\nloop_dim::Int64=0           : Whether to loop any dimension of the                                 parametric grid.\naxis_angle::Float64=0       : Tilting angle (deg) about the Z-axis to                                 revolve the contour.\nlow_a::Float64=0            : Lower bound of angle (deg) of revolution.\nup_a::Float64=0             : Upper bound of angle (deg) of revolution.\n\n\n\n\n\n","category":"function"},{"location":"geometry/gridgeneration-rev/#Node-and-Cell-Indexing","page":"Surface of Revolution Method","title":"Node and Cell Indexing","text":"","category":"section"},{"location":"geometry/gridgeneration-rev/","page":"Surface of Revolution Method","title":"Surface of Revolution Method","text":"Standard input:","category":"page"},{"location":"geometry/gridgeneration-rev/","page":"Surface of Revolution Method","title":"Surface of Revolution Method","text":"Contour drawn in the +y quadrants following the Selig airfoil format (starting at the trailing edge, progressing to the leading edge along the upper surface, and returning to the trailing edge along the lower surface).\nThe contour can be a closed curve describing the a toroidal cross section (as in the case of the duct), or an open contour along the y=0 axis describing the half surface of a cylindrical body of revolution (as in the case of the centerbody).","category":"page"},{"location":"geometry/gridgeneration-rev/","page":"Surface of Revolution Method","title":"Surface of Revolution Method","text":"Following these guidelines, GeometricTools.surface_revolution returns a revolved quadrilateral surface with the following node and cell indexing pattern:","category":"page"},{"location":"geometry/gridgeneration-rev/","page":"Surface of Revolution Method","title":"Surface of Revolution Method","text":"\n<center>\n  <table>\n      <tr>\n          <th>\n              <center>First Coordinate</center>\n          </th>\n          <th>\n              <center>Second Coordinate</center>\n          </th>\n      </tr>\n      <tr>\n          <td>\n              <img src=\"../../assets/images/bodyrev-cellindexdim1-00transp.png\" alt=\"Pic here\" width=\"450px\">\n          </td>\n          <td>\n              <img src=\"../../assets/images/bodyrev-cellindexdim2-00transp.png\" alt=\"Pic here\" width=\"450px\">\n          </td>\n      </tr>\n  </table>\n</center>\n\n<br><br>\n\n<center>\n  <table>\n      <tr>\n          <th>\n              <center>Node Index</center>\n          </th>\n          <th>\n              <center>Cell Index</center>\n          </th>\n      </tr>\n      <tr>\n          <td>\n              <img src=\"../../assets/images/bodyrev-nodeindex-000transp.png\" alt=\"Pic here\" width=\"450px\">\n          </td>\n          <td>\n              <img src=\"../../assets/images/bodyrev-cellindex-000transp.png\" alt=\"Pic here\" width=\"450px\">\n          </td>\n      </tr>\n  </table>\n</center>\n\n<br><br>\n\n<center>\n  <table>\n      <tr>\n          <th>\n              <center>Cell (1, 1)</center>\n          </th>\n          <th>\n              <center>Cell (40, 1)</center>\n          </th>\n          <th>\n              <center>Cell (39, 2)</center>\n          </th>\n      </tr>\n      <tr>\n          <td>\n              <img src=\"../../assets/images/bodyrev-cell1c1-000transp.png\" alt=\"Pic here\" width=\"450px\">\n          </td>\n          <td>\n              <img src=\"../../assets/images/bodyrev-cell40c1-000transp.png\" alt=\"Pic here\" width=\"450px\">\n          </td>\n          <td>\n              <img src=\"../../assets/images/bodyrev-cell39c2-000transp.png\" alt=\"Pic here\" width=\"450px\">\n          </td>\n      </tr>\n  </table>\n</center>","category":"page"},{"location":"geometry/gridgeneration-rev/","page":"Surface of Revolution Method","title":"Surface of Revolution Method","text":"OBSERVATION: The following examples show how to use the revolution method directly from the GeometricTools package. In order to use this grid in the definition of a body, the quadrilateral panels must by transformed into triangular panels through GeometricTools.GridTriangleSurface(orggrid, dimsplit).","category":"page"},{"location":"geometry/gridgeneration-rev/#Example-—-Rotor-hub","page":"Surface of Revolution Method","title":"Example — Rotor hub","text":"","category":"section"},{"location":"geometry/gridgeneration-rev/","page":"Surface of Revolution Method","title":"Surface of Revolution Method","text":"First, we need a profile to revolve consisting of a collection of points. This can be predefined and read as a csv file (for example), or defined programmatically. Here we show how to define the contour programmatically:","category":"page"},{"location":"geometry/gridgeneration-rev/","page":"Surface of Revolution Method","title":"Surface of Revolution Method","text":"import PyPlot as plt\n\nRhub = 0.375 * 0.02542        # (m) radius of hub\nRinn = Rhub / 2               # (m) inner hole radius\nRsec1 = Rinn                # (m) radius of first hole\nRsec2 = 3 / 1000              # (m) radius of second hole\nThub = Rhub                 # (m) thickness of hub\ndsec1 = 3 / 1000              # (m) depth of first hole\n\nRfillet = 2 / 1000            # (m) Fillet radius\nNfillet = 30                # Points along fillet\nCfillet = [Rhub, Thub] .- Rfillet      # Center of fillet\n\npoints_fillet = [Cfillet .+ Rfillet * [sin(a), cos(a)]\n                        for a in range(0, stop=pi/2, length=Nfillet)]\n\npoints = hcat(\n              [Rsec2, Thub-dsec1],\n              [Rsec1, Thub-dsec1],\n              [Rsec1, Thub],\n              points_fillet...,\n              [Rhub, 0],\n              [Rsec1, 0],\n              [Rsec1, dsec1],\n              [Rsec2, dsec1],\n              [Rsec2, Thub-dsec1]\n             )'\n\nx = [points[i,1] for i in 1:size(points,1)]\ny = [points[i,2] for i in 1:size(points,1)]\n\nplt.figure(figsize=[5,5]*2/3)\nplt.plot(x,y, \"--ok\")\nplt.plot([Cfillet[1]], [Cfillet[2]], \"xr\")\nplt.xlim([0, Rhub*1.25])\nplt.ylim([-Rhub*0.125, Rhub*1.125]);\n\nplt.savefig(joinpath(img_path, \"geometry-hubcontour00.png\"), transparent=true, dpi=300)","category":"page"},{"location":"geometry/gridgeneration-rev/","page":"Surface of Revolution Method","title":"Surface of Revolution Method","text":"<img src=\"../../assets/images/geometry-hubcontour00.png\" alt=\"Vid here\" style=\"width: 300px;\"/>","category":"page"},{"location":"geometry/gridgeneration-rev/","page":"Surface of Revolution Method","title":"Surface of Revolution Method","text":"import FLOWPanel as pnl\n\nsave_path = \"./\"\nfile_name = \"hub00\"\n\nthetaNDIVS = 180          # Number of angular sections\nloop_dim = 1             # Loops the parametric grid\n\n# Creates body of revolution\ngrid = pnl.gt.surface_revolution(points, thetaNDIVS; loop_dim=loop_dim)\n\n# Save vtk and call paraview\npnl.gt.save(grid, file_name; path=save_path, format=\"vtk\")\n\nrun(`paraview --data=$(joinpath(save_path, file_name)).vtk`)","category":"page"},{"location":"geometry/gridgeneration-rev/","page":"Surface of Revolution Method","title":"Surface of Revolution Method","text":"<img src=\"http://edoalvar2.groups.et.byu.net/public/FLOWPanel/hub00.gif\" alt=\"Vid here\" style=\"width: 800px;\"/>","category":"page"},{"location":"geometry/gridgeneration-rev/#Example-—-Tilted-revolution","page":"Surface of Revolution Method","title":"Example — Tilted revolution","text":"","category":"section"},{"location":"geometry/gridgeneration-rev/","page":"Surface of Revolution Method","title":"Surface of Revolution Method","text":"By using the optional argument axis_angle we can tilt the angle about which to do the revolution. To exemplify this, using the previous contour we will tilting the axis by 90^circ about the z-axis, resulting in a revolution about the y-axis:","category":"page"},{"location":"geometry/gridgeneration-rev/","page":"Surface of Revolution Method","title":"Surface of Revolution Method","text":"axis_angle = 90          # Axis tilting\n\ngrid = pnl.gt.surface_revolution(points, thetaNDIVS;\n                                    loop_dim=loop_dim,\n                                    axis_angle=axis_angle)\n\n# Save vtk and call paraview\npnl.gt.save(grid, file_name; path=save_path, format=\"vtk\")\n\nrun(`paraview --data=$(joinpath(save_path, file_name)).vtk`)","category":"page"},{"location":"geometry/gridgeneration-rev/","page":"Surface of Revolution Method","title":"Surface of Revolution Method","text":"<img src=\"http://edoalvar2.groups.et.byu.net/public/FLOWPanel/hub02.gif\" alt=\"Vid here\" style=\"width: 800px;\"/>","category":"page"},{"location":"geometry/gridgeneration-rev/","page":"Surface of Revolution Method","title":"Surface of Revolution Method","text":"And here is what we get by tilting the axis by 45^circ about the z-axis:","category":"page"},{"location":"geometry/gridgeneration-rev/","page":"Surface of Revolution Method","title":"Surface of Revolution Method","text":"axis_angle = 45          # Axis tilting\n\ngrid = pnl.gt.surface_revolution(points, thetaNDIVS;\n                                    loop_dim=loop_dim,\n                                    axis_angle=axis_angle)\n\n# Save vtk and call paraview\npnl.gt.save(grid, file_name; path=save_path, format=\"vtk\")\n\nrun(`paraview --data=$(joinpath(save_path, file_name)).vtk`)","category":"page"},{"location":"geometry/gridgeneration-rev/","page":"Surface of Revolution Method","title":"Surface of Revolution Method","text":"<img src=\"http://edoalvar2.groups.et.byu.net/public/FLOWPanel/hub03.gif\" alt=\"Vid here\" style=\"width: 800px;\"/>","category":"page"},{"location":"geometry/gridgeneration-rev/#Example-—-Incomplete-revolution","page":"Surface of Revolution Method","title":"Example — Incomplete revolution","text":"","category":"section"},{"location":"geometry/gridgeneration-rev/","page":"Surface of Revolution Method","title":"Surface of Revolution Method","text":"Using the arguments low_a and up_a we can set the lower and upper bound angles of the revolution to create an incomplete body of revolution:","category":"page"},{"location":"geometry/gridgeneration-rev/","page":"Surface of Revolution Method","title":"Surface of Revolution Method","text":"thetaNDIVS = 45          # Number of angular sections\nloop_dim = 1             # Loops the parametric grid\nlow_a = -45              # Lower bound of revolution angle\nup_a = 45                # Upper bound of revolution angle\n\ngrid = pnl.gt.surface_revolution(points, thetaNDIVS;\n                                    loop_dim=loop_dim,\n                                    low_a=low_a, up_a=up_a)\n\n# Save vtk and call paraview\npnl.gt.save(grid, file_name; path=save_path, format=\"vtk\")\n\nrun(`paraview --data=$(joinpath(save_path, file_name)).vtk`)","category":"page"},{"location":"geometry/gridgeneration-rev/","page":"Surface of Revolution Method","title":"Surface of Revolution Method","text":"<img src=\"http://edoalvar2.groups.et.byu.net/public/FLOWPanel/hub04.gif\" alt=\"Vid here\" style=\"width: 800px;\"/>","category":"page"},{"location":"elements/semiinfnonplanardoublet/#Non-Planar-Semi-Infinite-Doublet-(Vortex-Horseshoe)","page":"Non-Planar Semi-Infinite Doublet","title":"Non-Planar Semi-Infinite Doublet (Vortex Horseshoe)","text":"","category":"section"},{"location":"elements/semiinfnonplanardoublet/","page":"Non-Planar Semi-Infinite Doublet","title":"Non-Planar Semi-Infinite Doublet","text":"Suppose that we have a semi-infinite panel with a outgoing semi-infinite direction different than the incoming direction. That means that the semi-infinite panel is no longer planar. In this circumstances, the induced velocity mathbfu is computed just as explained in the previous section since it's simply a horseshoe. The computation of the potential field, however, needs a some adaptation.","category":"page"},{"location":"elements/semiinfnonplanardoublet/","page":"Non-Planar Semi-Infinite Doublet","title":"Non-Planar Semi-Infinite Doublet","text":"From mathbfp_b, we split the panel into two, and create two planar sections as shown below. The computation is then done on the -hatmathbfd_a mathbfp_i mathbfp_j +hatmathbfd_a section as explained before, while the -hatmathbfd_a mathbfp_j +hatmathbfd_b is approximated numerically with a large panel.","category":"page"},{"location":"elements/semiinfnonplanardoublet/","page":"Non-Planar Semi-Infinite Doublet","title":"Non-Planar Semi-Infinite Doublet","text":"<center>\n  <img src=\"../../assets/images/semiinfinite-nonplanar-doublet02.png\" alt=\"Pic here\" width=\"450px\">\n</center>","category":"page"},{"location":"elements/semiinfnonplanardoublet/","page":"Non-Planar Semi-Infinite Doublet","title":"Non-Planar Semi-Infinite Doublet","text":"The potential and velocity field of a non-planar semi-infinte doublet panel (or non-planar vortex horseshoe) of unitary strength (mu=1 or Gamma=1) is shown below","category":"page"},{"location":"elements/semiinfnonplanardoublet/","page":"Non-Planar Semi-Infinite Doublet","title":"Non-Planar Semi-Infinite Doublet","text":"<center>\n  <table>\n      <tr>\n          <th>\n              <img src=\"../../assets/images/panel-semiinfinite-nonplanar-doublet-phi00.png\" alt=\"Pic here\" width=\"450px\">\n          </th>\n          <th>\n              <img src=\"../../assets/images/panel-semiinfinite-nonplanar-doublet-u00.png\" alt=\"Pic here\" width=\"450px\">\n          </th>\n      </tr>\n  </table>\n</center>","category":"page"},{"location":"elements/semiinfnonplanardoublet/","page":"Non-Planar Semi-Infinite Doublet","title":"Non-Planar Semi-Infinite Doublet","text":"<center>\n  <br>$\\nabla \\phi$ = $\\mathbf{u}$ verification\n  <img src=\"../../assets/images/panel-semiinfinitenonplanardoublet-divphivsu00.png\" alt=\"Pic here\" style=\"width: 700px;\"/>\n</center>","category":"page"},{"location":"potentialflow/#Problem-Formulation","page":"Potential Flow","title":"Problem Formulation","text":"","category":"section"},{"location":"potentialflow/","page":"Potential Flow","title":"Potential Flow","text":"(Adapted from Katz and Plotkin's Low Speed Aerodynamics, Sec 3.2)","category":"page"},{"location":"potentialflow/","page":"Potential Flow","title":"Potential Flow","text":"By Helmholtz' decomposition theorem, any velocity field mathbfu can be decomposed into a uniform component, an irrotational component, and a solenoidal component as","category":"page"},{"location":"potentialflow/","page":"Potential Flow","title":"Potential Flow","text":"beginalign*\n        mathbfu\n    =\n        underbracemathbfu_infty_textuniform\n        + underbracenablaphi_textirrotational\n        + underbracenablatimesboldsymbolpsi_textsolenoidal\nendalign*","category":"page"},{"location":"potentialflow/","page":"Potential Flow","title":"Potential Flow","text":"where mathbfu_infty(t) is the freestream, phi (mathbfx t) is a scalar-potential field, and boldsymbolpsi (mathbfx t) is a vector-potential field.","category":"page"},{"location":"potentialflow/","page":"Potential Flow","title":"Potential Flow","text":"NOTE: Even though here we show mathbfu_infty as its own component, the freestream can be rolled into the potential field as a linearly-varying potential, giving a uniform velocity field.","category":"page"},{"location":"potentialflow/","page":"Potential Flow","title":"Potential Flow","text":"Assuming incompressible flow, the continuity equation poses a Laplace equation for the scalar-potential as","category":"page"},{"location":"potentialflow/","page":"Potential Flow","title":"Potential Flow","text":"beginalign*\n        nabla cdot mathbfu = 0\n    quadRightarrowquad\n        nabla^2 phi = 0\nendalign*","category":"page"},{"location":"potentialflow/","page":"Potential Flow","title":"Potential Flow","text":"Before we continue, let us derive a useful integral identity: Green's second identity. Let f and g be two differentiable functions, we have","category":"page"},{"location":"potentialflow/","page":"Potential Flow","title":"Potential Flow","text":"beginalign*\n    nabla cdot left( f nabla g - g nabla f right) = f nabla^2 g - g nabla^2 f\nendalign*","category":"page"},{"location":"potentialflow/","page":"Potential Flow","title":"Potential Flow","text":"The divergence theorem then leads to","category":"page"},{"location":"potentialflow/","page":"Potential Flow","title":"Potential Flow","text":"beginalign*\n        intlimits_partial V\n            left( f nabla g - g nabla f right) cdot hatmathbfn\n        mathrmdS\n     =\n        intlimits_V\n            left( f nabla^2 g - g nabla^2 f right)\n        mathrmdV\nendalign*","category":"page"},{"location":"potentialflow/","page":"Potential Flow","title":"Potential Flow","text":"over any volume V. Here we have defined the normal hatmathbfn  as pointing outward from V.","category":"page"},{"location":"potentialflow/","page":"Potential Flow","title":"Potential Flow","text":"Using Green's second identity, we now define f(mathbfx) equiv frac1Vert mathbfx - mathbfx_p Vert^2 = frac1r and g(mathbfx) equiv phi(mathbfx) where r is the distance to a point mathbfx_p defining an arbitrary fixed center, and the identity gives","category":"page"},{"location":"potentialflow/","page":"Potential Flow","title":"Potential Flow","text":"beginalign*\n        intlimits_partial V\n            left frac1r nabla phi - phi nabla left(frac1rright) right cdot hatmathbfn\n        mathrmdS\n     =\n        intlimits_V\n            left frac1r cancelnabla^2 phi^0 - phi cancelnabla^2 left(frac1rright)^0 right\n        mathrmdV\nendalign*","category":"page"},{"location":"potentialflow/","page":"Potential Flow","title":"Potential Flow","text":"beginalign*\n    Rightarrow boxed\n        intlimits_partial V\n            left frac1r nabla phi - phinabla left(frac1rright) right cdot hatmathbfn\n        mathrmdS\n    = \n        0\n    \nendalign*","category":"page"},{"location":"potentialflow/","page":"Potential Flow","title":"Potential Flow","text":"The integrand becomes singular when evaluated at mathbfx_p since lim limits_rrightarrow 0 frac1r = infty, which we will use to obtain some expressions depending on whether mathbfx_p lays inside, outside, or at the boundary of V.","category":"page"},{"location":"potentialflow/","page":"Potential Flow","title":"Potential Flow","text":"In the case that mathbfx_p cancelin V, the integral equation is automatically satisfied. In the case that mathbfx_p in V, we introduce a hole in V in the form of a sphere of radius epsilon surrounding mathbfx_p, and the integral equation is then automatically satisfied over the domain V backslash V_epsilon:","category":"page"},{"location":"potentialflow/","page":"Potential Flow","title":"Potential Flow","text":"beginalign*\n    \n        intlimits_partial (V backslash V_epsilon)\n            left frac1r nabla phi - phinabla left(frac1rright) right cdot hatmathbfn\n        mathrmdS\n    = \n        0\n    \n    Leftrightarrow \n        intlimits_partial V\n            left frac1r nabla phi - phinabla left(frac1rright) right cdot hatmathbfn\n        mathrmdS\n        -\n        intlimits_partial V_epsilon\n            left frac1r nabla phi - phinabla left(frac1rright) right cdot hatmathbfn\n        mathrmdS\n    = \n        0\nendalign*","category":"page"},{"location":"potentialflow/","page":"Potential Flow","title":"Potential Flow","text":"Since r is centered at mathbfx_p and the normal hatmathbfn points radially inwards the sphere (since all normals point outside of the volume V), the second integral becomes","category":"page"},{"location":"potentialflow/","page":"Potential Flow","title":"Potential Flow","text":"beginalign*\n        intlimits_partial V_epsilon\n            left frac1r nabla phi - phinabla left(frac1rright) right cdot hatmathbfn\n        mathrmdS\n    = \n        - intlimits_partial V_epsilon\n            left( frac1r fracpartial phipartial r + fracphir^2 right)\n        mathrmdS\nendalign*","category":"page"},{"location":"potentialflow/","page":"Potential Flow","title":"Potential Flow","text":"In the limit that epsilon is infinitesimally small, the integral can be approximated as","category":"page"},{"location":"potentialflow/","page":"Potential Flow","title":"Potential Flow","text":"beginalign*\n        intlimits_partial V_epsilon\n            left( frac1r fracpartial phipartial r - fracphir^2 right)\n        mathrmdS\n    approx\n        - left(\n            fracpartial phipartial r(mathbfx_p) limlimits_rrightarrow 0 frac1r\n            +\n            phi (mathbfx_p) limlimits_rrightarrow 0 frac1r^2\n        right)\n        limlimits_epsilonrightarrow 0 4 pi epsilon^2\nendalign*","category":"page"},{"location":"potentialflow/","page":"Potential Flow","title":"Potential Flow","text":"where 4 pi epsilon^2 is the surface area of the sphere.","category":"page"},{"location":"potentialflow/","page":"Potential Flow","title":"Potential Flow","text":"Assuming phi(mathbfx_p) neq pminfty and fracpartial phipartial r(mathbfx_p) neq pminfty, we have","category":"page"},{"location":"potentialflow/","page":"Potential Flow","title":"Potential Flow","text":"beginalign*\n        intlimits_partial V_epsilon\n            left( frac1r fracpartial phipartial r - fracphir^2 right)\n        mathrmdS\n     approx\n            - 4 pi fracpartial phipartial r(mathbfx_p) cancellimlimits_rhorightarrow 0 fracrho ^2rho^0\n            -\n            4 pi phi(mathbfx_p) cancellimlimits_rhorightarrow 0 fracrho^2rho^2^1\nendalign*","category":"page"},{"location":"potentialflow/","page":"Potential Flow","title":"Potential Flow","text":"Thus,","category":"page"},{"location":"potentialflow/","page":"Potential Flow","title":"Potential Flow","text":"beginalign*\n        intlimits_partial V_epsilon\n            left frac1r nabla phi - phinabla left(frac1rright) right cdot hatmathbfn\n        mathrmdS\n     =\n        4 pi phi(mathbfx_p)\nendalign*","category":"page"},{"location":"potentialflow/","page":"Potential Flow","title":"Potential Flow","text":"Substituting this back into the original equation,","category":"page"},{"location":"potentialflow/","page":"Potential Flow","title":"Potential Flow","text":"beginalign*\n        intlimits_partial V\n            left frac1r nabla phi - phinabla left(frac1rright) right cdot hatmathbfn\n        mathrmdS\n        -\n        4 pi phi(mathbfx_p)\n    = \n        0\nendalign*","category":"page"},{"location":"potentialflow/","page":"Potential Flow","title":"Potential Flow","text":"and since mathbfx_p is any arbitrary point inside V, we conclude","category":"page"},{"location":"potentialflow/","page":"Potential Flow","title":"Potential Flow","text":"beginalign*\n    boxed\n        phi(mathbfx)\n    = \n        frac14 pi \n        intlimits_partial V\n            left frac1r nabla phi - phinabla left(frac1rright) right cdot hatmathbfn\n        mathrmdS\n    \n     quad forall mathbfx in V\nendalign*","category":"page"},{"location":"potentialflow/","page":"Potential Flow","title":"Potential Flow","text":"If mathbfx_p lays in the boundary of V (i.e., mathbfx_p in partial V), we repeat the same derivation except that only half of the sphere V_epsilon is contained in the integration domain, and we conclude","category":"page"},{"location":"potentialflow/","page":"Potential Flow","title":"Potential Flow","text":"beginalign*\n    boxed\n        phi(mathbfx)\n    = \n        frac12 pi \n        intlimits_partial V\n            left frac1r nabla phi - phinabla left(frac1rright) right cdot hatmathbfn\n        mathrmdS\n    \n     quad forall mathbfx in partial V\nendalign*","category":"page"},{"location":"potentialflow/","page":"Potential Flow","title":"Potential Flow","text":"We merge the two equations to get","category":"page"},{"location":"potentialflow/","page":"Potential Flow","title":"Potential Flow","text":"beginalign*\n    therefore\n    boxed\n        phi(mathbfx)\n    = \n        fracf_tiny partial V(mathbfx)pi \n        intlimits_partial V\n            left frac1r nabla phi - phinabla left(frac1rright) right cdot hatmathbfn\n        mathrmdS\n    \n     quad forall mathbfx in V\n     quad textwhere \n    f_tiny partial V(mathbfx) = begincases\n                                          14   mathbfx in V backslash partial V \n                                          12   mathbfx in partial V\n                                        endcases\nendalign*","category":"page"},{"location":"potentialflow/","page":"Potential Flow","title":"Potential Flow","text":"Now, consider the case that V is infinitely large in all directions (with bound partial V_infty) while also having a hole (bound partial V_b, which represents a solid body immersed in the domain), leading to partial V = partial V_b cup partial V_infty. In V, the potential is calculated as","category":"page"},{"location":"potentialflow/","page":"Potential Flow","title":"Potential Flow","text":"beginalign*\n        phi(mathbfx)\n    = \n        fracf_tiny partial V_b(mathbfx)pi \n        intlimits_partial V_b\n            left frac1r nabla phi - phinabla left(frac1rright) right cdot hatmathbfn\n        mathrmdS\n        +\n        underbrace\n            frac14pi \n            intlimits_partial V_infty\n                left frac1r nabla phi - phinabla left(frac1rright) right cdot hatmathbfn\n            mathrmdS\n        _\n        equiv phi_infty(mathbfx)\n        \nendalign*","category":"page"},{"location":"potentialflow/","page":"Potential Flow","title":"Potential Flow","text":"When the isolated body is considered as a volume of its own, V_b, we can define an internal potential (i.e., internal to the body) as phi_i. When mathbfx_p is defined as being outside of V_b (but still inside V), we have","category":"page"},{"location":"potentialflow/","page":"Potential Flow","title":"Potential Flow","text":"beginalign*\n        fracf_tiny partial V_b(mathbfx)pi \n        intlimits_partial V_b\n            left frac1r nabla phi_i - phi_inabla left(frac1rright) right cdot hatmathbfn\n        mathrmdS\n    = \n        0\nendalign*","category":"page"},{"location":"potentialflow/","page":"Potential Flow","title":"Potential Flow","text":"from the Laplace equation.","category":"page"},{"location":"potentialflow/","page":"Potential Flow","title":"Potential Flow","text":"Since the superposition of two solutions to the Laplace equation yields another valid solution, we can add this internal potential to the previous equation to obtain","category":"page"},{"location":"potentialflow/","page":"Potential Flow","title":"Potential Flow","text":"beginalign*\n        phi(mathbfx)\n    = \n        fracf_tiny partial V_b(mathbfx)pi \n        intlimits_partial V_b\n            left\n                frac1r nabla left(phi - phi_iright)\n                -\n                left(phi - phi_iright) nabla left(frac1rright)\n            right cdot hatmathbfn\n        mathrmdS\n        +\n        phi_infty(mathbfx)\nendalign*","category":"page"},{"location":"potentialflow/","page":"Potential Flow","title":"Potential Flow","text":"where the negative sign accompanying phi_i comes from requiring hatmathbfn to point outward from V.","category":"page"},{"location":"potentialflow/","page":"Potential Flow","title":"Potential Flow","text":"This equation poses a boundary integral equation (BIE), with the potential phi being fully determined by its value at the boundaries. We can then define","category":"page"},{"location":"potentialflow/","page":"Potential Flow","title":"Potential Flow","text":"beginalign*\n    \n    boxed-sigma equiv fracpartial phipartial n - fracpartial phi_ipartial n\n     \n    boxed-mu equiv phi - phi_i\nendalign*","category":"page"},{"location":"potentialflow/","page":"Potential Flow","title":"Potential Flow","text":"resulting in the following BIE,","category":"page"},{"location":"potentialflow/","page":"Potential Flow","title":"Potential Flow","text":"beginalign*\n    boxed\n            phi(mathbfx)\n        = \n            -fracf_tiny partial V_b(mathbfx)pi \n            intlimits_partial V_b\n                left\n                    sigma frac1r\n                    -\n                    mu hatmathbfn cdot  nabla left(frac1rright)\n                right  \n            mathrmdS\n            +\n            phi_infty(mathbfx)\n    \n     quad textwhere \n    f_tiny partial V_b(mathbfx) = begincases\n                                          14   mathbfx in V backslash partial V_b \n                                          12   mathbfx in partial V_b\n                                        endcases\nendalign*","category":"page"},{"location":"potentialflow/","page":"Potential Flow","title":"Potential Flow","text":"where mu and sigma are unknowns that we will later determine imposing boundary conditions.","category":"page"},{"location":"elements/semiinfdoublet/#Semi-Infinite-Doublet-(Vortex-Horseshoe)","page":"Semi-Infinite Doublet","title":"Semi-Infinite Doublet (Vortex Horseshoe)","text":"","category":"section"},{"location":"elements/semiinfdoublet/","page":"Semi-Infinite Doublet","title":"Semi-Infinite Doublet","text":"(Adapted fron Moran, J. (1984), An introduction to theoretical and computational aerodynamics, Appendix F, p. 442)","category":"page"},{"location":"elements/semiinfdoublet/","page":"Semi-Infinite Doublet","title":"Semi-Infinite Doublet","text":"Assume a constant-strength doublet panel that starts from mathbfp_a and mathbfp_b and extends infinitely in the x direction laying in the xy-plane, as shown below. Since a finite doublet panel is the same than a vortex ring, the semi-infinite doublet panel corresponds to a horseshoe vortex.","category":"page"},{"location":"elements/semiinfdoublet/","page":"Semi-Infinite Doublet","title":"Semi-Infinite Doublet","text":"<center>\n  <img src=\"../../assets/images/seminfinitevortex00.png\" alt=\"Pic here\" width=\"400px\">\n</center>","category":"page"},{"location":"elements/semiinfdoublet/","page":"Semi-Infinite Doublet","title":"Semi-Infinite Doublet","text":"NOTE: In order to have the normal of the doublet panel pointing in the +z direction while having the horseshoe vortex going in the direction shown above (coming from infty to a, from a to b, and going out from b to infty), we have to define boxedmu = -Gamma.","category":"page"},{"location":"elements/semiinfdoublet/","page":"Semi-Infinite Doublet","title":"Semi-Infinite Doublet","text":"Since the potential of a point doublet corresponds to the negative normal-derivative of the potential of a point source,","category":"page"},{"location":"elements/semiinfdoublet/","page":"Semi-Infinite Doublet","title":"Semi-Infinite Doublet","text":"beginalign*\n        phi_textpoint mu\n    =\n        - mu fracpartialpartial zleft( -frac14pi r right)\n    =\n        -fracmu4pifraczr^3\nendalign*","category":"page"},{"location":"elements/semiinfdoublet/","page":"Semi-Infinite Doublet","title":"Semi-Infinite Doublet","text":"the potential of the semi-infinite constant-strength doublet panel is given by","category":"page"},{"location":"elements/semiinfdoublet/","page":"Semi-Infinite Doublet","title":"Semi-Infinite Doublet","text":"beginalign*\n        phi_mu (x y z)\n    =\n        -fracmu4pi\n        intlimits_y_a^y_b\n            intlimits_x_a^infty\n                fraczleft (x-x)^2 + (y-y)^2 + z^2 right^32\n            mathrmd x\n        mathrmd y\nendalign*","category":"page"},{"location":"elements/semiinfdoublet/","page":"Semi-Infinite Doublet","title":"Semi-Infinite Doublet","text":"According to Moran (p. 445), this integral becomes","category":"page"},{"location":"elements/semiinfdoublet/","page":"Semi-Infinite Doublet","title":"Semi-Infinite Doublet","text":"beginalign*\n        phi_mu (x y z)\n    =\n        -fracmu4pi\n        left left\n            tan^-1left( fracy-yz right)\n            +\n            tan^-1left( frac (y-y)(x-x_a)  z sqrt(x-x_a)^2 + (y-y)^2 + z^2  right)\n        rightrightvert_y_a^y_b\nendalign*","category":"page"},{"location":"elements/semiinfdoublet/","page":"Semi-Infinite Doublet","title":"Semi-Infinite Doublet","text":"NOTE: tan^-1 here is for outputs in the range -fracpi2 to fracpi2.","category":"page"},{"location":"elements/semiinfdoublet/","page":"Semi-Infinite Doublet","title":"Semi-Infinite Doublet","text":"In the derivation above we have assumed that the bound vortex section mathbfp_b - mathbfp_a is perpendicular to the semi-infinite direction hatmathbfd_infty. That is, hatmathbfd_inftycdot(mathbfp_b - mathbfp_a)=0. This is in general not true since mathbfp_b - mathbfp_a typically represents the trailing edge while hatmathbfd_infty is the direction of the freestream.","category":"page"},{"location":"elements/semiinfdoublet/","page":"Semi-Infinite Doublet","title":"Semi-Infinite Doublet","text":"Given two arbitrary nodes mathbfp_i and mathbfp_j along the trailing edge and an arbitrary freestream direction hatmathbfd_infty as shown below (left), we define mathbfp_a as the closest point to mathbfp_j along the incoming semi-infinite vortex, as shown below (right).","category":"page"},{"location":"elements/semiinfdoublet/","page":"Semi-Infinite Doublet","title":"Semi-Infinite Doublet","text":"<center>\n  <table>\n      <tr>\n          <td>\n              <img src=\"../../assets/images/semiinfinite-doublet02.png\" alt=\"Pic here\" width=\"450px\">\n          </td>\n          <td>\n              <img src=\"../../assets/images/semiinfinite-doublet01.png\" alt=\"Pic here\" width=\"450px\">\n          </td>\n      </tr>\n  </table>\n</center>","category":"page"},{"location":"elements/semiinfdoublet/","page":"Semi-Infinite Doublet","title":"Semi-Infinite Doublet","text":"This point is calculated as","category":"page"},{"location":"elements/semiinfdoublet/","page":"Semi-Infinite Doublet","title":"Semi-Infinite Doublet","text":"beginalign*\n        mathbfp_a\n    =\n        mathbfp_i + left (mathbfp_j - mathbfp_i) cdot hatmathbfd_infty right hatmathbfd_infty\nendalign*","category":"page"},{"location":"elements/semiinfdoublet/","page":"Semi-Infinite Doublet","title":"Semi-Infinite Doublet","text":"which defines a bound vortex mathbfp_j - mathbfp_a that is perpendicular to hatmathbfd_infty. This bound vortex is used to define the following local coordinate system","category":"page"},{"location":"elements/semiinfdoublet/","page":"Semi-Infinite Doublet","title":"Semi-Infinite Doublet","text":"beginalign*\n    bullet quad \n        hatmathbfx = hatmathbfd_infty\n    \n    bullet quad \n        hatmathbfy = fracmathbfp_b - mathbfp_aVert mathbfp_b - mathbfp_a Vert\n    \n    bullet quad \n        hatmathbfz = hatmathbfx times hatmathbfy\nendalign*","category":"page"},{"location":"elements/semiinfdoublet/","page":"Semi-Infinite Doublet","title":"Semi-Infinite Doublet","text":"where mathbfp_b = mathbfp_j.","category":"page"},{"location":"elements/semiinfdoublet/","page":"Semi-Infinite Doublet","title":"Semi-Infinite Doublet","text":"The potential induced by this elements is then computed as the superposition of potential of the doublet panel defined by the vertices mathbfp_a, mathbfp_i, and mathbfp_j and the potential induced by the semi-infinite panel starting between mathbfp_a and mathbfp_j.","category":"page"},{"location":"elements/semiinfdoublet/","page":"Semi-Infinite Doublet","title":"Semi-Infinite Doublet","text":"NOTE: The doublet panel is purposely defined in the order mathbfp_a, mathbfp_i, and mathbfp_j as to define its normal through the right-hand rule as hatmathbfn=-hatmathbfz and have the associated vortex ring matching the figure above.","category":"page"},{"location":"elements/semiinfdoublet/","page":"Semi-Infinite Doublet","title":"Semi-Infinite Doublet","text":"The induced velocity is calculated as the velocity induced by a bound vortex between mathbfp_i and mathbfp_j, plus the velocity induced by two semi-infinite vortices coming in and out of mathbfp_i and mathbfp_j, respectively.","category":"page"},{"location":"elements/semiinfdoublet/","page":"Semi-Infinite Doublet","title":"Semi-Infinite Doublet","text":"The velocity of the bound vortex is calculated as","category":"page"},{"location":"elements/semiinfdoublet/","page":"Semi-Infinite Doublet","title":"Semi-Infinite Doublet","text":"beginalign*\n        mathbfu_mathrmij left( mathbfx right)\n    =\n        fracGamma4pi\n            fracmathbfr_i times mathbfr_j Vert mathbfr_i times mathbfr_j Vert^2\n            mathbfr_ij cdot left(\n                fracmathbfr_ir_i - fracmathbfr_jr_j\n            right)\nendalign*","category":"page"},{"location":"elements/semiinfdoublet/","page":"Semi-Infinite Doublet","title":"Semi-Infinite Doublet","text":"where Gamma = mu, mathbfr_ij = mathbfp_j-mathbfp_i, mathbfr_i = mathbfx - mathbfp_i, mathbfr_j = mathbfx - mathbfp_j. The velocity of a semi-infinite vortex is calculated as follows.","category":"page"},{"location":"elements/semiinfdoublet/","page":"Semi-Infinite Doublet","title":"Semi-Infinite Doublet","text":"Assume a semi-infinite vortex starting at mathbfp_0 and extending in the direction hatmathbfd. Given a position mathbfx that is aligned with the starting point mathbfp_0 (by aligned we mean that both mathbfx and mathbfp_0 lay in a plane with normal hatmathbfd), the velocity that the semi-infinite vortex induces at mathbfx is calculated as","category":"page"},{"location":"elements/semiinfdoublet/","page":"Semi-Infinite Doublet","title":"Semi-Infinite Doublet","text":"beginalign*\n    mathbfu_infty2left( mathbfx right) = fracGamma4 pi h hatmathbfn\nendalign*","category":"page"},{"location":"elements/semiinfdoublet/","page":"Semi-Infinite Doublet","title":"Semi-Infinite Doublet","text":"where Gamma is the vortex strength, h = Vert mathbfx - mathbfp_0 Vert the normal distance to the vortex line, hatmathbfn equiv hatmathbfdtimeshatmathbfh is the vector normal to the plane defined by hatmathbfd and hatmathbfh, and hatmathbfh equiv fracmathbfx-mathbfp_0Vert mathbfx-mathbfp_0 Vert. Note that in this definition, a positive Gamma denotes the vortex going out from mathbfp_0 to infty.","category":"page"},{"location":"elements/semiinfdoublet/","page":"Semi-Infinite Doublet","title":"Semi-Infinite Doublet","text":"If mathbfx is not aligned with (\"in the same plane than\") the start of the semi-infinite vortex mathbfp, the semi-infinite vortex is arbitrarely split up such that mathbfp_0 is found by projecting mathbfx into the line vortex as","category":"page"},{"location":"elements/semiinfdoublet/","page":"Semi-Infinite Doublet","title":"Semi-Infinite Doublet","text":"beginalign*\n    mathbfp_0 =  mathbfp + left left( mathbfx - mathbfp right) cdot hatmathbfd right  hatmathbfd\nendalign*","category":"page"},{"location":"elements/semiinfdoublet/","page":"Semi-Infinite Doublet","title":"Semi-Infinite Doublet","text":"where mathbfp was the original starting point. Thus, the semi-infinite vortex is split up into two section: one bound vortex between mathbfp_0 and mathbfp, and a semi-infinite section starting from mathbfp_0 as shown below.","category":"page"},{"location":"elements/semiinfdoublet/","page":"Semi-Infinite Doublet","title":"Semi-Infinite Doublet","text":"<center>\n  <img src=\"../../assets/images/semiinfinite-vortex01.png\" alt=\"Pic here\" style=\"width: 350px;\"/>\n</center>","category":"page"},{"location":"elements/semiinfdoublet/","page":"Semi-Infinite Doublet","title":"Semi-Infinite Doublet","text":"Thus, the velocity is calculated as","category":"page"},{"location":"elements/semiinfdoublet/","page":"Semi-Infinite Doublet","title":"Semi-Infinite Doublet","text":"beginalign*\n    mathbfuleft( mathbfx right)  =\n        mathbfu_mathbfp_0mathbfpleft( mathbfx right) +\n            mathbfu_infty2left( mathbfx right)\nendalign*","category":"page"},{"location":"elements/semiinfdoublet/","page":"Semi-Infinite Doublet","title":"Semi-Infinite Doublet","text":"OBSERVATIONS","category":"page"},{"location":"elements/semiinfdoublet/","page":"Semi-Infinite Doublet","title":"Semi-Infinite Doublet","text":"The velocity induced by both bound and semi-infinite vortices are singular as mathbfx becomes collinear with the vortex. The singularity is avoided by adding a small offset epsilon to h in the semi-infinite vortex and to each denominator in the calculation of the bound vortex.\nSince the velocity induced by a vortex on itself must be zero, we also define a small threshold close to both the bound and semi-infinite vortices at which the velocity induced at mathbfx becomes zero.","category":"page"},{"location":"elements/semiinfdoublet/","page":"Semi-Infinite Doublet","title":"Semi-Infinite Doublet","text":"NOTE: The small offset epsilon corresponds to body.kerneloffset, while the cutoff threshold for self-induced velocity corresponds to body.kernelcutoff.","category":"page"},{"location":"elements/semiinfdoublet/","page":"Semi-Infinite Doublet","title":"Semi-Infinite Doublet","text":"The potential and velocity field of a semi-infinte doublet panel (or vortex horseshoe) of unitary strength (mu=1 or Gamma=1) is shown below","category":"page"},{"location":"elements/semiinfdoublet/","page":"Semi-Infinite Doublet","title":"Semi-Infinite Doublet","text":"<center>\n  <table>\n      <tr>\n          <th>\n              <img src=\"../../assets/images/panel-semiinfinite-doublet-phi01.png\" alt=\"Pic here\" width=\"450px\">\n          </th>\n          <th>\n              <img src=\"../../assets/images/panel-semiinfinite-doublet-u01.png\" alt=\"Pic here\" width=\"450px\">\n          </th>\n      </tr>\n  </table>\n</center>","category":"page"},{"location":"elements/semiinfdoublet/","page":"Semi-Infinite Doublet","title":"Semi-Infinite Doublet","text":"<center>\n  <br>$\\nabla \\phi$ = $\\mathbf{u}$ verification\n  <img src=\"../../assets/images/panel-semiinfinitedoublet-divphivsu00.png\" alt=\"Pic here\" style=\"width: 700px;\"/>\n</center>","category":"page"},{"location":"examples/cessna-aero/","page":"Import Mesh and Solve","title":"Import Mesh and Solve","text":"<center>\n  <img src=\"https://edoalvar2.groups.et.byu.net/public/FLOWPanel/cessna000.jpg\" alt=\"Pic here\" style=\"width: 100%;\"/>\n</center>","category":"page"},{"location":"examples/cessna-aero/#Import-Mesh-and-Solve","page":"Import Mesh and Solve","title":"Import Mesh and Solve","text":"","category":"section"},{"location":"examples/cessna-aero/","page":"Import Mesh and Solve","title":"Import Mesh and Solve","text":"Here we import the mesh into FLOWPanel using Meshes.jl, identify the trailing edge, and run the watertight solver.","category":"page"},{"location":"examples/cessna-aero/","page":"Import Mesh and Solve","title":"Import Mesh and Solve","text":"info: Default OpenVSP files\nWe have pre-generated and uploaded an OpenVSP mesh to this example so that you can run this section without needing to complete the previous sections. However, if you would like to use your own mesh, simply change read_path, meshfile, and trailingedges to point to your files.","category":"page"},{"location":"examples/cessna-aero/","page":"Import Mesh and Solve","title":"Import Mesh and Solve","text":"#=##############################################################################\n# DESCRIPTION\n    Cessna 210 aircraft. The mesh used in this analysis was created using\n    OpenVSP.\n\n# AUTHORSHIP\n  * Author    : Eduardo J. Alvarez\n  * Email     : Edo.AlvarezR@gmail.com\n  * Created   : Apri 2024\n  * License   : MIT License\n=###############################################################################\n\nimport FLOWPanel as pnl\nimport FLOWPanel: norm, dot, cross\n\nimport Meshes\nimport GeoIO\nimport Rotations: RotX, RotY, RotZ\n\n# import CUDA                               # Uncomment this to use GPU (if available)\n\n\nrun_name        = \"cessna\"                  # Name of this run\n\nsave_path       = run_name                  # Where to save outputs\nparaview        = true                      # Whether to visualize with Paraview\nread_path       = joinpath(pnl.examples_path, \"data\") # Where to read Gmsh files from\n\n# ----------------- SIMULATION PARAMETERS --------------------------------------\nAOA             = 4.0                       # (deg) freestream angle of attack\nmagVinf         = 180 * 0.514444            # (m/s) freestream velocity\nrho             = 0.71461                   # (kg/m^3) air density at 17300 ft\n\n\n# ----------------- GEOMETRY DESCRIPTION ---------------------------------------\nmeshfile        = joinpath(read_path, \"cessna.msh\")    # Gmsh file to read\n\noffset          = [0, 0, 0]                 # Offset to center the mesh\nrotation        = RotX(0*pi/180) * RotY(0*pi/180) * RotX(0*pi/180) # Rotation to align mesh\nscaling         = 0.3048                    # Factor to scale mesh dimensions (ft -> m)\n\n                                            # Gmsh files with trailing edges\ntrailingedges   = [ #   ( Gmsh file,                 span direction )\n                        (\"cessna-TE-leftwing.msh\",      [0, 1, 0]),\n                        (\"cessna-TE-rightwing.msh\",     [0, 1, 0]),\n                        (\"cessna-TE-leftelevator.msh\",  [0, 1, 0]),\n                        (\"cessna-TE-rightelevator.msh\", [0, 1, 0]),\n                        (\"cessna-TE-rudder.msh\",        [0, 0, 1]),\n                    ]\n\nflip            = true                      # Whether to flip control points against the direction of normals\n                                            # NOTE: use `flip=true` if the normals\n                                            #       point inside the body\n\nbref            = 11.2014                   # (m) reference span\ncref            = 1.449324                  # (m) reference chord\nSref            = 16.2344                   # (m^2) reference area\nXac             = [2.815, 0, 0.4142]        # (m) aerodynamic center for\n                                            # calculation of moments\n\n# ----------------- SOLVER SETTINGS -------------------------------------------\n\n# Solver: direct linear solver for open bodies\n# bodytype = pnl.RigidWakeBody{pnl.VortexRing} # Wake model and element type\n\n# Solver: least-squares solver for watertight bodies\nbodytype        = pnl.RigidWakeBody{pnl.VortexRing, 2}\n\n\n# ----------------- GENERATE BODY ----------------------------------------------\n# Read Gmsh mesh\nmsh = GeoIO.load(meshfile)\nmsh = msh.geometry\n\n# Transform the original mesh: Translate, rotate, and scale\nmsh = msh |> Meshes.Translate(offset...) |> Meshes.Rotate(rotation) |> Meshes.Scale(scaling)\n\n# Wrap Meshes object into a Grid object from GeometricTools\ngrid = pnl.gt.GridTriangleSurface(msh)\n\n# Read all trailing edges\nsheddings = []\n\nfor (trailingedgefile, spandir) in trailingedges\n\n    # Read Gmsh line of trailing edge\n    TEmsh = GeoIO.load(joinpath(read_path, trailingedgefile))\n    TEmsh = TEmsh.geometry\n\n    # Apply the same transformations of the mesh to the trailing edge\n    TEmsh = TEmsh |> Meshes.Translate(offset...) |> Meshes.Rotate(rotation) |> Meshes.Scale(scaling)\n\n    # Convert TE Meshes object into a matrix of points used to identify the trailing edge\n    trailingedge = pnl.gt.vertices2nodes(TEmsh.vertices)\n\n    # Sort TE points from \"left\" to \"right\" according to span direction\n    trailingedge = sortslices(trailingedge; dims=2, by = X -> pnl.dot(X, spandir))\n\n    # Function for identifying if a point is close to a junction\n    if trailingedgefile in [\"cessna-TE-leftwing.msh\", \"cessna-TE-rightwing.msh\"]\n\n        criterion = X -> abs(X[2]) <= 0.67\n\n    elseif trailingedgefile in [\"cessna-TE-leftelevator.msh\", \"cessna-TE-rightelevator.msh\"]\n\n        criterion = X -> abs(X[2]) <= 0.23\n\n    elseif trailingedgefile in [\"cessna-TE-rudder.msh\"]\n\n        criterion = X -> X[3] <= 0.65\n\n    else\n\n        criterion = X -> false\n\n    end\n\n    # Filter out any points that are close to junctions\n    tokeep = filter( i -> !criterion(trailingedge[:, i]), 1:size(trailingedge, 2) )\n    trailingedge = trailingedge[:, tokeep]\n\n    # Generate TE shedding matrix\n    shedding = pnl.calc_shedding(grid, trailingedge; tolerance=0.001*bref)\n\n    push!(sheddings, shedding)\n\nend\n\n# Combine all TE shedding matrices into one\nshedding = hcat(sheddings...)\n\n# Generate paneled body\nbody = bodytype(grid, shedding; CPoffset=(-1)^flip * 1e-14)\n\nprintln(\"Number of panels:\\t$(body.ncells)\")\n\n\n# ----------------- CALL SOLVER ------------------------------------------------\nprintln(\"Solving body...\")\n\n# Freestream vector\nVinf = magVinf*[cos(AOA*pi/180), 0, sin(AOA*pi/180)]\n\n# Freestream at every control point\nUinfs = repeat(Vinf, 1, body.ncells)\n\n# Unitary direction of semi-infinite vortex at points `a` and `b` of each\n# trailing edge panel\nDas = repeat(Vinf/magVinf, 1, body.nsheddings)\nDbs = repeat(Vinf/magVinf, 1, body.nsheddings)\n\n# Solve body (panel strengths) giving `Uinfs` as boundary conditions and\n# `Das` and `Dbs` as trailing edge rigid wake direction\n@time pnl.solve(body, Uinfs, Das, Dbs)\n\n# Uncomment this to use GPU instead (if available)\n# @time pnl.solve(body, Uinfs, Das, Dbs; GPUArray=CUDA.CuArray{Float32})\n\n# ----------------- POST PROCESSING ----------------------------------------\nprintln(\"Post processing...\")\n\n# Calculate surface velocity U on the body\nUs = pnl.calcfield_U(body, body)\n\n# NOTE: Since the boundary integral equation of the potential flow has a\n#       discontinuity at the boundary, we need to add the gradient of the\n#       doublet strength to get an accurate surface velocity\n\n# Calculate surface velocity U_∇μ due to the gradient of the doublet strength\nUDeltaGamma = pnl.calcfield_Ugradmu(body)\n# UDeltaGamma = pnl.calcfield_Ugradmu(body; sharpTE=true, force_cellTE=false)\n\n# Save this intermediate result in a separate field for debugging\npnl.add_field(body, \"Uinfind\", \"vector\", collect.(eachcol(Us)), \"cell\")\n\n# Add both velocities together\npnl.addfields(body, \"Ugradmu\", \"U\")\n\n# Calculate pressure coefficient (based on U + U_∇μ)\n@time Cps = pnl.calcfield_Cp(body, magVinf)\n\n# Calculate the force of each panel (based on Cp)\n@time Fs = pnl.calcfield_F(body, magVinf, rho)\n\n# Calculate total force of the vehicle decomposed as lift, drag, and sideslip\nDhat = Vinf/norm(Vinf)                      # Drag direction\nShat = [0, 1, 0]                            # Span direction\nLhat = cross(Dhat, Shat)                    # Lift direction\n\nLDS = pnl.calcfield_LDS(body, Lhat, Dhat)\nL, D, S = collect(eachcol(LDS))\n\n# Force coefficients\nnondim = 0.5*rho*magVinf^2*Sref             # Normalization factor\nCL = sign(dot(L, Lhat)) * norm(L) / nondim\nCD = sign(dot(D, Dhat)) * norm(D) / nondim\n\n# Integrated moment decomposed into rolling, pitching, and yawing moments\nlhat = Dhat                                 # Rolling direction\nmhat = Shat                                 # Pitching direction\nnhat = Lhat                                 # Yawing direction\n\nlmn = pnl.calcfield_lmn(body, Xac, lhat, mhat, nhat)\nroll, pitch, yaw = collect(eachcol(lmn))\n\n# Moment coefficients\nnondim = 0.5*rho*magVinf^2*Sref*cref # Normalization factor\n\nCl = sign(dot(roll, lhat)) * norm(roll) / nondim\nCm = sign(dot(pitch, mhat)) * norm(pitch) / nondim\nCn = sign(dot(yaw, nhat)) * norm(yaw) / nondim\n\n@show L\n@show D\n@show CL\n@show CD\n@show Cl\n@show Cm\n@show Cn\n\n# ----------------- VISUALIZATION ------------------------------------------\n\n# Save body as VTK\nvtks = save_path*\"/\"                        # String with VTK output files\nvtks *= pnl.save(body, run_name; path=save_path, debug=false)\n\n# NOTE: using `debug=true` outputs the control points and normal, but it takes\n#       much longer since it also calculates the velocity at those points\n\n# Call Paraview\nif paraview\n    run(`paraview --data=$(vtks)`)\nend","category":"page"},{"location":"examples/cessna-aero/","page":"Import Mesh and Solve","title":"Import Mesh and Solve","text":"<span style=\"font-size: 0.9em; color:gray;\"><i>\n    Number of panels: 24,000. <br>\n    Run time: ~100 seconds on a Dell Precision 7760 laptop (no GPU). <br>\n</i></span>\n<br><br>","category":"page"},{"location":"examples/cessna-aero/","page":"Import Mesh and Solve","title":"Import Mesh and Solve","text":" VSPAERO FLOWPanel\nLift C_L 0.499 0.554\nDrag C_D 0.0397 0.0496","category":"page"},{"location":"examples/cessna-aero/","page":"Import Mesh and Solve","title":"Import Mesh and Solve","text":"<center>\n  <img src=\"https://edoalvar2.groups.et.byu.net/public/FLOWPanel/cessna002.jpg\" alt=\"Pic here\" style=\"width: 100%;\"/>\n  <img src=\"https://edoalvar2.groups.et.byu.net/public/FLOWPanel/cessna005.jpg\" alt=\"Pic here\" style=\"width: 100%;\"/>\n</center>\n<br><br>\n<br><br>","category":"page"},{"location":"examples/cessna-aero/","page":"Import Mesh and Solve","title":"Import Mesh and Solve","text":"details: Tip\nYou can also automatically run this example with the following command:import FLOWPanel as pnl\n\ninclude(joinpath(pnl.examples_path, \"cessna.jl\"))","category":"page"},{"location":"examples/cessna-aero/","page":"Import Mesh and Solve","title":"Import Mesh and Solve","text":"details: Checklist for importing meshes\nCheck whether normals point into the body: Using the flag  debug=true in pnl.save(body, run_name; path=save_path, debug=true)  will output the control points of the body along with the associated  normal vector of each panel.      We recommend opening the body and control points in ParaView and  visualizing the normals with the Glyph filter.      Whenever the normals are pointing into the body, the user needs  to flip the offset of the  control points with CPoffset=-1e-14 or any other negligibly small  negative number. This won't flip the normals outwards, but it will flip  the zero-potential domain from outwards back to inside the body  (achieved by shifting the control points slightly into the body).  If you pull up the solution in ParaView and realize that the surface  velocity is much smaller than the freestream everywhere along the  aircraft, that's an indication that the normals are point inwards  and you need to set CPoffset to be negative.\nCheck that the trailing edge was correctly identified:  pnl.save(body, run_name; path=save_path) automatically outputes the  wake.      We recommend opening the body and wake in ParaView and visually  inspecting that the wake runs along the trailing edge line that you  defined under trailingedge.      If not successful, increase the resolution of trailingedge and tighten  the tolerance to something small like  pnl.calc_shedding(grid, trailingedge; tolerance=0.0001*span).\nChoose the right solver for the geometry:  Use the least-squares solver with watertight bodies  (bodytype = pnl.RigidWakeBody{pnl.VortexRing, 2}), and the direct  linear solver with open bodies  (bodytype = pnl.RigidWakeBody{pnl.VortexRing}). The least-squares  solver runs much faster in GPU  (pnl.solve(body, Uinfs, Das, Dbs; GPUArray=CUDA.CuArray{Float32})),  but it comes at the price of sacrificing accuracy (single precision  numbers as opposed to double).","category":"page"},{"location":"examples/cessna-aero/","page":"Import Mesh and Solve","title":"Import Mesh and Solve","text":"tip: Visualization\nTo help you practice in ParaView, we have uploaded the solution files of this simulation along with the ParaView state file (.pvsm) that we used to generate the visualizations shown above: DOWNLOADTo open in ParaView: File → Load State → cessna.pvsm then select \"Search files under specified directory\" and point it to the folder with the outputs of FLOWPanel.","category":"page"},{"location":"examples/duct-leastquares/#Least-Squares-Solver","page":"Least-Squares Solver","title":"Least-Squares Solver","text":"","category":"section"},{"location":"examples/duct-leastquares/","page":"Least-Squares Solver","title":"Least-Squares Solver","text":"It is well known that a purely doublet (or vortex ring) solver encounters difficulties when the geometry is closed (i.e., watertight). The flow field around a body is given by the vortex filaments that make the edges of the panel, and the strength of each filament is simply the difference between adjacent panels. Thus, in the absence of an open edge (like in a watertight geometry), the strengths of the vortex-ring elements become irrelevant, and the problem is purely determined by the difference in strength between adjacent panels. This leads to an overdetermined problem where one of the original degrees of freedom (panels strengths) has become redundant.","category":"page"},{"location":"examples/duct-leastquares/","page":"Least-Squares Solver","title":"Least-Squares Solver","text":"Let n the number of panels. The problem is well defined for an open geometry formulating the solver as","category":"page"},{"location":"examples/duct-leastquares/","page":"Least-Squares Solver","title":"Least-Squares Solver","text":"beginalign*\n    G Gamma = -b\nendalign*","category":"page"},{"location":"examples/duct-leastquares/","page":"Least-Squares Solver","title":"Least-Squares Solver","text":"where b in mathbbR^n is the normal component of the freestream velocity at each panel, which needs to be canceled (\"no-flow-through\" boundary condition), G in mathbbR^ntimes n contains the geometric information of the panels and Gamma in mathbbR^n is the strength of each vortex-ring panel. However, for a watertight geometry, G is no longer full rank and the problem becomes ill-conditioned. Due to numerical roundoff, the system of equations can still be inverted but the numerical solution ends up giving panel strengths (vortex-ring circulations) that are in the order of 10^16 and large numerical noise.","category":"page"},{"location":"examples/duct-leastquares/","page":"Least-Squares Solver","title":"Least-Squares Solver","text":"In order to circumvent this issue, we can transform the original problem into a least-squares problem as follows. Since one of the panel strengths is redundant in a watertight geometry, we can simply pick an arbitrary panel and prescribe its strength. Then, G has become a ntimes (n-1) matrix, Gamma is a vector of length n-1, while b is still a vector of length n. To formulate the least-squares problem, we substract the velocity b_p induced by the \"prescribed\" panel  to the right-hand side,","category":"page"},{"location":"examples/duct-leastquares/","page":"Least-Squares Solver","title":"Least-Squares Solver","text":"beginalign*\n    G Gamma = -b - b_p\nendalign*","category":"page"},{"location":"examples/duct-leastquares/","page":"Least-Squares Solver","title":"Least-Squares Solver","text":"and we solve the problem as","category":"page"},{"location":"examples/duct-leastquares/","page":"Least-Squares Solver","title":"Least-Squares Solver","text":"beginalign*\n    Gamma = - left( G^t G right)^-1 G^t left( b + b_p right)\nendalign*","category":"page"},{"location":"examples/duct-leastquares/","page":"Least-Squares Solver","title":"Least-Squares Solver","text":"where the superscript t denotes the transposed matrix.","category":"page"},{"location":"examples/duct-leastquares/","page":"Least-Squares Solver","title":"Least-Squares Solver","text":"Either solver (i.e., the original vortex-ring solver or the vortex-ring least-squares one) is automatically called whenever the function FLOWPanel.solve(body, Uinfs, Das, Dbs) is called. The solver to be used is identified based on the body type. A body type bodytype = pnl.RigidWakeBody{pnl.VortexRing} corresponds to the original vortex-ring solver, while the least-squares solver is called by declaring bodytype = pnl.RigidWakeBody{pnl.VortexRing, 2}.","category":"page"},{"location":"examples/duct-leastquares/","page":"Least-Squares Solver","title":"Least-Squares Solver","text":"NOTE: The prescribed panel can be manually set by the user through the optional argument elprescribe = [(index, val), ...] of FLOWPanel.solve, which is a list of elements to prescribe, where index is the linear index of the element and val is the prescribed element strength. If not set, the function defaults to FLOWPanel.solve(body, Uinfs, Das, Dbs; elprescribe=[(1, 0)])","category":"page"},{"location":"examples/duct-leastquares/","page":"Least-Squares Solver","title":"Least-Squares Solver","text":"Even though both solvers lead to roughly the same flow field solution, the numerical noise of the ill-condition problem is evident when visualizing the potential field:","category":"page"},{"location":"examples/duct-leastquares/","page":"Least-Squares Solver","title":"Least-Squares Solver","text":"<center>\n    <br><b>Vortex-Ring Solver</b><br>\n    <img src=\"../../assets/images/duct-hill0110-viz-phi00.png\" alt=\"Pic here\" style=\"width:70%;\"/>\n</center>\n<br>\n<center>\n    <br><b>Vortex-Ring Least-Squares Solver</b><br>\n    <img src=\"../../assets/images/duct-hill0111-viz-phi00.png\" alt=\"Pic here\" style=\"width:70%;\"/>\n</center>","category":"page"},{"location":"geometry/basics-loopedgrid/#Looped-Grid","page":"Looped Grid","title":"Looped Grid","text":"","category":"section"},{"location":"geometry/basics-loopedgrid/","page":"Looped Grid","title":"Looped Grid","text":"For some applications it is convenient to define a grid that loops on itself, making the last cell in a dimension close back with the first cell. The Grid object accepts an optional argument indicating the dimension that loops on itself as follows:","category":"page"},{"location":"geometry/basics-loopedgrid/","page":"Looped Grid","title":"Looped Grid","text":"Grid(P_min, P_max, NDIVS, loop_dim)","category":"page"},{"location":"geometry/basics-loopedgrid/","page":"Looped Grid","title":"Looped Grid","text":"where loop_dim is an integer indicating the dimension to loop.","category":"page"},{"location":"geometry/basics-loopedgrid/","page":"Looped Grid","title":"Looped Grid","text":"Here is an example of a cylindrical grid (r theta) where the nodes at theta=0^circ and theta=360^circ end up overlapping (notice nodes 1, 2, and 3 overlapping with 16, 17, and 18).","category":"page"},{"location":"geometry/basics-loopedgrid/","page":"Looped Grid","title":"Looped Grid","text":"import GeometricTools as gt\n\nR = 1.0                   # Radius of circle\n\nP_min = [R/4, 0*pi/180]   # Lower boundaries r, theta\nP_max = [R, 360*pi/180]   # Upper boundaries r, theta\n\nNDIVS = [2, 5]          # 15 radius divisions, 60 angle divisions\n\n# Generates the grid as cartesian\ngrid = gt.Grid(P_min, P_max, NDIVS)\n\n# Converts to cylindrical\ngt.transform!(grid, gt.cylindrical2D)\n\ngt.plot(grid; labelnodes=true, labelcells=!true, labelndivs=!true, fontsize=8)","category":"page"},{"location":"geometry/basics-loopedgrid/","page":"Looped Grid","title":"Looped Grid","text":"<img src=\"../../assets/images/geometry-loopedgrid00.png\" alt=\"Pic here\" style=\"width: 600px;\"/>\n<br><br><br><br>","category":"page"},{"location":"geometry/basics-loopedgrid/","page":"Looped Grid","title":"Looped Grid","text":"Using loop_dim=2, now the theta-coordinate loops on itself, merging the nodes that were overlapping:","category":"page"},{"location":"geometry/basics-loopedgrid/","page":"Looped Grid","title":"Looped Grid","text":"loop_dim = 2              # Loop the theta dimension\n\n# Generates the grid as cartesian\ngrid = gt.Grid(P_min, P_max, NDIVS, loop_dim)\n\n# Converts to cylindrical\ngt.transform!(grid, gt.cylindrical2D)\n\ngt.plot(grid; labelnodes=true, labelcells=!true, labelndivs=!true, fontsize=8)","category":"page"},{"location":"geometry/basics-loopedgrid/","page":"Looped Grid","title":"Looped Grid","text":"<img src=\"../../assets/images/geometry-loopedgrid01.png\" alt=\"Pic here\" style=\"width: 600px;\"/>","category":"page"},{"location":"geometry/basics-loopedgrid/#Example-—-Airfoil-Contour","page":"Looped Grid","title":"Example — Airfoil Contour","text":"","category":"section"},{"location":"geometry/basics-loopedgrid/","page":"Looped Grid","title":"Looped Grid","text":"We will now both a space transformation and a looped grid to generate a two-dimensional airfoil section. The airfoil section is generated through the following procedure:","category":"page"},{"location":"geometry/basics-loopedgrid/","page":"Looped Grid","title":"Looped Grid","text":"Read a collection of points from a CSV file describing an airfoil contour (\"Original Airfoil Geometry\").\nSplit the contour into upper and lower surfaces.\nSpline through the points generating two analytic curve parameterized from inputs 0 to 1.\nGenerate a 1D line that represents a structured grid (\"Original Grid\").\nApply a space transformation to the 1D line to curve it into the shape of the airfoil contours (\"Transformed Grid\").","category":"page"},{"location":"geometry/basics-loopedgrid/","page":"Looped Grid","title":"Looped Grid","text":"import FLOWPanel as pnl\nimport GeometricTools as gt\n                                # Airfoil data path\nairfoil_path = joinpath(pnl.def_data_path, \"airfoils\");\n\n# ----------------- READ AND PARAMETERIZE AIRFOIL -----------------------------\n# Read airfoil contour\nx,y = gt.readcontour(joinpath(airfoil_path, \"S809.txt\"); header_len=2)\n\ngt.plot_airfoil(x,y; style=\"--.k\", title_str=\"Original Airfoil Geometry\")","category":"page"},{"location":"geometry/basics-loopedgrid/","page":"Looped Grid","title":"Looped Grid","text":"<img src=\"../../assets/images/geometry-loopedgrid-airfoil00.png\" alt=\"Pic here\" style=\"width: 900px;\"/>\n<br><br><br><br>","category":"page"},{"location":"geometry/basics-loopedgrid/","page":"Looped Grid","title":"Looped Grid","text":"# Separate upper and lower surfaces to make the contour injective in x\nupper, lower = gt.splitcontour(x,y)\n\n# Parameterize both surfaces independently\nfun_upper = gt.parameterize(upper[1], upper[2], zeros(size(upper[1])); inj_var=1, s=1e-6)\nfun_lower = gt.parameterize(lower[1], lower[2], zeros(size(lower[1])); inj_var=1, s=1e-6)\n\n\n# ----------------- CREATE GRID OF AIRFOIL CONTOUR ----------------------------\n# Create the grid as a quasi-1D line\n#   `X[1]` is the arc-length around the airfoil contour (between 0 and 1),\n#   `X[2]` is a dummy value.\n\nP_min = [0, 0]             # Lower boundaries of arclength and dummy\nP_max = [1, 0]             # Upper boundaries of arclength and dummy\nNDIVS = [10, 0]            # 100 arclength divisions, 0 dummys  divisions\nloop_dim = 1               # Loop the arclength dimension\n\ngrid = gt.Grid(P_min, P_max, NDIVS, loop_dim)\n\ngt.plot(grid; labelnodes=true, labelcells=true, labelndivs=!true,\n                fontsize=8, fig_name=\"org\", title_str=\"Original Grid\")","category":"page"},{"location":"geometry/basics-loopedgrid/","page":"Looped Grid","title":"Looped Grid","text":"<img src=\"../../assets/images/geometry-loopedgrid-airfoil01.png\" alt=\"Pic here\" style=\"width: 600px;\"/>\n<br><br><br><br>","category":"page"},{"location":"geometry/basics-loopedgrid/","page":"Looped Grid","title":"Looped Grid","text":"# Create space transformation function\nfunction my_space_transform(X)\n    if X[1]<0.5\n        return fun_upper(1-2*X[1])[1:2]\n    else\n        return fun_lower(2*(X[1]-0.5))[1:2]\n    end\nend\n\n# Transforms the quasi-1D line into the 2D airfoil contour\ngt.transform!(grid, my_space_transform)\n\ngt.plot(grid; labelnodes=true, labelcells=true, labelndivs=!true,\n                fontsize=8, title_str=\"Transformed grid\");","category":"page"},{"location":"geometry/basics-loopedgrid/","page":"Looped Grid","title":"Looped Grid","text":"<img src=\"../../assets/images/geometry-loopedgrid-airfoil02.png\" alt=\"Pic here\" style=\"width: 600px;\"/>","category":"page"},{"location":"geometry/basics-loopedgrid/","page":"Looped Grid","title":"Looped Grid","text":"Green = Cell index\nBlack = Node index","category":"page"},{"location":"geometry/gridgeneration-transf/#Space-Transformation-Method","page":"Space Transformation Method","title":"Space Transformation Method","text":"","category":"section"},{"location":"geometry/gridgeneration-transf/","page":"Space Transformation Method","title":"Space Transformation Method","text":"Complex geometries can be defined manually by applying a predefined or user-defined space transformation on a Grid object.","category":"page"},{"location":"geometry/gridgeneration-transf/","page":"Space Transformation Method","title":"Space Transformation Method","text":"FLOWPanel.GeometricTools.transform!","category":"page"},{"location":"geometry/gridgeneration-transf/","page":"Space Transformation Method","title":"Space Transformation Method","text":"The following predefined nonlinear orthogonal space transformations are implemented in GeometricTools:","category":"page"},{"location":"geometry/gridgeneration-transf/","page":"Space Transformation Method","title":"Space Transformation Method","text":"cylindrical3D(X)\ncylindrical2D(X)\nspherical3D(X)\nparabolic3D(X)\nparaboloidal3D(X)\nelliptic3D(X; a=1)\nprolate3D(X; a=1)\noblate3D(X; a=1)\nbipolar3D(X; a=1)\ntoroidal3D(X; a=1)\nconical3D(X; b=2, c=1).","category":"page"},{"location":"geometry/gridgeneration-transf/#Example-—-Sphere,-predefined-transformation","page":"Space Transformation Method","title":"Example — Sphere, predefined transformation","text":"","category":"section"},{"location":"geometry/gridgeneration-transf/","page":"Space Transformation Method","title":"Space Transformation Method","text":"import FLOWPanel as pnl\n\nfile_name = \"sphere00\"\nsave_path = \"./\"\n\n# Parameters\nR = 1.0                          # (m) radius of sphere\nP_min = [0, 0, 0]                # Lower bounds of (theta, phi, dummy)\nP_max = [pi, 2*pi, 0]            # Upper bounds of (theta, phi, dummy)\nNDIVS = [25, 50, 0]              # Number of divisions (cells) of (theta, phi, dummy)\nloop_dim = 2                     # Coordinate to loop (1==theta)\n\n# Generates parametric (theta, phi) grid\ngrid = pnl.gt.Grid(P_min, P_max, NDIVS, loop_dim)\n\n# Transforms the grid into a spherical cartesian space\nmy_transform(X) = pnl.gt.spherical3D(vcat(R, X[1:2]))\npnl.gt.transform!(grid, my_transform)\n\n# Splits the quad cells into triangular cells\ndimsplit = 1\ntriang_grid = pnl.gt.GridTriangleSurface(grid, dimsplit)\n\n\n# Save vtk and call paraview\npnl.gt.save(triang_grid, file_name; path=save_path, format=\"vtk\")\n\nrun(`paraview --data=$(joinpath(save_path, file_name)).vtk`)","category":"page"},{"location":"geometry/gridgeneration-transf/","page":"Space Transformation Method","title":"Space Transformation Method","text":"<img src=\"http://edoalvar2.groups.et.byu.net/public/FLOWPanel/sphere00.gif\" alt=\"Vid here\" style=\"width: 900px;\"/>","category":"page"},{"location":"geometry/gridgeneration-transf/#Example-—-Box,-user-defined-transformation","page":"Space Transformation Method","title":"Example — Box, user-defined transformation","text":"","category":"section"},{"location":"geometry/gridgeneration-transf/","page":"Space Transformation Method","title":"Space Transformation Method","text":"import FLOWPanel as pnl\n\nfile_name = \"box00\"\nsave_path = \"./\"\n\n# Parameters\nL = 1.0                          # (m) side's length\nP_min = [-0.95, 0, 0]            # Lower bounds of (x, y, dummy)\nP_max = [.95, 4.0, 0]            # Upper bounds of (x, y, dummy)\n# NDIVS = [24, 20, 0]            # Number of divisions (cells) of (x, y, dummy)\nN = 3\nNDIVS = [\n            [(0.45, 3*N, 1/2, false),\n                (1.0, 6*N, 2.0, true),\n                (0.45, 3*N, 2.0, false)],\n            [(0.25, 6*N, 2.0, true) for i in 1:4],\n            [(1.0, 0, 0.0, false)]\n        ]\nloop_dim = 2                     # Coordinate to loop (2==y)\n\n# Generates parametric (theta, phi) grid\ngrid = pnl.gt.Grid(P_min, P_max, NDIVS, loop_dim)\n\n# Axis on every face\nOaxis = [pnl.gt.rotation_matrix2(-a, 0, 0) for a in [90, 0, -90, -180]]\n\n# Center of every face\nO = L*[zeros(3), [0, 0, 1.0], [0, 1, 1.0], [0, 1, 0.0]]\n\n# Axis of side sections\nOaxis_sec = [pnl.gt.rotation_matrix2(angles...)*Oaxis[i]\n                for (i, angles) in enumerate([(0,-90,0), (0,-90,0), (0,-90,0), (0,-90,0)])]\n\n# Center of side sections\nO_sec = [O[i]+L/2*Oaxis[i][2,:] for i in 1:4]\n\n# Transformation function\nfunction my_transform(X)\n\n    # Identifies the face\n    face = Int(floor(X[2]+1))\n\n    if face<=0 || face>4\n        error(\"Logic error! Invalid face $face\")\n    end\n\n    # Identifies the side (-1->left, 0->center, 1->right)\n    side = sign(X[1])*(abs(X[1])>0.5)\n\n    if side==0\n        return pnl.gt.countertransform(L*[X[1], X[2]-(face-1), 0], inv(Oaxis[face]), O[face])\n    else\n        mod_X = [abs(X[1])-0.5, X[2]-(face-1)-0.5, 0]\n        mod_X[2] *= 1 - mod_X[1]/0.5\n        return pnl.gt.countertransform(L*[mod_X[1], side*mod_X[2], 0],\n                                        inv([1 0 0; 0 side 0; 0 0 side]*Oaxis_sec[face]),\n                                        O_sec[face] + L/2*[side, 0, 0])\n    end\nend\n\n# Converts the parametric grid into a box\npnl.gt.transform!(grid, my_transform)\n\n# Splits the quad cells into triangular cells\ndimsplit = 1\ntriang_grid = pnl.gt.GridTriangleSurface(grid, dimsplit)\n\n# Save vtk and call paraview\npnl.gt.save(triang_grid, file_name; path=save_path, format=\"vtk\")\n\nrun(`paraview --data=$(joinpath(save_path, file_name)).vtk`)","category":"page"},{"location":"geometry/gridgeneration-transf/","page":"Space Transformation Method","title":"Space Transformation Method","text":"<img src=\"http://edoalvar2.groups.et.byu.net/public/FLOWPanel/box00.gif\" alt=\"Vid here\" style=\"width: 900px;\"/>","category":"page"},{"location":"examples/sweptwing-solver/#Solver-Benchmark","page":"Solver Benchmark","title":"Solver Benchmark","text":"","category":"section"},{"location":"examples/sweptwing-solver/","page":"Solver Benchmark","title":"Solver Benchmark","text":"The problem of solving the panel strengths that satisfy the no-flow-through condition poses a linear system of equation of the form","category":"page"},{"location":"examples/sweptwing-solver/","page":"Solver Benchmark","title":"Solver Benchmark","text":"beginalign*\n        A y = b\nendalign*","category":"page"},{"location":"examples/sweptwing-solver/","page":"Solver Benchmark","title":"Solver Benchmark","text":"where A is the matrix containing the geometry of the panels and wake, y is the vector of panel strengths, and b is the vector of boundary conditions. This is trivially solved as","category":"page"},{"location":"examples/sweptwing-solver/","page":"Solver Benchmark","title":"Solver Benchmark","text":"beginalign*\n        y = A^-1b\nendalign*","category":"page"},{"location":"examples/sweptwing-solver/","page":"Solver Benchmark","title":"Solver Benchmark","text":"however, depending on the size of A (which depends on the number of panels) it can become inefficient or even unfeasible to explicitely calculate the inverse of A. Multiple linear solvers are available in FLOWPanel that avoid explicitely inverting A, which are described and benchmarked as follows.","category":"page"},{"location":"examples/sweptwing-solver/","page":"Solver Benchmark","title":"Solver Benchmark","text":"The complete code is available at examples/sweptwing_solverbenchmark.jl but you should also be able to copy and paste these lines after running the first section of this example.","category":"page"},{"location":"examples/sweptwing-solver/#Backslash-operator-\\","page":"Solver Benchmark","title":"Backslash operator \\","text":"","category":"section"},{"location":"examples/sweptwing-solver/","page":"Solver Benchmark","title":"Solver Benchmark","text":"Most programming languages implement an operator \\ that directly calculates the matrix-vector product A^-1b. This is more efficient than directly inverting A and then multiplying by b, without loosing any accuracy. This linear solver is available under this function:","category":"page"},{"location":"examples/sweptwing-solver/","page":"Solver Benchmark","title":"Solver Benchmark","text":"FLOWPanel.solve_backslash!","category":"page"},{"location":"examples/sweptwing-solver/#FLOWPanel.solve_backslash!","page":"Solver Benchmark","title":"FLOWPanel.solve_backslash!","text":"solve_backslash!(y::AbstractVector, A::AbstractMatrix, b::AbstractVector)\n\nSolves a linear system of equations of the form Ay = b using the \\ operator.\n\nThe solution is stored under y.\n\n\n\n\n\n","category":"function"},{"location":"examples/sweptwing-solver/","page":"Solver Benchmark","title":"Solver Benchmark","text":"and is used as follows:","category":"page"},{"location":"examples/sweptwing-solver/","page":"Solver Benchmark","title":"Solver Benchmark","text":"import Printf: @sprintf\n\nfunction calc_lift_drag(body, b, ar, Vinf, magVinf, rho; verbose=true, lbl=\"\")\n\n    CLexp = 0.238\n    CDexp = 0.005\n\n    str = \"\"\n\n    if verbose\n        str *= @sprintf \"| %15.15s | %-7s | %-7s |\\n\" \"Solver\" \"CL\" \"CD\"\n        str *= \"| --------------: | :-----: | :-----: |\\n\"\n    end\n\n    # Calculate velocity away from the body\n    Us = pnl.calcfield_U(body, body; fieldname=\"Uoff\",\n                            offset=0.02, characteristiclength=(args...)->b/ar)\n\n    # Calculate surface velocity U_∇μ due to the gradient of the doublet strength\n    UDeltaGamma = pnl.calcfield_Ugradmu(body)\n\n    # Add both velocities together\n    pnl.addfields(body, \"Ugradmu\", \"Uoff\")\n\n    # Calculate pressure coeffiecient\n    Cps = pnl.calcfield_Cp(body, magVinf; U_fieldname=\"Uoff\")\n\n    # Calculate the force of each panel\n    Fs = pnl.calcfield_F(body, magVinf, rho; U_fieldname=\"Uoff\")\n    # Calculate total force of the vehicle decomposed as lfit, drag, and sideslip\n    Dhat = Vinf/pnl.norm(Vinf)        # Drag direction\n    Shat = [0, 1, 0]              # Span direction\n    Lhat = pnl.cross(Dhat, Shat)      # Lift direction\n\n    LDS = pnl.calcfield_LDS(body, Lhat, Dhat)\n\n    L = LDS[:, 1]\n    D = LDS[:, 2]\n\n    # Force coefficients\n    nondim = 0.5*rho*magVinf^2*b^2/ar   # Normalization factor\n    CL = sign(pnl.dot(L, Lhat)) * pnl.norm(L) / nondim\n    CD = sign(pnl.dot(D, Dhat)) * pnl.norm(D) / nondim\n    err = abs(CL-CLexp)/CLexp\n\n    if verbose\n        str *= @sprintf \"| %15.15s | %-7.4f | %-7.4f |\\n\" lbl CL CD\n        str *= @sprintf \"| %15.15s | %-7s | %-7s |\\n\" \"Experimental\" CLexp CDexp\n        str *= @sprintf \"\\n\\tCL Error:\\t%4.3g﹪\\n\" err*100\n    end\n\n    return CL, CD, str\n\nend\n\n\n# ----- Linear solver test: backslash \\ operator\nt = @elapsed pnl.solve(body, Uinfs, Das, Dbs; solver=pnl.solve_backslash!)\n\nCL, CD, str = calc_lift_drag(body, b, ar, Vinf, magVinf, rho; lbl=\"Backslash\")","category":"page"},{"location":"examples/sweptwing-solver/","page":"Solver Benchmark","title":"Solver Benchmark","text":"Solver CL CD\nBackslash 0.2335 0.0132\nExperimental 0.238 0.005","category":"page"},{"location":"examples/sweptwing-solver/","page":"Solver Benchmark","title":"Solver Benchmark","text":"CL Error:\t1.89﹪\nRun time:\t0.44 seconds","category":"page"},{"location":"examples/sweptwing-solver/#LU-decomposition","page":"Solver Benchmark","title":"LU decomposition","text":"","category":"section"},{"location":"examples/sweptwing-solver/","page":"Solver Benchmark","title":"Solver Benchmark","text":"Pre-calculating and re-using the LU decomposition of A is advantageous when the linear system needs to be solved for multiple boundary conditions.","category":"page"},{"location":"examples/sweptwing-solver/","page":"Solver Benchmark","title":"Solver Benchmark","text":"FLOWPanel.solve_ludiv!","category":"page"},{"location":"examples/sweptwing-solver/#FLOWPanel.solve_ludiv!","page":"Solver Benchmark","title":"FLOWPanel.solve_ludiv!","text":"solve_ludiv!(y::AbstractVector,\n                A::AbstractMatrix, b::AbstractVector; Alu=nothing)\n\nSolves a linear system of equations of the form Ay = b using the LU decomposition of A provided under Alu and LinearAlgebra.ldiv!. If Alu is not provided, it will be automatically calculated using LinearAlgebra.lu.\n\nThis method is useful when the system needs to be solved multiple times for different b vectors since Alu can be precomputed and re-used. We recommend you use FLOWPanel.calc_Alu to compute Alu since this function has been overloaded for Dual and TrackedReal numbers. solve_ludiv! has also been overloaded with ImplicitAD to efficiently differentiate the linear solver as needed.\n\nThe solution is stored under y.\n\nimport FLOWPanel as pnl\n\nAlu = pnl.calc_Alu(A)\npnl.solve_ludiv!(y, A, b; Alu=Alu)\n\n\n\n\n\n","category":"function"},{"location":"examples/sweptwing-solver/","page":"Solver Benchmark","title":"Solver Benchmark","text":"Running the solver:","category":"page"},{"location":"examples/sweptwing-solver/","page":"Solver Benchmark","title":"Solver Benchmark","text":"t = @elapsed pnl.solve(body, Uinfs, Das, Dbs; solver=pnl.solve_ludiv!)\n\nCL, CD, str = calc_lift_drag(body, b, ar, Vinf, magVinf, rho; lbl=\"LUdiv\")","category":"page"},{"location":"examples/sweptwing-solver/","page":"Solver Benchmark","title":"Solver Benchmark","text":"Solver CL CD\nLUdiv 0.2335 0.0132\nExperimental 0.238 0.005","category":"page"},{"location":"examples/sweptwing-solver/","page":"Solver Benchmark","title":"Solver Benchmark","text":"CL Error:\t1.89﹪\nRun time:\t0.44 seconds","category":"page"},{"location":"examples/sweptwing-solver/#Iterative-Krylov-Solver","page":"Solver Benchmark","title":"Iterative Krylov Solver","text":"","category":"section"},{"location":"examples/sweptwing-solver/","page":"Solver Benchmark","title":"Solver Benchmark","text":"Iterative Krylov subspace solvers converge to the right solution rather than directly solving the system of equations. This allows the user to trade off accuracy for computational speed by tuning the tolerance of the solver.","category":"page"},{"location":"examples/sweptwing-solver/","page":"Solver Benchmark","title":"Solver Benchmark","text":"The generalized minimal residual (GMRES) method provided by Krylov.jl is available in FLOWPanel.","category":"page"},{"location":"examples/sweptwing-solver/","page":"Solver Benchmark","title":"Solver Benchmark","text":"FLOWPanel.solve_gmres!","category":"page"},{"location":"examples/sweptwing-solver/#FLOWPanel.solve_gmres!","page":"Solver Benchmark","title":"FLOWPanel.solve_gmres!","text":"solve_gmres!(y::AbstractVector,\n                A::AbstractMatrix, b::AbstractVector; Avalue=nothing,\n                atol=1e-8, rtol=1e-8, optargs...)\n\nSolves a linear system of equations of the form Ay = b through the generalized minimal residual (GMRES) method, which is an iterative method in the Krylov subspace.\n\nThis iterative method is more efficient than a direct method (solve_backslack! or solve_ludiv!) when A is larger than 3000x3000 or so. Also, iterative methods can trade off accuracy for speed by lowering the tolerance (atol and rtol). Optional arguments optargs... will be passed to Krylov.gmres.\n\nDifferentiating through the solver will require extracting the primal values of A, which can be provided through the argument Avalue (this is calculated automatically if not already provided).\n\nThe solution is stored under y.\n\nimport FLOWPanel as pnl\n\nAvalue = pnl.calc_Avalue(A)\npnl.solve_gmres!(y, A, b; Avalue=Avalue)\n\n\n\n\n\n","category":"function"},{"location":"examples/sweptwing-solver/","page":"Solver Benchmark","title":"Solver Benchmark","text":"Running the solver with tolerance 10^-8:","category":"page"},{"location":"examples/sweptwing-solver/","page":"Solver Benchmark","title":"Solver Benchmark","text":"stats = []                      # Stats of GMRES get stored here\n\nt = @elapsed pnl.solve(body, Uinfs, Das, Dbs;\n                        solver = pnl.solve_gmres!,\n                        solver_optargs = (atol=1e-8, rtol=1e-8, out=stats))\n\nCL, CD, str = calc_lift_drag(body, b, ar, Vinf, magVinf, rho; lbl=\"GMRES tol=1e-8\")","category":"page"},{"location":"examples/sweptwing-solver/","page":"Solver Benchmark","title":"Solver Benchmark","text":"Solver CL CD\nGMRES tol=1e-8 0.2335 0.0132\nExperimental 0.238 0.005","category":"page"},{"location":"examples/sweptwing-solver/","page":"Solver Benchmark","title":"Solver Benchmark","text":"CL Error:\t1.89﹪\n\nSimple stats\n niter: 286\n solved: true\n inconsistent: false\n residuals: []\n Aresiduals: []\n κ₂(A): []\n status: solution good enough given atol and rtol\n\nRun time:\t0.71 seconds","category":"page"},{"location":"examples/sweptwing-solver/","page":"Solver Benchmark","title":"Solver Benchmark","text":"Running the solver with tolerance 10^-2:","category":"page"},{"location":"examples/sweptwing-solver/","page":"Solver Benchmark","title":"Solver Benchmark","text":"stats = []                      # Stats of GMRES get stored here\n\nt = @elapsed pnl.solve(body, Uinfs, Das, Dbs;\n                        solver = pnl.solve_gmres!,\n                        solver_optargs = (atol=1e-2, rtol=1e-2, out=stats))\n\nCL, CD, str = calc_lift_drag(body, b, ar, Vinf, magVinf, rho; lbl=\"GMRES tol=1e-2\")","category":"page"},{"location":"examples/sweptwing-solver/","page":"Solver Benchmark","title":"Solver Benchmark","text":"Solver CL CD\nGMRES tol=1e-2 0.2331 0.0129\nExperimental 0.238 0.005","category":"page"},{"location":"examples/sweptwing-solver/","page":"Solver Benchmark","title":"Solver Benchmark","text":"CL Error:\t2.06﹪\n\nSimple stats\n niter: 88\n solved: true\n inconsistent: false\n residuals: []\n Aresiduals: []\n κ₂(A): []\n status: solution good enough given atol and rtol\n\nRun time:\t0.39 seconds","category":"page"},{"location":"examples/sweptwing-solver/","page":"Solver Benchmark","title":"Solver Benchmark","text":"Running the solver with tolerance 10^-1:","category":"page"},{"location":"examples/sweptwing-solver/","page":"Solver Benchmark","title":"Solver Benchmark","text":"stats = []                      # Stats of GMRES get stored here\n\nt = @elapsed pnl.solve(body, Uinfs, Das, Dbs;\n                        solver = pnl.solve_gmres!,\n                        solver_optargs = (atol=1e-1, rtol=1e-1, out=stats))\n\nCL, CD, str = calc_lift_drag(body, b, ar, Vinf, magVinf, rho; lbl=\"GMRES tol=1e-1\")","category":"page"},{"location":"examples/sweptwing-solver/","page":"Solver Benchmark","title":"Solver Benchmark","text":"Solver CL CD\nGMRES tol=1e-1 0.2625 0.0133\nExperimental 0.238 0.005","category":"page"},{"location":"examples/sweptwing-solver/","page":"Solver Benchmark","title":"Solver Benchmark","text":"CL Error:\t10.3﹪\n\nSimple stats\n niter: 25\n solved: true\n inconsistent: false\n residuals: []\n Aresiduals: []\n κ₂(A): []\n status: solution good enough given atol and rtol\n\nRun time:\t0.29 seconds","category":"page"},{"location":"examples/cessna-TE/#Export-Trailing-Edge","page":"Export Trailing Edge","title":"Export Trailing Edge","text":"","category":"section"},{"location":"examples/cessna-TE/","page":"Export Trailing Edge","title":"Export Trailing Edge","text":"For each trailing edge in the mesh we need to generate a collection of ordered points that we can use to recognize such edge in the .msh file. We will use Gmsh to process the STEP file with NURBS and create such lines of points along each trailing edge:","category":"page"},{"location":"examples/cessna-TE/","page":"Export Trailing Edge","title":"Export Trailing Edge","text":"Import STEP file\nFile > Merge\nSet discretization settings\nSet size factor to something small: Tools > Options > Mesh > General > Element size factor > 0.01\n(Image: pic)","category":"page"},{"location":"examples/cessna-TE/","page":"Export Trailing Edge","title":"Export Trailing Edge","text":"Then for each trailing edge:","category":"page"},{"location":"examples/cessna-TE/","page":"Export Trailing Edge","title":"Export Trailing Edge","text":"Create physical group with the TE curve\nMake sure that geometric curves are visible: Tools > Options > Geometry > Visibility > ✓ Curves\nCreate physical group: Modules > Geometry > Physical Groups > Add > Curve\nSelect the curve that define the trailing edge\n(Image: pic)\nDiscretize the TE:\nModules > Mesh > 1D\n(Optional) Verify discretization\nMake nodes visible: Tools > Options > Mesh > Visibility > ✓ Nodes\nZoom into the trailing edge and visually confirm that the line is finelly discretized\n(Image: pic)\nHide nodes (otherwise you won't be able to select other curves in steps   1 and 5): Tools > Options > Mesh > Visibility > □ Nodes\nExport discretized curve as .msh in ASCII format v4: File > Export  and select Mesh - Gmsh MSH (*.msh) in the dropdown menu\nDelete physical group\nModules > Geometry > Physical Groups > Remove > Curve\nSelect the curve that we just exported","category":"page"},{"location":"examples/cessna-TE/","page":"Export Trailing Edge","title":"Export Trailing Edge","text":"Repeat steps 1 through 5 for each trailing edge.","category":"page"},{"location":"examples/cessna-TE/","page":"Export Trailing Edge","title":"Export Trailing Edge","text":"info: Trailing Edge Files\nThe resulting TE .msh files are available here:cessna-TE-leftwing.msh\ncessna-TE-rightwing.msh\ncessna-TE-leftelevator.msh\ncessna-TE-rightelevator.msh\ncessna-TE-rudder.msh(right click → save as...)","category":"page"},{"location":"examples/cessna-vspgeom/#VSPGeom.jl","page":"VSPGeom.jl","title":"VSPGeom.jl","text":"","category":"section"},{"location":"examples/cessna-vspgeom/","page":"VSPGeom.jl","title":"VSPGeom.jl","text":"VSPGeom.jl is a Julia package for reading and processing the geometry of OpenVSP, which we can also use with FLOWPanel. For instance, in OpenVSP we can generate a CFD-quality surface mesh that gets exported as an STL file. The STL can then be read following these instructions and wrapped as a Meshes.jl object that is passed to FLOWPanel.","category":"page"},{"location":"examples/cessna-vspgeom/","page":"VSPGeom.jl","title":"VSPGeom.jl","text":"<center>\n  <img src=\"https://edoalvar2.groups.et.byu.net/public/FLOWPanel/openvsp004.png\" alt=\"Pic here\" style=\"width: 100%;\"/>\n</center>","category":"page"},{"location":"geometry/panel-gradient/#Panel-Gradients","page":"Panel Gradients","title":"Panel Gradients","text":"","category":"section"},{"location":"geometry/panel-gradient/","page":"Panel Gradients","title":"Panel Gradients","text":"Computing the gradient of panel circulation is necessary when using Vortex ring elements to model a geometry. Unlike in structured meshes, gradient estimation in unstructured meshes is not straightforward due to the lack of consistent connectivity. Multiple methods have been proposed to compute gradients on unstructured meshes that utilize either the cell-centered or node-based circulation strengths [1]. A few of these are listed below:","category":"page"},{"location":"geometry/panel-gradient/","page":"Panel Gradients","title":"Panel Gradients","text":"Green-Gauss gradient method\nSimple face averaging\nInverse distance weighted face interpolation\nWeighted Least squares Face interpolation\nWeighted Tri-Linear Face Interpolation\nLeast squares gradient method\nCurvilinear gradient method ","category":"page"},{"location":"geometry/panel-gradient/","page":"Panel Gradients","title":"Panel Gradients","text":"Since cell-centered approaches have inherent difficulties handling boundaries and 'holes' in the geometry, a node-based approach is utlized here. This requires converting cell-centered panel strengths to node-based. An area-weighted averaging procedure enables this conversion. Once node-based strengths are obtained, the gradient is computed as the inclination of the plane passing through the scalar values at each cell's vertex. Steps involved in this procedure are described below.","category":"page"},{"location":"geometry/panel-gradient/","page":"Panel Gradients","title":"Panel Gradients","text":"Consider a single triangular panel element with the scalar values phi_1, phi_2, phi_3 at its three vertices P_1, P_2, P_3. First, the three vertices are converted to a local two-dimensional frame.","category":"page"},{"location":"geometry/panel-gradient/","page":"Panel Gradients","title":"Panel Gradients","text":"<center>\n  <img src=\"../../assets/images/geometry-panel-gradient.png\" alt=\"panel gradient\" style=\"width: 380px;\"/>\n</center>\n<br><br>","category":"page"},{"location":"geometry/panel-gradient/","page":"Panel Gradients","title":"Panel Gradients","text":"A plane passing through phi_1, phi_2, phi_3 satisfies the equations,","category":"page"},{"location":"geometry/panel-gradient/","page":"Panel Gradients","title":"Panel Gradients","text":"alpha + beta (x_1 - x_0) + gamma (y_1 - y_0) = phi_1\n alpha + beta (x_2 - x_0) + gamma (y_2 - y_0) = phi_2\n alpha + beta (x_3 - x_0) + gamma (y_3 - y_0) = phi_3","category":"page"},{"location":"geometry/panel-gradient/","page":"Panel Gradients","title":"Panel Gradients","text":"where (x_0 y_0) is the cell center, and alpha the value of phi at the cell-center. beta and gamma are the gradients (or slope) in the x and y directions in the two-dimensional frame.","category":"page"},{"location":"geometry/panel-gradient/","page":"Panel Gradients","title":"Panel Gradients","text":"The unknowns alpha, beta, and gamma may be obtained by solving the system of linear equations given by,","category":"page"},{"location":"geometry/panel-gradient/","page":"Panel Gradients","title":"Panel Gradients","text":"beginbmatrix\n1  (x_1-x_0)  (y_1-y_0) \n1  (x_1-x_0)  (y_1-y_0) \n1  (x_1-x_0)  (y_1-y_0)\nendbmatrix beginbmatrix\nalpha \nbeta \ngamma\nendbmatrix = beginbmatrix\nphi_1 \nphi_2 \nphi_3\nendbmatrix","category":"page"},{"location":"geometry/panel-gradient/","page":"Panel Gradients","title":"Panel Gradients","text":"The slopes beta and gamma are converted back to three-dimensions using the appropriate basis vectors as shown below,","category":"page"},{"location":"geometry/panel-gradient/","page":"Panel Gradients","title":"Panel Gradients","text":"mathbfnabla phi = beta mathbfe_x + gamma mathbfe_y","category":"page"},{"location":"geometry/panel-gradient/#References","page":"Panel Gradients","title":"References","text":"","category":"section"},{"location":"geometry/panel-gradient/","page":"Panel Gradients","title":"Panel Gradients","text":"[1] Sozer, E., Brehm, C., & Kiris, C. C. (2014). Gradient calculation methods on arbitrary polyhedral unstructured meshes for cell-centered CFD solvers. 52nd Aerospace Sciences Meeting, 1–24.","category":"page"},{"location":"","page":"Intro","title":"Intro","text":"<img src=\"http://edoalvar2.groups.et.byu.net/public/FLOWPanel/julianlogo-flowpanel06.png\" alt=\"FLOWpanel logo\" style=\"width:100%\">","category":"page"},{"location":"","page":"Intro","title":"Intro","text":"<p align=\"right\">\n  <span style=\"color:#7aa098;\">\n    <i>Three-dimensional panel method for low-speed aerodynamics</i>\n  </span>\n</p>","category":"page"},{"location":"","page":"Intro","title":"Intro","text":"<p align=\"right\">\n  <a href=\"https://github.com/byuflowlab/FLOWPanel.jl\">\n    <img src=\"https://img.shields.io/badge/code-open%20source-brightgreen.svg\">\n  </a>\n\n  <a href=\"https://flow.byu.edu/FLOWPanel.jl/dev/\">\n    <img src=\"https://img.shields.io/badge/docs-stable-blue.svg\">\n  </a>\n</p>","category":"page"},{"location":"","page":"Intro","title":"Intro","text":"<p><br></p>","category":"page"},{"location":"#Capabilities","page":"Intro","title":"Capabilities","text":"","category":"section"},{"location":"","page":"Intro","title":"Intro","text":"Structured mesh generation: Lofts • Bodies of revolution • User-defined space transformationsUnstructured mesh import: OpenVSP • CAD (e.g., SolidWorks) + Gmsh • Meshes.jlMulti Element: Source-panel or doublet/vortex-ring for non-lifting bodies • Doublet/vortex-ring for lifting bodies with rigid wake modelFlexible Solver: Direct LU decomposition • Iterative Krylov (GMRES) • Handling of both watertight and open meshes • Multiple bodiesFast Computation: GPU enabled • CPU threaded • Low memory allocation • Type stable • Adjoint solver through ImplicitAD for gradient-based optimization • Support for both ForwardDiff and ReverseDiffCurrent Limitations: Inviscid (no viscous drag nor stall) • Incompressible • No fast multipole method (though a 30,000 panel problem can still be solved in as fast as 90 seconds on a laptop)Coded in the Julia language for Linux, MacOS, and Windows WSL.","category":"page"},{"location":"","page":"Intro","title":"Intro","text":"Tested in Julia v1.10","category":"page"},{"location":"","page":"Intro","title":"Intro","text":"<p><br></p>","category":"page"},{"location":"","page":"Intro","title":"Intro","text":"<p align=\"left\">\n  <img src=\"http://edoalvar2.groups.et.byu.net/public/FLOWPanel/zeroebwb009.jpg\" alt=\"img\" style=\"width:100%\">\n</p>","category":"page"},{"location":"","page":"Intro","title":"Intro","text":"<p><br></p>","category":"page"},{"location":"","page":"Intro","title":"Intro","text":"Documentation: flow.byu.edu/FLOWPanel.jl\nCode: github.com/byuflowlab/FLOWPanel.jl","category":"page"},{"location":"","page":"Intro","title":"Intro","text":"<p><br></p>","category":"page"},{"location":"#Installation-Instructions","page":"Intro","title":"Installation Instructions","text":"","category":"section"},{"location":"","page":"Intro","title":"Intro","text":"Download and install Julia\nType in the Julia REPL: ] add FLOWPanel\n(optional) For visualization, install ParaView and make sure that it is callable from the terminal typing paraview","category":"page"},{"location":"","page":"Intro","title":"Intro","text":"Copy and paste any of the examples directly in the Julia REPL to run your first simulation","category":"page"},{"location":"","page":"Intro","title":"Intro","text":"<p><br></p>","category":"page"},{"location":"#Selected-Publications","page":"Intro","title":"Selected Publications","text":"","category":"section"},{"location":"","page":"Intro","title":"Intro","text":"See the following publication for an in-depth dive into the theory and validation:","category":"page"},{"location":"","page":"Intro","title":"Intro","text":"E. J. Alvarez, C. Joseph, & A. Ning (2023), \"Vortex Particle Method for Electric Ducted Fan in Non-Axisymmetric Flow,\" AIAA AVIATION Forum. [VIDEO] [SLIDES] [PDF]","category":"page"},{"location":"","page":"Intro","title":"Intro","text":"<p><br></p>","category":"page"},{"location":"#About","page":"Intro","title":"About","text":"","category":"section"},{"location":"","page":"Intro","title":"Intro","text":"FLOWPanel is an open-source project jointly led by Whisper Aero and the FLOW Lab at Brigham Young University. All contributions are welcome.","category":"page"},{"location":"","page":"Intro","title":"Intro","text":"Developers/contributors : Eduardo J. Alvarez (main) and Cibin Joseph\nEmail           : edo.alvarezr@gmail.com\nCreated         : August 2021\nLicense         : MIT License","category":"page"},{"location":"","page":"Intro","title":"Intro","text":"<p><br></p>","category":"page"},{"location":"#Sponsors","page":"Intro","title":"Sponsors","text":"","category":"section"},{"location":"","page":"Intro","title":"Intro","text":"<p align=\"right\">\n  <img src=\"http://edoalvar2.groups.et.byu.net/public/FLOWPanel/sponsors01.png\" alt=\"img\" style=\"width:90%\">\n  <br><br><br>\n</p>","category":"page"},{"location":"","page":"Intro","title":"Intro","text":"<p><br></p>","category":"page"},{"location":"","page":"Intro","title":"Intro","text":"<p align=\"center\">\n  <img src=\"http://edoalvar2.groups.et.byu.net/public/FLOWPanel/cessna002.jpg\" alt=\"img\" style=\"width:75%\">\n  <img src=\"http://edoalvar2.groups.et.byu.net/public/FLOWPanel/zeroebwb000.jpg\" alt=\"img\" style=\"width:75%\">\n</p>","category":"page"},{"location":"","page":"Intro","title":"Intro","text":"<p><br></p>","category":"page"},{"location":"","page":"Intro","title":"Intro","text":"<p align=\"center\">\n  <img src=\"http://edoalvar2.groups.et.byu.net/public/FLOWPanel/duct-hill-aoa15-slice02-small.png\" alt=\"img\" style=\"width:45%\"><img src=\"http://edoalvar2.groups.et.byu.net/public/FLOWPanel/light/sphere01_2.gif\" alt=\"img\" style=\"width:45%\">\n</p>","category":"page"},{"location":"examples/duct-fluiddomain/#Fluid-Domain","page":"Fluid Domain","title":"Fluid Domain","text":"","category":"section"},{"location":"examples/duct-fluiddomain/","page":"Fluid Domain","title":"Fluid Domain","text":"The previous script uses the flag fluiddomain to indicate whether to generate the fluid domain around the duct or not. When fluiddomain=true, the fluid domain is generated through the function call generate_fluiddomain(body, AOA, Vinf, d, aspectratio, save_path), which creates a grid around the duct where the velocity, pressure, and potential field are probed. This grid is then saved as an XDMF file that can be visualized in Paraview.","category":"page"},{"location":"examples/duct-fluiddomain/","page":"Fluid Domain","title":"Fluid Domain","text":"generate_fluiddomain is defined under examples/duct_postprocessing.jl as follows:","category":"page"},{"location":"examples/duct-fluiddomain/","page":"Fluid Domain","title":"Fluid Domain","text":"function generate_fluiddomain(body, AOA, Vinf, d, aspectratio, save_path;\n                                halfdomain=false, # Whether to cover only one side of the duct\n                                gridname=\"fluidomain\",\n                                num=nothing,\n                                verbose=true,\n                                v_lvl=0\n                                )\n\n    if verbose; println(\"\\t\"^(v_lvl)*\"Generating fluid domain...\"); end;\n\n    # ---------------- GENERATE FLUID DOMAIN GRID ------------------------------\n    # Bounds of grid\n    Pmax = d*[aspectratio*1.5,    aspectratio*0.005,  0.5*1.35] # Upper bound\n    Pmin = d*[-aspectratio*0.35, -Pmax[2], -Pmax[3]]            # Lower bound\n\n    halfdomain ? Pmin[3] = 0 : nothing\n\n    # Grid discretization\n    dx         = 0.005*d*aspectratio                            # Cell size\n    dy, dz     = dx, dx\n\n    NDIVS = ceil.(Int, (Pmax .- Pmin) ./ [dx, dy, dz]) # Divisions in each dimension\n\n    # Generate grid\n    @time grid  = pnl.gt.Grid(Pmin, Pmax, NDIVS) # Grid\n\n    if verbose; println(\"\\t\"^(v_lvl+1)*\"Grid size:\\t\\t$(NDIVS)\"); end;\n    if verbose; println(\"\\t\"^(v_lvl+1)*\"Number of nodes :\\t$(grid.nnodes)\"); end;\n\n    # Translate and rotate grid to align with freestream\n    O = zeros(3)\n    Oaxis = pnl.gt.rotation_matrix2(0, AOA, 0)\n    pnl.gt.lintransform!(grid, Oaxis, O)\n\n    # Targets where to probe the velocity\n    targets = grid.nodes\n    ntargets = size(targets, 2)\n\n    # Array where to store potential and velocity\n    phis = zeros(ntargets)\n    Us = repeat(Vinf, 1, ntargets)\n\n    # Calculate potential and velocity fields\n    @time pnl.phi!(body, targets, phis)\n    @time pnl.Uind!(body, targets, Us)\n\n    # Save fields\n    pnl.gt.add_field(grid, \"phi\", \"scalar\", phis, \"node\")\n    pnl.gt.add_field(grid, \"U\", \"vector\", collect(eachcol(Us)), \"node\")\n\n    # Output fluid domain\n    @time vtks = pnl.gt.save(grid, gridname; path=save_path, num=num)\n\n    return vtks\nend","category":"page"},{"location":"examples/duct-fluiddomain/","page":"Fluid Domain","title":"Fluid Domain","text":"The fluid domain can be processed to visualize streamlines and contours of velocity/pressure/potential fields as shown below (the Paraview state that generated these images is available here: LINK <- right click and \"save as\")","category":"page"},{"location":"examples/duct-fluiddomain/","page":"Fluid Domain","title":"Fluid Domain","text":"    <table width=100%>\n    <tr>\n        <td>\n            <center>\n                <img src=\"../../assets/images/duct-hill-aoa15-0001-viz-glyph00.png\" alt=\"Pic here\" style=\"width:100%\">\n            </center>\n        </td>\n    </tr>\n    <tr>\n        <td>\n            <center>\n                <img src=\"../../assets/images/duct-hill-aoa15-0001-viz-streamline00.png\" alt=\"Pic here\" style=\"width:100%\">\n            </center>\n        </td>\n    </tr>\n    <tr>\n        <td>\n            <center>\n                <img src=\"../../assets/images/duct-hill-aoa15-0001-viz-u00.png\" alt=\"Pic here\" style=\"width:100%\">\n            </center>\n        </td>\n    </tr>\n    <tr>\n        <td>\n            <center>\n                <img src=\"../../assets/images/duct-hill-aoa15-0001-viz-cp00.png\" alt=\"Pic here\" style=\"width:100%\">\n            </center>\n        </td>\n    </tr>\n    <tr>\n        <td>\n            <center>\n                <img src=\"../../assets/images/duct-hill-aoa15-0001-viz-phi00.png\" alt=\"Pic here\" style=\"width:100%\">\n            </center>\n        </td>\n    </tr>\n</table>","category":"page"},{"location":"elements/constantdoublet/#Constant-Strength-Doublet-(Vortex-Ring)","page":"Constant Doublet","title":"Constant-Strength Doublet (Vortex Ring)","text":"","category":"section"},{"location":"elements/constantdoublet/","page":"Constant Doublet","title":"Constant Doublet","text":"Recall that the potential field induced by doublets is given by","category":"page"},{"location":"elements/constantdoublet/","page":"Constant Doublet","title":"Constant Doublet","text":"beginalign*\n        phi_mu(mathbfx)\n    = \n        fracf_tiny partial V_b(mathbfx)pi \n        intlimits_partial V_b\n            mu hatmathbfn cdot  nabla left(frac1rright)\n        mathrmdS\nendalign*","category":"page"},{"location":"elements/constantdoublet/","page":"Constant Doublet","title":"Constant Doublet","text":"while the component induced by sources is","category":"page"},{"location":"elements/constantdoublet/","page":"Constant Doublet","title":"Constant Doublet","text":"beginalign*\n        phi_sigma(mathbfx)\n    = \n        -fracf_tiny partial V_b(mathbfx)pi \n        intlimits_partial V_b\n            sigma frac1r\n        mathrmdS\nendalign*","category":"page"},{"location":"elements/constantdoublet/","page":"Constant Doublet","title":"Constant Doublet","text":"Assuming constant-strength panels, each strength comes out of the integrals and we rewrite the above equations as","category":"page"},{"location":"elements/constantdoublet/","page":"Constant Doublet","title":"Constant Doublet","text":"beginalign*\n        phi_mu(mathbfx)\n    = \n        mu G_mu (mathbfx)\n    quad  quad\n        G_mu (mathbfx)\n    equiv\n        fracf_tiny partial V_b(mathbfx)pi \n        intlimits_partial V_b\n             hatmathbfn cdot  nabla left(frac1rright)\n        mathrmdS\nendalign*","category":"page"},{"location":"elements/constantdoublet/","page":"Constant Doublet","title":"Constant Doublet","text":"and","category":"page"},{"location":"elements/constantdoublet/","page":"Constant Doublet","title":"Constant Doublet","text":"beginalign*\n        phi_sigma(mathbfx)\n    = \n        sigma G_sigma (mathbfx)\n    quad  quad\n        G_sigma (mathbfx)\n    equiv\n        -fracf_tiny partial V_b(mathbfx)pi \n        intlimits_partial V_b\n            frac1r\n        mathrmdS\nendalign*","category":"page"},{"location":"elements/constantdoublet/","page":"Constant Doublet","title":"Constant Doublet","text":"Notice that computation of the potential field induced by the doublet element is similar to the computation of the normal velocity induced by the source element:","category":"page"},{"location":"elements/constantdoublet/","page":"Constant Doublet","title":"Constant Doublet","text":"beginalign*\n        hatmathbfn cdot nablaphi_sigma\n    =\n        -sigma fracf_tiny partial V_bpi \n        intlimits_partial V_b\n            hatmathbfn cdot nabla left(\n                frac1r\n            right)\n        mathrmdS\n    =\n        -sigma G_mu\nendalign*","category":"page"},{"location":"elements/constantdoublet/","page":"Constant Doublet","title":"Constant Doublet","text":"Hence, we can simply reuse the computation of the source-induced velocity to calculate the potential of the doublet element as","category":"page"},{"location":"elements/constantdoublet/","page":"Constant Doublet","title":"Constant Doublet","text":"beginalign*\n        phi_mu\n    =\n        -mu frachatmathbfn cdot mathbfu_sigmasigma\nendalign*","category":"page"},{"location":"elements/constantdoublet/","page":"Constant Doublet","title":"Constant Doublet","text":"where hatmathbfn cdot mathbfu_sigma = U_z with U_z as defined in the previous section.","category":"page"},{"location":"elements/constantdoublet/","page":"Constant Doublet","title":"Constant Doublet","text":"In order to calculate the velocity field induced by the doublet, instead of calculating nablaphi_mu we take advantage of the fact that the velocity induced by a constant-strength doublet panel is the same than the velocity induced by a vortex ring (see Katz and Plotkin Sec. 10.4.3),","category":"page"},{"location":"elements/constantdoublet/","page":"Constant Doublet","title":"Constant Doublet","text":"beginalign*\n        mathbfu_mathrmring left( mathbfx right)\n    =\n        fracGamma4pi\n        sumlimits_ijin A\n            fracmathbfr_i times mathbfr_j Vert mathbfr_i times mathbfr_j Vert^2\n            mathbfr_ij cdot left(\n                fracmathbfr_ir_i - fracmathbfr_jr_j\n            right)\nendalign*","category":"page"},{"location":"elements/constantdoublet/","page":"Constant Doublet","title":"Constant Doublet","text":"when Gamma = mu, and where mathbfr_ij = mathbfp_j-mathbfp_i, mathbfr_i = mathbfx - mathbfp_i, mathbfr_j = mathbfx - mathbfp_j, A = (12)dots(n-1 n)(n 1)  and n the number of vertices that make the panel, each with position mathbfp_k.","category":"page"},{"location":"elements/constantdoublet/","page":"Constant Doublet","title":"Constant Doublet","text":"NOTE: For the same reasons explained in the previous section, phi_mu poses a discontinuity at the surface since limlimits_zrightarrow pm 0 phi_mu (0 0 z) = -fracmusigma limlimits_zrightarrow pm 0 U_z (0 0 z) = mp fracmu2. In FLOWPanel, we let phi_mu (0 0 0) = 0, but we also have shifted all control points slightly in the direction of hatmathbfn. Remembering that hatmathbfn_mathrmHS = -hatmathbfn, the control points are thus shifted in the -z direction, effectively obtaining boxedphi_mu (mathbfx_mathrmcp) approx fracmu2.","category":"page"},{"location":"elements/constantdoublet/","page":"Constant Doublet","title":"Constant Doublet","text":"OBSERVATIONS","category":"page"},{"location":"elements/constantdoublet/","page":"Constant Doublet","title":"Constant Doublet","text":"The velocity induced by a segment of the vortex ring shown above becomes singular when the denominator terms r_i, r_j, or Vert mathbfr_i times mathbfr_j Vert  approach 0. For this reason, FLOWPanel adds a small epsilon to each of these terms, while also defining a cutoff threshold for Vert mathbfr_i times mathbfr_j Vert under which the velocity induced becomes 0 (thus, self-induced velocity is forced to be zero).","category":"page"},{"location":"elements/constantdoublet/","page":"Constant Doublet","title":"Constant Doublet","text":"NOTE: The small offset added to the denominator terms r_i, r_j, and Vert mathbfr_i times mathbfr_j Vert corresponds to body.kerneloffset, while the cutoff threshold for self-induced velocity corresponds to body.kernelcutoff.","category":"page"},{"location":"elements/constantdoublet/","page":"Constant Doublet","title":"Constant Doublet","text":"The potential and velocity field of a doublet panel of unitary strength (mu=1) is shown below","category":"page"},{"location":"elements/constantdoublet/","page":"Constant Doublet","title":"Constant Doublet","text":"<center>\n  <table>\n      <tr>\n          <th>\n              <img src=\"../../assets/images/panel-doublet-phi02.png\" alt=\"Pic here\" width=\"450px\">\n          </th>\n          <th>\n              <img src=\"../../assets/images/panel-doublet-u01.png\" alt=\"Pic here\" width=\"300px\">\n          </th>\n      </tr>\n  </table>\n</center>","category":"page"},{"location":"elements/constantdoublet/","page":"Constant Doublet","title":"Constant Doublet","text":"<center>\n  <br>$\\nabla \\phi$ = $\\mathbf{u}$ verification\n  <img src=\"../../assets/images/panel-doublet-divphivsu00.png\" alt=\"Pic here\" style=\"width: 700px;\"/>\n</center>","category":"page"}]
}
