<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Surface Grid · FLOWPanel.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.svg" alt="FLOWPanel.jl logo"/></a><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Intro</a></li><li><a class="tocitem" href="../../potentialflow/">Potential Flow</a></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">Elements</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../elements/paneldefinition/">Panel Definition</a></li><li><a class="tocitem" href="../../elements/constantsource/">Constant Source</a></li><li><a class="tocitem" href="../../elements/constantdoublet/">Constant Doublet</a></li><li><a class="tocitem" href="../../elements/semiinfdoublet/">Semi-Infinite Doublet</a></li><li><a class="tocitem" href="../../elements/semiinfnonplanardoublet/">Non-Planar Semi-Infinite Doublet</a></li><li><a class="tocitem" href="../../elements/constantvortexsheet/">Constant Vortex Sheet</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox" checked/><label class="tocitem" for="menuitem-4"><span class="docs-label">Geometry Engine</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><input class="collapse-toggle" id="menuitem-4-1" type="checkbox"/><label class="tocitem" for="menuitem-4-1"><span class="docs-label">Grid Generation</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../gridgeneration/">Methods</a></li><li><a class="tocitem" href="../gridgeneration-loft/">Lofting Method</a></li><li><a class="tocitem" href="../gridgeneration-pathloft/">Path-Lofting Method</a></li><li><a class="tocitem" href="../gridgeneration-rev/">Surface of Revolution Method</a></li><li><a class="tocitem" href="../gridgeneration-transf/">Space Transformation Method</a></li><li><a class="tocitem" href="../gridgeneration-triang/">Grid Triangulation</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4-2" type="checkbox" checked/><label class="tocitem" for="menuitem-4-2"><span class="docs-label">Advanced</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../basics/"><code>GeometricTools.jl</code></a></li><li><a class="tocitem" href="../basics-grid/">Cartesian Grid</a></li><li><a class="tocitem" href="../basics-transformations/">Space Transformations</a></li><li><a class="tocitem" href="../basics-loopedgrid/">Looped Grid</a></li><li class="is-active"><a class="tocitem" href>Surface Grid</a><ul class="internal"><li><a class="tocitem" href="#Example-—-Paneled-Wing"><span>Example — Paneled Wing</span></a></li></ul></li><li><a class="tocitem" href="../panel-gradient/">Panel Gradients</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">Tutorials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><input class="collapse-toggle" id="menuitem-5-1" type="checkbox"/><label class="tocitem" for="menuitem-5-1"><span class="docs-label">Swept Wing</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../examples/sweptwing-4p2aoa/">4.2° Angle of Attack</a></li><li><a class="tocitem" href="../../examples/sweptwing-aoasweep/">AOA Sweep</a></li><li><a class="tocitem" href="../../examples/sweptwing-solver/">Solver Benchmark</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5-2" type="checkbox"/><label class="tocitem" for="menuitem-5-2"><span class="docs-label">Centerbody</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../examples/centerbody-source/">Source Elements</a></li><li><a class="tocitem" href="../../examples/centerbody-slice/">Slice</a></li><li><a class="tocitem" href="../../examples/centerbody-vortexring/">Vortex Ring Elements</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5-3" type="checkbox"/><label class="tocitem" for="menuitem-5-3"><span class="docs-label">Duct</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../examples/duct-aoasweep/">AOA Sweep</a></li><li><a class="tocitem" href="../../examples/duct-fluiddomain/">Fluid Domain</a></li><li><a class="tocitem" href="../../examples/duct-leastsquares/">Least-Squares Solver</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5-4" type="checkbox"/><label class="tocitem" for="menuitem-5-4"><span class="docs-label">Blended Wing Body</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../examples/blendedwingbody-cad/">CAD Model</a></li><li><a class="tocitem" href="../../examples/blendedwingbody-gmsh/">Unstructured Meshing</a></li><li><a class="tocitem" href="../../examples/blendedwingbody-TE/">Export Trailing Edge</a></li><li><a class="tocitem" href="../../examples/blendedwingbody-aero/">Import Mesh and Solve</a></li><li><a class="tocitem" href="../../examples/blendedwingbody-gpucpu/">GPU and CPU Acceleration</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5-5" type="checkbox"/><label class="tocitem" for="menuitem-5-5"><span class="docs-label">Cessna 210</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../examples/cessna-openvsp/">OpenVSP Model</a></li><li><a class="tocitem" href="../../examples/cessna-TE/">Export Trailing Edge</a></li><li><a class="tocitem" href="../../examples/cessna-aero/">Import Mesh and Solve</a></li><li><a class="tocitem" href="../../examples/cessna-vspgeom/">VSPGeom.jl</a></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Geometry Engine</a></li><li><a class="is-disabled">Advanced</a></li><li class="is-active"><a href>Surface Grid</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Surface Grid</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/byuflowlab/FLOWPanel.jl/blob/master/docs/src/geometry/basics-surfacegrid.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Surface-Grid"><a class="docs-heading-anchor" href="#Surface-Grid">Surface Grid</a><a id="Surface-Grid-1"></a><a class="docs-heading-anchor-permalink" href="#Surface-Grid" title="Permalink"></a></h1><p>A 3D surface grid can be generated by defining a 3D grid where one of its dimensions has zero divisions, and then transforming the space into the surface geometry. A dimension with zero divisions is recognized as a &quot;quasi-dimension&quot;, which is a place holder for space transformations without actually spanning the dimensions of the grid. For instance, a 3D grid with one quasi-dimension doesn&#39;t define its cells as VTK-HEXAHEDRONs as a regular 3D grid would, but <strong>its cells are defined as VTK-QUADs</strong>. Also, quasi-dimensions are not considered as a coordinate direction, meaning that a node/cell in a 3D grid with one quasi-dimension is not indexed by three coordinates <span>$(i,j,k)$</span>, but with <strong>only two coordinates <span>$(i,j)$</span>.</strong></p><p>The following lines exemplify the process of defining the quasi-dimensional grid, and applying the space transformation:</p><pre><code class="language-julia hljs">import GeometricTools as gt

# Create quasi-3D grid
P_min = [0, -1, 0]            # Lower boundaries of arclength, span, and dummy
P_max = [1, 1, 0 ]            # Upper boundaries of arclength, span, and dummy
NDIVS = [20, 10, 0]           # Divisions: 20 arclength, 10 span, 0 dummy
grid = gt.Grid(P_min, P_max, NDIVS)

# Create a space transformation function
function my_space_transform(X)
    new_X = ... # Write a new definition of each node here
    return new_X
end

# Applie the space transformation
gt.transform!(grid, my_space_transform)</code></pre><h2 id="Example-—-Paneled-Wing"><a class="docs-heading-anchor" href="#Example-—-Paneled-Wing">Example — Paneled Wing</a><a id="Example-—-Paneled-Wing-1"></a><a class="docs-heading-anchor-permalink" href="#Example-—-Paneled-Wing" title="Permalink"></a></h2><p>We will now use a space transformation on a 2D looped grid with 3D quasi-dimensions to generate the 3D surface of a wing.</p><pre><code class="language-julia hljs">import FLOWPanel as pnl
import GeometricTools as gt
                                # Airfoil data path
airfoil_path = joinpath(pnl.def_data_path, &quot;airfoils&quot;);

file_name = &quot;paneledwing00&quot;
paraview = true

# ----------------- READ AND PARAMETERIZE AIRFOILS ----------------------------
semispan = 10            # (m) semi-span length

chords = [(0, 2.5),      # (semi-span position, chord length (m))
          (0.25, 2.0),
          (1, 1.0)]

x_pos = [(0, 0),         # (semi-span position, leading edge x-position (m))
         (0.25, semispan/40 ),
         (1, semispan/8 )]

z_pos = [(0, 0),         # (semi-span position, leading edge z-position (m))
         (0.25, semispan/100 ),
         (1, semispan/50 )]

twist = [(0, 5),         # (semi-span position, twist (deg))
         (1, 0)]

airfoils = [(0, &quot;naca6412.dat&quot;), # (semi-span position, airfoil geometry)
            (1, &quot;naca6412.dat&quot;)]

airfoil_funs = []

for (pos, airfoil_file) in airfoils
    # Read the original airfoil geometry from airfoiltools.com
    org_x, org_y = gt.readcontour(joinpath(airfoil_path, airfoil_file); header_len=1)

    # Separate upper and lower sides to make the contour injective in x
    upper, lower = gt.splitcontour(org_x, org_y)

    # Parameterize both sides independently
    fun_upper = gt.parameterize(upper[1], upper[2], zeros(size(upper[1])); inj_var=1)
    fun_lower = gt.parameterize(lower[1], lower[2], zeros(size(lower[1])); inj_var=1)

    push!(airfoil_funs, [pos, (fun_upper, fun_lower)])
end


# ----------------- CREATE 3D SURFACE GRID ----------------------------------
P_min = [0, -1, 0]            # Lower boundaries arclength, span, dummy
P_max = [1, 1, 0 ]            # Upper boundaries arclength, span, dummy
NDIVS = [20, 10, 0]           # 50 arclength cells, 10 span cells, 0 dummy
loop_dim = 1                  # Loop the arclength dimension

grid = gt.Grid(P_min, P_max, NDIVS, loop_dim)

gt.plot(grid; labelnodes=!true, labelcells=!true, labelndivs=true,
                fontsize=8, fig_name=&quot;org&quot;, title_str=&quot;Original Grid&quot;,
                alpha=0.25)</code></pre><img src="../../assets/images/geometry-surfacegrid-wing00.png" alt="Pic here" style="width: 600px;"/>
<br><br><br><br><pre><code class="language-julia hljs"># Auxiliary function for weighting values across span
function calc_vals(span, array)

    # Finds bounding airfoil position
    val_in, val_out = nothing, array[1]
    for val in array[2:end]
        val_in = val_out
        val_out = val
        if val[1]&gt;=abs(span); break; end
    end
    pos_in = val_in[1]
    val_in = val_in[2]
    pos_out = val_out[1]
    val_out = val_out[2]

    weight = (abs(span)-pos_in)/(pos_out-pos_in)

    return weight, val_in, val_out
end

# Creates a space transformation function
function my_space_transform(X)
    span = X[2]

    # Calculates chord
    weight, chord_in, chord_out = calc_vals(span, chords)
    chord = weight*chord_out+(1-weight)*chord_in

    # Calculates airfoil geometry
    weight, rfl_in, rfl_out = calc_vals(span, airfoil_funs)
    fun_upper_in, fun_lower_in = rfl_in
    fun_upper_out, fun_lower_out = rfl_out

    # Arc-length on upper or lower side of airfoil
    if X[1]&lt;0.5
        s = 1 - 2 * X[1]
        fun_in = fun_upper_in
        fun_out = fun_upper_out
    else
        s = 2 * (X[1] - 0.5)
        fun_in = fun_lower_in
        fun_out = fun_lower_out
    end

    # Point over airfoil contour
    point =  weight * fun_out(s) + (1 - weight) * fun_in(s)
    point = chord * point

    # Twist
    weight, twist_in, twist_out = calc_vals(span, twist)
    this_twist = weight * twist_out + (1 - weight) * twist_in

    # Applies twist to the airfoil point
    point = gt.rotation_matrix(-this_twist, 0, 0) * point

    # Leading edge x-position
    weight, x_in, x_out = calc_vals(span, x_pos)
    le_x = weight * x_out + (1 - weight) * x_in

    # Leading edge z-position
    weight, z_in, z_out = calc_vals(span, z_pos)
    le_z = weight * z_out + (1 - weight) * z_in

    # Span position
    y = X[2] * semispan

    return [point[1] + le_x, y, point[2] + le_z]
end

# Transforms the quasi-2D grid into the wing surface
gt.transform!(grid, my_space_transform)


lims = [-semispan, semispan]
gt.plot(grid; labelnodes=!true, labelcells=!true, labelndivs=true,
                fontsize=8, title_str=&quot;Transformed grid&quot;, alpha=0.25,
                xlims=lims / 2 .* [0,1], ylims=lims, zlims=lims/10);</code></pre><img src="../../assets/images/geometry-surfacegrid-wing01.png" alt="Pic here" style="width: 600px;"/>
<br><br><br><br><pre><code class="language-julia hljs"># Adds some dummy example fields
gt.add_field(grid, &quot;node_index&quot;, &quot;scalar&quot;, [i for i in 1:grid.nnodes], &quot;node&quot;)
gt.add_field(grid, &quot;cell_index&quot;, &quot;scalar&quot;, [i for i in 1:grid.ncells], &quot;cell&quot;)

if paraview
    # Outputs a vtk file
    gt.save(grid, file_name; format=&quot;vtk&quot;)

    # Calls paraview
    run(`paraview --data=$file_name.vtk`)
end;</code></pre><img src="../../assets/images/wing04.png" alt="Pic here" style="width: 800px;"/>
<img src="http://edoalvar2.groups.et.byu.net/public/FLOWPanel/wing04.gif" alt="Vid here" style="width: 800px;"/><p>By construction, the wing we have defined has non-planar quadrilateral panel. Since some solvers require planar panels, GeometricTools has a especial type of grid that receives a 3D surface <code>Grid</code> object, and splits all non-planar quadrilateral panels into planar triangular panels of the <code>VTK_TRIANGLE</code> type.</p><img src="../../assets/images/vtk_triangle.png" alt="Pic here" style="width: 200px;"/>
<br><br><p>This is implemented in the <code>GridTriangleSurface</code> type:</p><p><a href="../gridgeneration-triang/#GeometricTools.GridTriangleSurface"><code>FLOWPanel.GeometricTools.GridTriangleSurface</code></a></p><pre><code class="language-julia hljs">file_name = &quot;paneledwing01&quot;

# Splits the quadrialateral panels into triangles
dimsplit = 1              # Dimension along which to split
triang_grid = gt.GridTriangleSurface(grid, dimsplit)

# Adds some dummy example fields
gt.add_field(triang_grid, &quot;node_index&quot;, &quot;scalar&quot;,
                    [i for i in 1:triang_grid.nnodes], &quot;node&quot;)
gt.add_field(triang_grid, &quot;cell_index&quot;, &quot;scalar&quot;,
                    [i for i in 1:triang_grid.ncells], &quot;cell&quot;)
gt.add_field(triang_grid, &quot;normal&quot;, &quot;vector&quot;,
                    [gt.get_normal(triang_grid, i)
                       for i in 1:triang_grid.ncells], &quot;cell&quot;)
gt.add_field(triang_grid, &quot;tangent&quot;, &quot;vector&quot;,
                    [gt.get_tangent(triang_grid, i)
                       for i in 1:triang_grid.ncells], &quot;cell&quot;)

if paraview
    # Outputs a vtk file
    gt.save(triang_grid, file_name; format=&quot;vtk&quot;)

    # Calls paraview
    run(`paraview --data=$file_name.vtk`)
end</code></pre><img src="../../assets/images/wing05.png" alt="Pic here" style="width: 900px;"/></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../basics-loopedgrid/">« Looped Grid</a><a class="docs-footer-nextpage" href="../panel-gradient/">Panel Gradients »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Tuesday 23 April 2024 18:11">Tuesday 23 April 2024</span>. Using Julia version 1.10.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
