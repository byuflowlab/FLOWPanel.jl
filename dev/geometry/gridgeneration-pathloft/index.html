<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Path-Lofting Method · FLOWPanel.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.svg" alt="FLOWPanel.jl logo"/></a><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../potentialflow/">Potential Flow</a></li><li><span class="tocitem">Elements</span><ul><li><a class="tocitem" href="../../elements/paneldefinition/">Panel Definition</a></li><li><a class="tocitem" href="../../elements/constantsource/">Constant Source</a></li><li><a class="tocitem" href="../../elements/constantdoublet/">Constant Doublet</a></li><li><a class="tocitem" href="../../elements/semiinfdoublet/">Semi-Infinite Doublet</a></li><li><a class="tocitem" href="../../elements/semiinfnonplanardoublet/">Non-Planar Semi-Infinite Doublet</a></li><li><a class="tocitem" href="../../elements/constantvortexsheet/">Constant Vortex Sheet</a></li></ul></li><li><span class="tocitem">Geometry Engine</span><ul><li><input class="collapse-toggle" id="menuitem-4-1" type="checkbox" checked/><label class="tocitem" for="menuitem-4-1"><span class="docs-label">Grid Generation</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../gridgeneration/">Methods</a></li><li><a class="tocitem" href="../gridgeneration-loft/">Lofting Method</a></li><li class="is-active"><a class="tocitem" href>Path-Lofting Method</a><ul class="internal"><li><a class="tocitem" href="#Example"><span>Example</span></a></li></ul></li><li><a class="tocitem" href="../gridgeneration-rev/">Surface of Revolution Method</a></li><li><a class="tocitem" href="../gridgeneration-transf/">Space Transformation Method</a></li><li><a class="tocitem" href="../gridgeneration-triang/">Grid Triangulation</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4-2" type="checkbox"/><label class="tocitem" for="menuitem-4-2"><span class="docs-label">Advanced</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../basics/"><code>GeometricTools.jl</code></a></li><li><a class="tocitem" href="../basics-grid/">Cartesian Grid</a></li><li><a class="tocitem" href="../basics-transformations/">Space Transformations</a></li><li><a class="tocitem" href="../basics-loopedgrid/">Looped Grid</a></li><li><a class="tocitem" href="../basics-surfacegrid/">Surface Grid</a></li><li><a class="tocitem" href="../panel-gradient/">Panel Gradients</a></li></ul></li></ul></li><li><span class="tocitem">Examples</span><ul><li><input class="collapse-toggle" id="menuitem-5-1" type="checkbox"/><label class="tocitem" for="menuitem-5-1"><span class="docs-label">Swept Wing</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../examples/sweptwing-4p2aoa/">4.2° Angle of Attack</a></li><li><a class="tocitem" href="../../examples/sweptwing-aoasweep/">AOA Sweep</a></li><li><a class="tocitem" href="../../examples/sweptwing-solver/">Solver Benchmark</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5-2" type="checkbox"/><label class="tocitem" for="menuitem-5-2"><span class="docs-label">Centerbody</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../examples/centerbody-source/">Source Elements</a></li><li><a class="tocitem" href="../../examples/centerbody-slice/">Slice</a></li><li><a class="tocitem" href="../../examples/centerbody-vortexring/">Vortex Ring Elements</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5-3" type="checkbox"/><label class="tocitem" for="menuitem-5-3"><span class="docs-label">Duct</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../examples/duct-aoasweep/">AOA Sweep</a></li><li><a class="tocitem" href="../../examples/duct-fluiddomain/">Fluid Domain</a></li><li><a class="tocitem" href="../../examples/duct-leastsquares/">Least-Squares Solver</a></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Geometry Engine</a></li><li><a class="is-disabled">Grid Generation</a></li><li class="is-active"><a href>Path-Lofting Method</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Path-Lofting Method</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/byuflowlab/FLOWPanel.jl/blob/master/docs/src/geometry/gridgeneration-pathloft.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Path-Lofting-Method"><a class="docs-heading-anchor" href="#Path-Lofting-Method">Path-Lofting Method</a><a id="Path-Lofting-Method-1"></a><a class="docs-heading-anchor-permalink" href="#Path-Lofting-Method" title="Permalink"></a></h1><p>The following function in GeometricTools facilitates the path lofting of a surface geometry through a set of cross sections and a path. This method will use an Akima spline to extrapolate in between the sections and path points that are given by the user, which resembles the flexibility of NURBs but without weights to make the process simpler for the user.</p><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>FLOWPanel.GeometricTools.surface_pathloft</code>. Check Documenter&#39;s build log for details.</p></div></div><h2 id="Example"><a class="docs-heading-anchor" href="#Example">Example</a><a id="Example-1"></a><a class="docs-heading-anchor-permalink" href="#Example" title="Permalink"></a></h2><p>First, we generate a set of conical sections for the loft:</p><pre><code class="language-julia hljs">import GeometricTools as gt
import FLOWMath as math
import PyPlot as plt

import LinearAlgebra: det
import PyPlot: @L_str

# Circular-to-rectangular transition
areadist        = [ # (xpos, area/R^2)      # Area distribution
                    (0.0, pi),
                    (1.0, pi)
                  ]
ar              = 2.0                       # Rectangle&#39;s aspect ratio
flatbottom      = false                     # If true, makes the lower inner surface flat, if false, the geometry is symmetric

sections_params = [ # (x-pos (0==LE, 1==TE), conic shape parameter rho, aspect ratio y/z)
                                (0.0,  0.4142, 1.0),
                                (0.125, 0.4142, 1.0),
                                (0.25, 0.4142, 1.0),
                                (0.8,  0.82,   ar),
                                (0.9,  0.82,   ar),
                                (1.0,   0.82,   ar),
                            ]

# npoints         = 20                       # Number of points per conic segment per section
npoints         = 100

# Spline area/R^2 distribution
area_spl = math.Akima([xa[1] for xa in areadist], [xa[2] for xa in areadist])

# Generate deforming sections from conic contours
sections = [ # (x, yzpoints)
            ]

# Plot area/R^2 distribution
fig = plt.figure(figsize=[7, 5]*5/9)
ax = fig.gca()
ax.plot(getindex.(areadist, 1), getindex.(areadist, 2)/pi, &quot;ok&quot;)
ax.plot(range(0, 1, length=100), area_spl(range(0, 1, length=100))/pi, &quot;-r&quot;)
ax.set_title(&quot;Area distribution spline&quot;)
ax.set_xlabel(L&quot;x/d&quot;)
ax.set_ylabel(L&quot;\mathrm{Area} / \pi d^2&quot;)

# Generate and plot conic sections
fig = plt.figure(figsize=[7, 5]*5/9)
ax = fig.gca()
ax.set_aspect(&quot;equal&quot;)

for (xpos, rho, ar) in sections_params

    # Contour points
    Ps = [ [1, 0], [0, 1], [-1, 0], [0, -1] ]

    # Control points
    CPs = [ [1, 1], [-1, 1], [-1, -1], [1, -1] ]

    # Apply aspect ratio
    Ps = [ [x, y/ar] for (x, y) in Ps ]
    CPs = [ [x, y/ar] for (x, y) in CPs ]

    # Conic shape parameter for each control point
    rhos = [ rho for i in 1:length(CPs) ]

    # Parametric probing points along each segment of the compound conic
    ss = [ collect(range(0, 1, length=npoints)) for i in 1:length(CPs) ]

    points = gt.conic_cross_section(Ps, CPs, rhos, ss)

    # Calculate original area of this compound conic
    area_org = 0
    for (i, X) in enumerate(points)

        Y = points[i%length(points) + 1]

        area_org += det(hcat(X, Y))/2

    end

    # Scale contour by target area distribution
    area_trg = area_spl(xpos)
    points *= sqrt(area_trg / area_org)

    # Verify new area
    area_new = 0
    for (i, X) in enumerate(points)

        Y = points[i%length(points) + 1]

        area_new += det(hcat(X, Y))/2

    end
    println(&quot;Section x=$(xpos)&quot;)
    println(&quot;\tOriginal area: $(area_org)&quot;)
    println(&quot;\tTarget area: $(area_trg)&quot;)
    println(&quot;\tActual area: $(area_new)&quot;)

    # Move contour down to have a straight bottom surface
    zmin = flatbottom ? minimum(z for (y, z) in points) : -1.0
    for X in points
        X[2] -= (zmin + 1.0)
    end

    # Plot contour
    ys = [y for (y, z) in points]
    zs = [z for (y, z) in points]
    ax.plot(ys, zs, &quot;.-&quot;, label=L&quot;x = &quot;*&quot;$(xpos)&quot;, alpha=0.8)

    # Convert points from array of arrays to a matrix
    points_matrix = hcat(ys, zs)

    push!(sections, (; x=xpos, points=points_matrix))
end</code></pre><p>Now we define the path and use the sections to generate the path loft:</p><pre><code class="language-julia hljs">save_path = &quot;pathloft-test000&quot;

xpos_NDIVS = 7*10
sec_NDIVS = 20*10

sec_NDIVS = [[(1.0, sec_NDIVS, 1.0, true)] for i in 1:6]

sections = [(pos, points) for (pos, points) in sections]


path_Xs = [[1, 0, 0], [3.0, 0, 0], [4.0, 0.5, 0], [6.0, 1, 1]]
path_normals = [[1, 0, 0], [1, 0, 0], [1, 1, 0]/sqrt(2), [1, 1, 1]/sqrt(3)]
path_twists = [0, 45, 0, -45]

path = collect(zip(path_Xs, path_normals, path_twists))

grid = gt.surface_pathloft(sections, sec_NDIVS, xpos_NDIVS, path;
                                    save_path=save_path, paraview=true)</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../gridgeneration-loft/">« Lofting Method</a><a class="docs-footer-nextpage" href="../gridgeneration-rev/">Surface of Revolution Method »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Friday 26 January 2024 20:44">Friday 26 January 2024</span>. Using Julia version 1.6.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
