        - struct Quaternion{TF}
        -     real::TF
        -     pure::SVector{3,TF}
        - end
        - 
        - function rotate(v, q::Quaternion)
        -     t = 2*cross(q.pure, v)
        -     return v + q.real*t + cross(q.pure,t)
        - end
        - 
        - "perform the reverse rotation"
        - function antirotate(v, q::Quaternion)
        -     q = Quaternion(q.real, -q.pure)
        -     return rotate(v, q)
        - end
        - 
        - function get_quaternion(axis, angle)
        0     @assert isapprox(norm(axis), 1.0; atol=1e-12) "axis must be a unit vector"
        0     stheta_over_2, ctheta_over_2 = sincos(angle/2)
        -     real_part = ctheta_over_2
        0     pure_part = axis * stheta_over_2
        0     quat = Quaternion(real_part, pure_part)
        0     return quat
        - end
        - 
        - function rotate(v, axis, angle)
        0     return rotate(v, get_quaternion(axis, angle))
        - end
        - 
        - function antirotate(v, axis, angle)
        -     return rotate(v, get_quaternion(axis, -angle))
        - end
        - 
        0 function create_panel(;
        -         vertices = SVector{4}(
        -             SVector{3}(-0.5,-0.5,0.0),
        -             SVector{3}(0.5,-0.5,0.0),
        -             SVector{3}(0.5,0.5,0.0),
        -             SVector{3}(-0.5,0.5,0.0),
        -         ),
        -         control_point = SVector{3}(0.0,0.0,0.0),
        -         normal = SVector{3}(0,0,1.0),
        -         strength = SVector{1}(1.0),
        -         invert_normals = false,
        -     )
        - 
        -     radius = FLOWPanel.get_radius(control_point, vertices...)
        -     
        -     if invert_normals
        -         vertices = reverse(vertices)
        -         normal = -1 * normal
        -     end
        - 
        -     return Panel(vertices, control_point, normal, strength, radius)
        - end
        - 
        0 function create_random_panel(seed=123;
        -         vertices = SVector{3}(
        -             rand(SVector{3}),
        -             rand(SVector{3}),
        -             rand(SVector{3}),
        -         ),
        -         strength = SVector{1}(1.0),
        -         invert_normals = false,
        -     )
        0     control_point = (vertices[1]+vertices[2]+vertices[3])/3
        0     normal = cross(vertices[2]-vertices[1], vertices[3]-vertices[1])
        0     normal /= norm(normal)
        - 
      384     radius = FLOWPanel.get_radius(control_point, vertices...)
        -     
        0     if invert_normals
        0         vertices = reverse(vertices)
        0         normal = -1 * normal
        -     end
        - 
        0     return Panel(vertices, control_point, normal, strength, radius)
        - end
        - 
        - function create_tripanel(;
        -         vertices = SVector{4}(
        -             rand(SVector{3,Float64}),
        -             rand(SVector{3,Float64}),
        -             rand(SVector{3,Float64}),
        -         ),
        -         strength = SVector{1}(1.0),
        -         invert_normals = false,
        -         seed = 123,
        -     )
        -     Random.seed!(seed)
        -     control_point = (vertices[1] + vertices[2] + vertices[3])/3
        -     normal = cross(vertices[2]-vertices[1], vertices[3]-vertices[1])
        -     normal /= norm(normal)
        - 
        -     radius = FLOWPanel.get_radius(control_point, vertices...)
        -     
        -     if invert_normals
        -         vertices = reverse(vertices)
        -         normal = -1 * normal
        -     end
        - 
        -     return Panel(vertices, control_point, normal, strength, radius)
        - end
        - 
        - function test_velocity(target, panel, kernel=ConstantSource())
        0     this_potential(target) = induced(target, panel, kernel, DerivativesSwitch(true, false, false, false))[1]
        0     return -ForwardDiff.gradient(this_potential, target)
        - end
        - 
        - function test_gradient(target, panel, kernel=ConstantSource())
        0     this_velocity(target) = induced(target, panel, kernel, DerivativesSwitch(false, false, true, false))[2]
        0     return ForwardDiff.jacobian(this_velocity, target)
        - end
        - 
        0 function create_sphere_structured(kernel, center=SVector{3}(0.0,0.0,0.0);
        -         radius=1.0, n_phi=20, n_theta=10, d_theta=5*pi/180,
        -         invert_normals=true,
        -     )
    37504     corner_grid = zeros(SVector{3,Float64},n_phi+1,n_theta+1,1)
        0     for (itheta,theta) in enumerate(range(d_theta,stop=pi-d_theta,length=n_theta+1))
        0         for (iphi,phi) in enumerate(range(0,stop=2*pi,length=n_phi+1))
        0             corner_grid[iphi,itheta] = SVector{3}(
        -                 radius * sin(theta) * cos(phi),
        -                 radius * sin(theta) * sin(phi),
        -                 radius * cos(theta)
        -             ) + center
        0         end
        0     end
        - 
        0     return PanelArray(corner_grid, kernel; invert_normals)
        - end
        - 
        0 function create_sphere_unstructured(kernel, center=SVector{3}(0.0,0.0,0.0);
        -         radius=1.0, n_phi=4, n_theta=3,
        -         invert_normals=true,
        -     )
        0     n_points = 2 + (n_theta-1) * n_phi
        0     n_mesh_cells = n_phi*2 + n_phi*(n_theta-2)*2
    44640     points = Vector{SVector{3,Float64}}(undef,n_points)
   176912     meshcells = Vector{WriteVTK.MeshCell{WriteVTK.VTKCellType, SVector{3,Int64}}}(undef,n_mesh_cells)
        - 
        0     d_phi = 2*pi/n_phi
        -     ipoint_theta = 0
        0     for (itheta,theta) in enumerate(range(0,stop=pi,length=n_theta+1))
        0         phi_range = itheta == 1 || itheta == n_theta+1 ? (0.0:0.0) : range(0,stop=(n_phi-1)*d_phi,length=n_phi)
        0         stheta, ctheta = sincos(theta)
        0         for (iphi,phi) in enumerate(phi_range)
        0             phi -= d_phi / 2 * 0^iseven(itheta)
        0             sphi, cphi = sincos(phi)
        0             points[ipoint_theta + iphi] = SVector{3}(stheta*cphi, stheta*sphi, ctheta) + center
        0         end
        0         ipoint_theta += length(phi_range)
        0     end
        - 
        -     # add top
        -     i_meshcell = 1
        0     for ipoint in 2:1+n_phi
        0         ipoint_p1 = ipoint < n_phi+1 ? ipoint + 1 : 2
        0         meshcells[i_meshcell] = WriteVTK.MeshCell(WriteVTK.VTKCellTypes.VTK_TRIANGLE, SVector{3}(1,ipoint,ipoint_p1))
        0         i_meshcell += 1
        0     end
        - 
        -     # add middle sections
        0     for itheta in 2:n_theta-1
        0         for iphi in 1:n_phi
        0             ipoint1 = n_phi * (itheta-2) + iphi + 1
        0             if iseven(itheta)
        0                 ipoint2 = ipoint1+n_phi
        0                 ipoint3 = iphi < n_phi ? ipoint2 + 1 : n_phi * (itheta-1) + 2
        0                 meshcells[i_meshcell] = WriteVTK.MeshCell(WriteVTK.VTKCellTypes.VTK_TRIANGLE, SVector{3}(ipoint1,ipoint2,ipoint3))
        0                 i_meshcell += 1
        -                 ipoint2 = ipoint3
        0                 ipoint3 = iphi < n_phi ? ipoint1+1 : n_phi * (itheta-2) + 2
        0                 meshcells[i_meshcell] = WriteVTK.MeshCell(WriteVTK.VTKCellTypes.VTK_TRIANGLE, SVector{3}(ipoint1,ipoint2,ipoint3))
        0                 i_meshcell += 1
        -             else
        0                 ipoint2 = ipoint1 + n_phi
        0                 ipoint3 = iphi < n_phi ? ipoint1 + 1 : n_phi * (itheta-2) + 2
        0                 meshcells[i_meshcell] = WriteVTK.MeshCell(WriteVTK.VTKCellTypes.VTK_TRIANGLE, SVector{3}(ipoint1,ipoint2,ipoint3))
        0                 i_meshcell += 1
        -                 ipoint1 = ipoint3
        0                 ipoint3 = iphi < n_phi ? ipoint2+1 : n_phi * (itheta-1) + 2
        0                 meshcells[i_meshcell] = WriteVTK.MeshCell(WriteVTK.VTKCellTypes.VTK_TRIANGLE, SVector{3}(ipoint1,ipoint2,ipoint3))
        0                 i_meshcell += 1
        -             end
        0         end
        0     end
        - 
        -     # add bottom
        0     point1 = length(points)
        0     for ipoint in length(points)-1:-1:length(points)-n_phi
        -         point2 = ipoint
        0         point3 = ipoint == point1 - n_phi ? point1-1 : ipoint-1
        0         meshcells[i_meshcell] = WriteVTK.MeshCell(WriteVTK.VTKCellTypes.VTK_TRIANGLE, SVector{3}(point1, point2, point3))
        0         i_meshcell += 1
        0     end
        - 
        -     # create panels
        0     sphere = PanelArray(points, meshcells, kernel)
        0     return sphere
        - end
